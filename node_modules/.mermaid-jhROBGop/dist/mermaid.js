"use strict";
var __esbuild_esm_mermaid = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __name = (target, value2) => __defProp(target, "name", { value: value2, configurable: true });
  var __esm = (fn3, res) => function __init() {
    return fn3 && (res = (0, fn3[__getOwnPropNames(fn3)[0]])(fn3 = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // ../../node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/dayjs.min.js
  var require_dayjs_min = __commonJS({
    "../../node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/dayjs.min.js"(exports2, module2) {
      "use strict";
      !function(t4, e3) {
        "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = e3() : "function" == typeof define && define.amd ? define(e3) : (t4 = "undefined" != typeof globalThis ? globalThis : t4 || self).dayjs = e3();
      }(exports2, function() {
        "use strict";
        var t4 = 1e3, e3 = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", c3 = "month", f3 = "quarter", h2 = "year", d2 = "date", l2 = "Invalid Date", $3 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y5 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: /* @__PURE__ */ __name(function(t5) {
          var e4 = ["th", "st", "nd", "rd"], n3 = t5 % 100;
          return "[" + t5 + (e4[(n3 - 20) % 10] || e4[n3] || e4[0]) + "]";
        }, "ordinal") }, m2 = /* @__PURE__ */ __name(function(t5, e4, n3) {
          var r3 = String(t5);
          return !r3 || r3.length >= e4 ? t5 : "" + Array(e4 + 1 - r3.length).join(n3) + t5;
        }, "m"), v3 = { s: m2, z: /* @__PURE__ */ __name(function(t5) {
          var e4 = -t5.utcOffset(), n3 = Math.abs(e4), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
          return (e4 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i3, 2, "0");
        }, "z"), m: /* @__PURE__ */ __name(function t5(e4, n3) {
          if (e4.date() < n3.date()) return -t5(n3, e4);
          var r3 = 12 * (n3.year() - e4.year()) + (n3.month() - e4.month()), i3 = e4.clone().add(r3, c3), s3 = n3 - i3 < 0, u3 = e4.clone().add(r3 + (s3 ? -1 : 1), c3);
          return +(-(r3 + (n3 - i3) / (s3 ? i3 - u3 : u3 - i3)) || 0);
        }, "t"), a: /* @__PURE__ */ __name(function(t5) {
          return t5 < 0 ? Math.ceil(t5) || 0 : Math.floor(t5);
        }, "a"), p: /* @__PURE__ */ __name(function(t5) {
          return { M: c3, y: h2, w: o2, d: a2, D: d2, h: u2, m: s2, s: i2, ms: r2, Q: f3 }[t5] || String(t5 || "").toLowerCase().replace(/s$/, "");
        }, "p"), u: /* @__PURE__ */ __name(function(t5) {
          return void 0 === t5;
        }, "u") }, g2 = "en", D3 = {};
        D3[g2] = M2;
        var p3 = "$isDayjsObject", S3 = /* @__PURE__ */ __name(function(t5) {
          return t5 instanceof _2 || !(!t5 || !t5[p3]);
        }, "S"), w3 = /* @__PURE__ */ __name(function t5(e4, n3, r3) {
          var i3;
          if (!e4) return g2;
          if ("string" == typeof e4) {
            var s3 = e4.toLowerCase();
            D3[s3] && (i3 = s3), n3 && (D3[s3] = n3, i3 = s3);
            var u3 = e4.split("-");
            if (!i3 && u3.length > 1) return t5(u3[0]);
          } else {
            var a3 = e4.name;
            D3[a3] = e4, i3 = a3;
          }
          return !r3 && i3 && (g2 = i3), i3 || !r3 && g2;
        }, "t"), O2 = /* @__PURE__ */ __name(function(t5, e4) {
          if (S3(t5)) return t5.clone();
          var n3 = "object" == typeof e4 ? e4 : {};
          return n3.date = t5, n3.args = arguments, new _2(n3);
        }, "O"), b2 = v3;
        b2.l = w3, b2.i = S3, b2.w = function(t5, e4) {
          return O2(t5, { locale: e4.$L, utc: e4.$u, x: e4.$x, $offset: e4.$offset });
        };
        var _2 = function() {
          function M3(t5) {
            this.$L = w3(t5.locale, null, true), this.parse(t5), this.$x = this.$x || t5.x || {}, this[p3] = true;
          }
          __name(M3, "M");
          var m3 = M3.prototype;
          return m3.parse = function(t5) {
            this.$d = function(t6) {
              var e4 = t6.date, n3 = t6.utc;
              if (null === e4) return /* @__PURE__ */ new Date(NaN);
              if (b2.u(e4)) return /* @__PURE__ */ new Date();
              if (e4 instanceof Date) return new Date(e4);
              if ("string" == typeof e4 && !/Z$/i.test(e4)) {
                var r3 = e4.match($3);
                if (r3) {
                  var i3 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
                  return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
                }
              }
              return new Date(e4);
            }(t5), this.init();
          }, m3.init = function() {
            var t5 = this.$d;
            this.$y = t5.getFullYear(), this.$M = t5.getMonth(), this.$D = t5.getDate(), this.$W = t5.getDay(), this.$H = t5.getHours(), this.$m = t5.getMinutes(), this.$s = t5.getSeconds(), this.$ms = t5.getMilliseconds();
          }, m3.$utils = function() {
            return b2;
          }, m3.isValid = function() {
            return !(this.$d.toString() === l2);
          }, m3.isSame = function(t5, e4) {
            var n3 = O2(t5);
            return this.startOf(e4) <= n3 && n3 <= this.endOf(e4);
          }, m3.isAfter = function(t5, e4) {
            return O2(t5) < this.startOf(e4);
          }, m3.isBefore = function(t5, e4) {
            return this.endOf(e4) < O2(t5);
          }, m3.$g = function(t5, e4, n3) {
            return b2.u(t5) ? this[e4] : this.set(n3, t5);
          }, m3.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, m3.valueOf = function() {
            return this.$d.getTime();
          }, m3.startOf = function(t5, e4) {
            var n3 = this, r3 = !!b2.u(e4) || e4, f4 = b2.p(t5), l3 = /* @__PURE__ */ __name(function(t6, e6) {
              var i3 = b2.w(n3.$u ? Date.UTC(n3.$y, e6, t6) : new Date(n3.$y, e6, t6), n3);
              return r3 ? i3 : i3.endOf(a2);
            }, "l"), $4 = /* @__PURE__ */ __name(function(t6, e6) {
              return b2.w(n3.toDate()[t6].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e6)), n3);
            }, "$"), y6 = this.$W, M4 = this.$M, m4 = this.$D, v4 = "set" + (this.$u ? "UTC" : "");
            switch (f4) {
              case h2:
                return r3 ? l3(1, 0) : l3(31, 11);
              case c3:
                return r3 ? l3(1, M4) : l3(0, M4 + 1);
              case o2:
                var g3 = this.$locale().weekStart || 0, D4 = (y6 < g3 ? y6 + 7 : y6) - g3;
                return l3(r3 ? m4 - D4 : m4 + (6 - D4), M4);
              case a2:
              case d2:
                return $4(v4 + "Hours", 0);
              case u2:
                return $4(v4 + "Minutes", 1);
              case s2:
                return $4(v4 + "Seconds", 2);
              case i2:
                return $4(v4 + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, m3.endOf = function(t5) {
            return this.startOf(t5, false);
          }, m3.$set = function(t5, e4) {
            var n3, o3 = b2.p(t5), f4 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a2] = f4 + "Date", n3[d2] = f4 + "Date", n3[c3] = f4 + "Month", n3[h2] = f4 + "FullYear", n3[u2] = f4 + "Hours", n3[s2] = f4 + "Minutes", n3[i2] = f4 + "Seconds", n3[r2] = f4 + "Milliseconds", n3)[o3], $4 = o3 === a2 ? this.$D + (e4 - this.$W) : e4;
            if (o3 === c3 || o3 === h2) {
              var y6 = this.clone().set(d2, 1);
              y6.$d[l3]($4), y6.init(), this.$d = y6.set(d2, Math.min(this.$D, y6.daysInMonth())).$d;
            } else l3 && this.$d[l3]($4);
            return this.init(), this;
          }, m3.set = function(t5, e4) {
            return this.clone().$set(t5, e4);
          }, m3.get = function(t5) {
            return this[b2.p(t5)]();
          }, m3.add = function(r3, f4) {
            var d3, l3 = this;
            r3 = Number(r3);
            var $4 = b2.p(f4), y6 = /* @__PURE__ */ __name(function(t5) {
              var e4 = O2(l3);
              return b2.w(e4.date(e4.date() + Math.round(t5 * r3)), l3);
            }, "y");
            if ($4 === c3) return this.set(c3, this.$M + r3);
            if ($4 === h2) return this.set(h2, this.$y + r3);
            if ($4 === a2) return y6(1);
            if ($4 === o2) return y6(7);
            var M4 = (d3 = {}, d3[s2] = e3, d3[u2] = n2, d3[i2] = t4, d3)[$4] || 1, m4 = this.$d.getTime() + r3 * M4;
            return b2.w(m4, this);
          }, m3.subtract = function(t5, e4) {
            return this.add(-1 * t5, e4);
          }, m3.format = function(t5) {
            var e4 = this, n3 = this.$locale();
            if (!this.isValid()) return n3.invalidDate || l2;
            var r3 = t5 || "YYYY-MM-DDTHH:mm:ssZ", i3 = b2.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n3.weekdays, c4 = n3.months, f4 = n3.meridiem, h3 = /* @__PURE__ */ __name(function(t6, n4, i4, s4) {
              return t6 && (t6[n4] || t6(e4, r3)) || i4[n4].slice(0, s4);
            }, "h"), d3 = /* @__PURE__ */ __name(function(t6) {
              return b2.s(s3 % 12 || 12, t6, "0");
            }, "d"), $4 = f4 || function(t6, e6, n4) {
              var r4 = t6 < 12 ? "AM" : "PM";
              return n4 ? r4.toLowerCase() : r4;
            };
            return r3.replace(y5, function(t6, r4) {
              return r4 || function(t7) {
                switch (t7) {
                  case "YY":
                    return String(e4.$y).slice(-2);
                  case "YYYY":
                    return b2.s(e4.$y, 4, "0");
                  case "M":
                    return a3 + 1;
                  case "MM":
                    return b2.s(a3 + 1, 2, "0");
                  case "MMM":
                    return h3(n3.monthsShort, a3, c4, 3);
                  case "MMMM":
                    return h3(c4, a3);
                  case "D":
                    return e4.$D;
                  case "DD":
                    return b2.s(e4.$D, 2, "0");
                  case "d":
                    return String(e4.$W);
                  case "dd":
                    return h3(n3.weekdaysMin, e4.$W, o3, 2);
                  case "ddd":
                    return h3(n3.weekdaysShort, e4.$W, o3, 3);
                  case "dddd":
                    return o3[e4.$W];
                  case "H":
                    return String(s3);
                  case "HH":
                    return b2.s(s3, 2, "0");
                  case "h":
                    return d3(1);
                  case "hh":
                    return d3(2);
                  case "a":
                    return $4(s3, u3, true);
                  case "A":
                    return $4(s3, u3, false);
                  case "m":
                    return String(u3);
                  case "mm":
                    return b2.s(u3, 2, "0");
                  case "s":
                    return String(e4.$s);
                  case "ss":
                    return b2.s(e4.$s, 2, "0");
                  case "SSS":
                    return b2.s(e4.$ms, 3, "0");
                  case "Z":
                    return i3;
                }
                return null;
              }(t6) || i3.replace(":", "");
            });
          }, m3.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, m3.diff = function(r3, d3, l3) {
            var $4, y6 = this, M4 = b2.p(d3), m4 = O2(r3), v4 = (m4.utcOffset() - this.utcOffset()) * e3, g3 = this - m4, D4 = /* @__PURE__ */ __name(function() {
              return b2.m(y6, m4);
            }, "D");
            switch (M4) {
              case h2:
                $4 = D4() / 12;
                break;
              case c3:
                $4 = D4();
                break;
              case f3:
                $4 = D4() / 3;
                break;
              case o2:
                $4 = (g3 - v4) / 6048e5;
                break;
              case a2:
                $4 = (g3 - v4) / 864e5;
                break;
              case u2:
                $4 = g3 / n2;
                break;
              case s2:
                $4 = g3 / e3;
                break;
              case i2:
                $4 = g3 / t4;
                break;
              default:
                $4 = g3;
            }
            return l3 ? $4 : b2.a($4);
          }, m3.daysInMonth = function() {
            return this.endOf(c3).$D;
          }, m3.$locale = function() {
            return D3[this.$L];
          }, m3.locale = function(t5, e4) {
            if (!t5) return this.$L;
            var n3 = this.clone(), r3 = w3(t5, e4, true);
            return r3 && (n3.$L = r3), n3;
          }, m3.clone = function() {
            return b2.w(this.$d, this);
          }, m3.toDate = function() {
            return new Date(this.valueOf());
          }, m3.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, m3.toISOString = function() {
            return this.$d.toISOString();
          }, m3.toString = function() {
            return this.$d.toUTCString();
          }, M3;
        }(), k2 = _2.prototype;
        return O2.prototype = k2, [["$ms", r2], ["$s", i2], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", c3], ["$y", h2], ["$D", d2]].forEach(function(t5) {
          k2[t5[1]] = function(e4) {
            return this.$g(e4, t5[0], t5[1]);
          };
        }), O2.extend = function(t5, e4) {
          return t5.$i || (t5(e4, _2, O2), t5.$i = true), O2;
        }, O2.locale = w3, O2.isDayjs = S3, O2.unix = function(t5) {
          return O2(1e3 * t5);
        }, O2.en = D3[g2], O2.Ls = D3, O2.p = {}, O2;
      });
    }
  });

  // src/logger.ts
  var import_dayjs, LEVELS, log, setLogLevel, format;
  var init_logger = __esm({
    "src/logger.ts"() {
      "use strict";
      import_dayjs = __toESM(require_dayjs_min(), 1);
      LEVELS = {
        trace: 0,
        debug: 1,
        info: 2,
        warn: 3,
        error: 4,
        fatal: 5
      };
      log = {
        trace: /* @__PURE__ */ __name((..._args) => {
        }, "trace"),
        debug: /* @__PURE__ */ __name((..._args) => {
        }, "debug"),
        info: /* @__PURE__ */ __name((..._args) => {
        }, "info"),
        warn: /* @__PURE__ */ __name((..._args) => {
        }, "warn"),
        error: /* @__PURE__ */ __name((..._args) => {
        }, "error"),
        fatal: /* @__PURE__ */ __name((..._args) => {
        }, "fatal")
      };
      setLogLevel = /* @__PURE__ */ __name(function(level = "fatal") {
        let numericLevel = LEVELS.fatal;
        if (typeof level === "string") {
          if (level.toLowerCase() in LEVELS) {
            numericLevel = LEVELS[level];
          }
        } else if (typeof level === "number") {
          numericLevel = level;
        }
        log.trace = () => {
        };
        log.debug = () => {
        };
        log.info = () => {
        };
        log.warn = () => {
        };
        log.error = () => {
        };
        log.fatal = () => {
        };
        if (numericLevel <= LEVELS.fatal) {
          log.fatal = console.error ? console.error.bind(console, format("FATAL"), "color: orange") : console.log.bind(console, "\x1B[35m", format("FATAL"));
        }
        if (numericLevel <= LEVELS.error) {
          log.error = console.error ? console.error.bind(console, format("ERROR"), "color: orange") : console.log.bind(console, "\x1B[31m", format("ERROR"));
        }
        if (numericLevel <= LEVELS.warn) {
          log.warn = console.warn ? console.warn.bind(console, format("WARN"), "color: orange") : console.log.bind(console, `\x1B[33m`, format("WARN"));
        }
        if (numericLevel <= LEVELS.info) {
          log.info = console.info ? console.info.bind(console, format("INFO"), "color: lightblue") : console.log.bind(console, "\x1B[34m", format("INFO"));
        }
        if (numericLevel <= LEVELS.debug) {
          log.debug = console.debug ? console.debug.bind(console, format("DEBUG"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", format("DEBUG"));
        }
        if (numericLevel <= LEVELS.trace) {
          log.trace = console.debug ? console.debug.bind(console, format("TRACE"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", format("TRACE"));
        }
      }, "setLogLevel");
      format = /* @__PURE__ */ __name((level) => {
        const time4 = (0, import_dayjs.default)().format("ss.SSS");
        return `%c${time4} : ${level} : `;
      }, "format");
    }
  });

  // ../../node_modules/.pnpm/@iconify+utils@2.1.33/node_modules/@iconify/utils/lib/icon/defaults.mjs
  var defaultIconDimensions, defaultIconTransformations, defaultIconProps, defaultExtendedIconProps;
  var init_defaults = __esm({
    "../../node_modules/.pnpm/@iconify+utils@2.1.33/node_modules/@iconify/utils/lib/icon/defaults.mjs"() {
      "use strict";
      defaultIconDimensions = Object.freeze(
        {
          left: 0,
          top: 0,
          width: 16,
          height: 16
        }
      );
      defaultIconTransformations = Object.freeze({
        rotate: 0,
        vFlip: false,
        hFlip: false
      });
      defaultIconProps = Object.freeze({
        ...defaultIconDimensions,
        ...defaultIconTransformations
      });
      defaultExtendedIconProps = Object.freeze({
        ...defaultIconProps,
        body: "",
        hidden: false
      });
    }
  });

  // ../../node_modules/.pnpm/@iconify+utils@2.1.33/node_modules/@iconify/utils/lib/customisations/defaults.mjs
  var defaultIconSizeCustomisations, defaultIconCustomisations;
  var init_defaults2 = __esm({
    "../../node_modules/.pnpm/@iconify+utils@2.1.33/node_modules/@iconify/utils/lib/customisations/defaults.mjs"() {
      "use strict";
      init_defaults();
      defaultIconSizeCustomisations = Object.freeze({
        width: null,
        height: null
      });
      defaultIconCustomisations = Object.freeze({
        // Dimensions
        ...defaultIconSizeCustomisations,
        // Transformations
        ...defaultIconTransformations
      });
    }
  });

  // ../../node_modules/.pnpm/@iconify+utils@2.1.33/node_modules/@iconify/utils/lib/icon/name.mjs
  var matchIconName, stringToIcon, validateIconName;
  var init_name = __esm({
    "../../node_modules/.pnpm/@iconify+utils@2.1.33/node_modules/@iconify/utils/lib/icon/name.mjs"() {
      "use strict";
      matchIconName = /^[a-z0-9]+(-[a-z0-9]+)*$/;
      stringToIcon = /* @__PURE__ */ __name((value2, validate2, allowSimpleName, provider = "") => {
        const colonSeparated = value2.split(":");
        if (value2.slice(0, 1) === "@") {
          if (colonSeparated.length < 2 || colonSeparated.length > 3) {
            return null;
          }
          provider = colonSeparated.shift().slice(1);
        }
        if (colonSeparated.length > 3 || !colonSeparated.length) {
          return null;
        }
        if (colonSeparated.length > 1) {
          const name2 = colonSeparated.pop();
          const prefix = colonSeparated.pop();
          const result = {
            // Allow provider without '@': "provider:prefix:name"
            provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,
            prefix,
            name: name2
          };
          return validate2 && !validateIconName(result) ? null : result;
        }
        const name = colonSeparated[0];
        const dashSeparated = name.split("-");
        if (dashSeparated.length > 1) {
          const result = {
            provider,
            prefix: dashSeparated.shift(),
            name: dashSeparated.join("-")
          };
          return validate2 && !validateIconName(result) ? null : result;
        }
        if (allowSimpleName && provider === "") {
          const result = {
            provider,
            prefix: "",
            name
          };
          return validate2 && !validateIconName(result, allowSimpleName) ? null : result;
        }
        return null;
      }, "stringToIcon");
      validateIconName = /* @__PURE__ */ __name((icon2, allowSimpleName) => {
        if (!icon2) {
          return false;
        }
        return !!((icon2.provider === "" || icon2.provider.match(matchIconName)) && (allowSimpleName && icon2.prefix === "" || icon2.prefix.match(matchIconName)) && icon2.name.match(matchIconName));
      }, "validateIconName");
    }
  });

  // ../../node_modules/.pnpm/@iconify+utils@2.1.33/node_modules/@iconify/utils/lib/icon/transformations.mjs
  function mergeIconTransformations(obj1, obj2) {
    const result = {};
    if (!obj1.hFlip !== !obj2.hFlip) {
      result.hFlip = true;
    }
    if (!obj1.vFlip !== !obj2.vFlip) {
      result.vFlip = true;
    }
    const rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;
    if (rotate) {
      result.rotate = rotate;
    }
    return result;
  }
  var init_transformations = __esm({
    "../../node_modules/.pnpm/@iconify+utils@2.1.33/node_modules/@iconify/utils/lib/icon/transformations.mjs"() {
      "use strict";
      __name(mergeIconTransformations, "mergeIconTransformations");
    }
  });

  // ../../node_modules/.pnpm/@iconify+utils@2.1.33/node_modules/@iconify/utils/lib/icon/merge.mjs
  function mergeIconData(parent4, child) {
    const result = mergeIconTransformations(parent4, child);
    for (const key in defaultExtendedIconProps) {
      if (key in defaultIconTransformations) {
        if (key in parent4 && !(key in result)) {
          result[key] = defaultIconTransformations[key];
        }
      } else if (key in child) {
        result[key] = child[key];
      } else if (key in parent4) {
        result[key] = parent4[key];
      }
    }
    return result;
  }
  var init_merge = __esm({
    "../../node_modules/.pnpm/@iconify+utils@2.1.33/node_modules/@iconify/utils/lib/icon/merge.mjs"() {
      "use strict";
      init_defaults();
      init_transformations();
      __name(mergeIconData, "mergeIconData");
    }
  });

  // ../../node_modules/.pnpm/@iconify+utils@2.1.33/node_modules/@iconify/utils/lib/icon-set/tree.mjs
  function getIconsTree(data5, names) {
    const icons = data5.icons;
    const aliases = data5.aliases || /* @__PURE__ */ Object.create(null);
    const resolved = /* @__PURE__ */ Object.create(null);
    function resolve3(name) {
      if (icons[name]) {
        return resolved[name] = [];
      }
      if (!(name in resolved)) {
        resolved[name] = null;
        const parent4 = aliases[name] && aliases[name].parent;
        const value2 = parent4 && resolve3(parent4);
        if (value2) {
          resolved[name] = [parent4].concat(value2);
        }
      }
      return resolved[name];
    }
    __name(resolve3, "resolve");
    (names || Object.keys(icons).concat(Object.keys(aliases))).forEach(resolve3);
    return resolved;
  }
  var init_tree = __esm({
    "../../node_modules/.pnpm/@iconify+utils@2.1.33/node_modules/@iconify/utils/lib/icon-set/tree.mjs"() {
      "use strict";
      __name(getIconsTree, "getIconsTree");
    }
  });

  // ../../node_modules/.pnpm/@iconify+utils@2.1.33/node_modules/@iconify/utils/lib/icon-set/get-icon.mjs
  function internalGetIconData(data5, name, tree) {
    const icons = data5.icons;
    const aliases = data5.aliases || /* @__PURE__ */ Object.create(null);
    let currentProps = {};
    function parse8(name2) {
      currentProps = mergeIconData(
        icons[name2] || aliases[name2],
        currentProps
      );
    }
    __name(parse8, "parse");
    parse8(name);
    tree.forEach(parse8);
    return mergeIconData(data5, currentProps);
  }
  function getIconData(data5, name) {
    if (data5.icons[name]) {
      return internalGetIconData(data5, name, []);
    }
    const tree = getIconsTree(data5, [name])[name];
    return tree ? internalGetIconData(data5, name, tree) : null;
  }
  var init_get_icon = __esm({
    "../../node_modules/.pnpm/@iconify+utils@2.1.33/node_modules/@iconify/utils/lib/icon-set/get-icon.mjs"() {
      "use strict";
      init_merge();
      init_tree();
      __name(internalGetIconData, "internalGetIconData");
      __name(getIconData, "getIconData");
    }
  });

  // ../../node_modules/.pnpm/@iconify+utils@2.1.33/node_modules/@iconify/utils/lib/svg/size.mjs
  function calculateSize(size5, ratio, precision) {
    if (ratio === 1) {
      return size5;
    }
    precision = precision || 100;
    if (typeof size5 === "number") {
      return Math.ceil(size5 * ratio * precision) / precision;
    }
    if (typeof size5 !== "string") {
      return size5;
    }
    const oldParts = size5.split(unitsSplit);
    if (oldParts === null || !oldParts.length) {
      return size5;
    }
    const newParts = [];
    let code = oldParts.shift();
    let isNumber = unitsTest.test(code);
    while (true) {
      if (isNumber) {
        const num = parseFloat(code);
        if (isNaN(num)) {
          newParts.push(code);
        } else {
          newParts.push(Math.ceil(num * ratio * precision) / precision);
        }
      } else {
        newParts.push(code);
      }
      code = oldParts.shift();
      if (code === void 0) {
        return newParts.join("");
      }
      isNumber = !isNumber;
    }
  }
  var unitsSplit, unitsTest;
  var init_size = __esm({
    "../../node_modules/.pnpm/@iconify+utils@2.1.33/node_modules/@iconify/utils/lib/svg/size.mjs"() {
      "use strict";
      unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
      unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
      __name(calculateSize, "calculateSize");
    }
  });

  // ../../node_modules/.pnpm/@iconify+utils@2.1.33/node_modules/@iconify/utils/lib/svg/defs.mjs
  function splitSVGDefs(content, tag2 = "defs") {
    let defs2 = "";
    const index = content.indexOf("<" + tag2);
    while (index >= 0) {
      const start3 = content.indexOf(">", index);
      const end2 = content.indexOf("</" + tag2);
      if (start3 === -1 || end2 === -1) {
        break;
      }
      const endEnd = content.indexOf(">", end2);
      if (endEnd === -1) {
        break;
      }
      defs2 += content.slice(start3 + 1, end2).trim();
      content = content.slice(0, index).trim() + content.slice(endEnd + 1);
    }
    return {
      defs: defs2,
      content
    };
  }
  function mergeDefsAndContent(defs2, content) {
    return defs2 ? "<defs>" + defs2 + "</defs>" + content : content;
  }
  function wrapSVGContent(body, start3, end2) {
    const split = splitSVGDefs(body);
    return mergeDefsAndContent(split.defs, start3 + split.content + end2);
  }
  var init_defs = __esm({
    "../../node_modules/.pnpm/@iconify+utils@2.1.33/node_modules/@iconify/utils/lib/svg/defs.mjs"() {
      "use strict";
      __name(splitSVGDefs, "splitSVGDefs");
      __name(mergeDefsAndContent, "mergeDefsAndContent");
      __name(wrapSVGContent, "wrapSVGContent");
    }
  });

  // ../../node_modules/.pnpm/@iconify+utils@2.1.33/node_modules/@iconify/utils/lib/svg/build.mjs
  function iconToSVG(icon2, customisations) {
    const fullIcon = {
      ...defaultIconProps,
      ...icon2
    };
    const fullCustomisations = {
      ...defaultIconCustomisations,
      ...customisations
    };
    const box = {
      left: fullIcon.left,
      top: fullIcon.top,
      width: fullIcon.width,
      height: fullIcon.height
    };
    let body = fullIcon.body;
    [fullIcon, fullCustomisations].forEach((props) => {
      const transformations = [];
      const hFlip = props.hFlip;
      const vFlip = props.vFlip;
      let rotation = props.rotate;
      if (hFlip) {
        if (vFlip) {
          rotation += 2;
        } else {
          transformations.push(
            "translate(" + (box.width + box.left).toString() + " " + (0 - box.top).toString() + ")"
          );
          transformations.push("scale(-1 1)");
          box.top = box.left = 0;
        }
      } else if (vFlip) {
        transformations.push(
          "translate(" + (0 - box.left).toString() + " " + (box.height + box.top).toString() + ")"
        );
        transformations.push("scale(1 -1)");
        box.top = box.left = 0;
      }
      let tempValue;
      if (rotation < 0) {
        rotation -= Math.floor(rotation / 4) * 4;
      }
      rotation = rotation % 4;
      switch (rotation) {
        case 1:
          tempValue = box.height / 2 + box.top;
          transformations.unshift(
            "rotate(90 " + tempValue.toString() + " " + tempValue.toString() + ")"
          );
          break;
        case 2:
          transformations.unshift(
            "rotate(180 " + (box.width / 2 + box.left).toString() + " " + (box.height / 2 + box.top).toString() + ")"
          );
          break;
        case 3:
          tempValue = box.width / 2 + box.left;
          transformations.unshift(
            "rotate(-90 " + tempValue.toString() + " " + tempValue.toString() + ")"
          );
          break;
      }
      if (rotation % 2 === 1) {
        if (box.left !== box.top) {
          tempValue = box.left;
          box.left = box.top;
          box.top = tempValue;
        }
        if (box.width !== box.height) {
          tempValue = box.width;
          box.width = box.height;
          box.height = tempValue;
        }
      }
      if (transformations.length) {
        body = wrapSVGContent(
          body,
          '<g transform="' + transformations.join(" ") + '">',
          "</g>"
        );
      }
    });
    const customisationsWidth = fullCustomisations.width;
    const customisationsHeight = fullCustomisations.height;
    const boxWidth = box.width;
    const boxHeight = box.height;
    let width3;
    let height2;
    if (customisationsWidth === null) {
      height2 = customisationsHeight === null ? "1em" : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
      width3 = calculateSize(height2, boxWidth / boxHeight);
    } else {
      width3 = customisationsWidth === "auto" ? boxWidth : customisationsWidth;
      height2 = customisationsHeight === null ? calculateSize(width3, boxHeight / boxWidth) : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
    }
    const attributes = {};
    const setAttr = /* @__PURE__ */ __name((prop, value2) => {
      if (!isUnsetKeyword(value2)) {
        attributes[prop] = value2.toString();
      }
    }, "setAttr");
    setAttr("width", width3);
    setAttr("height", height2);
    const viewBox = [box.left, box.top, boxWidth, boxHeight];
    attributes.viewBox = viewBox.join(" ");
    return {
      attributes,
      viewBox,
      body
    };
  }
  var isUnsetKeyword;
  var init_build = __esm({
    "../../node_modules/.pnpm/@iconify+utils@2.1.33/node_modules/@iconify/utils/lib/svg/build.mjs"() {
      "use strict";
      init_defaults();
      init_defaults2();
      init_size();
      init_defs();
      isUnsetKeyword = /* @__PURE__ */ __name((value2) => value2 === "unset" || value2 === "undefined" || value2 === "none", "isUnsetKeyword");
      __name(iconToSVG, "iconToSVG");
    }
  });

  // ../../node_modules/.pnpm/@iconify+utils@2.1.33/node_modules/@iconify/utils/lib/svg/id.mjs
  function replaceIDs(body, prefix = randomPrefix) {
    const ids = [];
    let match2;
    while (match2 = regex.exec(body)) {
      ids.push(match2[1]);
    }
    if (!ids.length) {
      return body;
    }
    const suffix = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
    ids.forEach((id28) => {
      const newID = typeof prefix === "function" ? prefix(id28) : prefix + (counter++).toString();
      const escapedID = id28.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      body = body.replace(
        // Allowed characters before id: [#;"]
        // Allowed characters after id: [)"], .[a-z]
        new RegExp('([#;"])(' + escapedID + ')([")]|\\.[a-z])', "g"),
        "$1" + newID + suffix + "$3"
      );
    });
    body = body.replace(new RegExp(suffix, "g"), "");
    return body;
  }
  var regex, randomPrefix, counter;
  var init_id = __esm({
    "../../node_modules/.pnpm/@iconify+utils@2.1.33/node_modules/@iconify/utils/lib/svg/id.mjs"() {
      "use strict";
      regex = /\sid="(\S+)"/g;
      randomPrefix = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
      counter = 0;
      __name(replaceIDs, "replaceIDs");
    }
  });

  // ../../node_modules/.pnpm/@iconify+utils@2.1.33/node_modules/@iconify/utils/lib/svg/html.mjs
  function iconToHTML(body, attributes) {
    let renderAttribsHTML = body.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
    for (const attr in attributes) {
      renderAttribsHTML += " " + attr + '="' + attributes[attr] + '"';
    }
    return '<svg xmlns="http://www.w3.org/2000/svg"' + renderAttribsHTML + ">" + body + "</svg>";
  }
  var init_html = __esm({
    "../../node_modules/.pnpm/@iconify+utils@2.1.33/node_modules/@iconify/utils/lib/svg/html.mjs"() {
      "use strict";
      __name(iconToHTML, "iconToHTML");
    }
  });

  // ../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
  var require_ms = __commonJS({
    "../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js"(exports2, module2) {
      "use strict";
      var s2 = 1e3;
      var m2 = s2 * 60;
      var h2 = m2 * 60;
      var d2 = h2 * 24;
      var w3 = d2 * 7;
      var y5 = d2 * 365.25;
      module2.exports = function(val, options3) {
        options3 = options3 || {};
        var type3 = typeof val;
        if (type3 === "string" && val.length > 0) {
          return parse8(val);
        } else if (type3 === "number" && isFinite(val)) {
          return options3.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error(
          "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
        );
      };
      function parse8(str2) {
        str2 = String(str2);
        if (str2.length > 100) {
          return;
        }
        var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str2
        );
        if (!match2) {
          return;
        }
        var n2 = parseFloat(match2[1]);
        var type3 = (match2[2] || "ms").toLowerCase();
        switch (type3) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n2 * y5;
          case "weeks":
          case "week":
          case "w":
            return n2 * w3;
          case "days":
          case "day":
          case "d":
            return n2 * d2;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n2 * h2;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n2 * m2;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n2 * s2;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n2;
          default:
            return void 0;
        }
      }
      __name(parse8, "parse");
      function fmtShort(ms3) {
        var msAbs = Math.abs(ms3);
        if (msAbs >= d2) {
          return Math.round(ms3 / d2) + "d";
        }
        if (msAbs >= h2) {
          return Math.round(ms3 / h2) + "h";
        }
        if (msAbs >= m2) {
          return Math.round(ms3 / m2) + "m";
        }
        if (msAbs >= s2) {
          return Math.round(ms3 / s2) + "s";
        }
        return ms3 + "ms";
      }
      __name(fmtShort, "fmtShort");
      function fmtLong(ms3) {
        var msAbs = Math.abs(ms3);
        if (msAbs >= d2) {
          return plural(ms3, msAbs, d2, "day");
        }
        if (msAbs >= h2) {
          return plural(ms3, msAbs, h2, "hour");
        }
        if (msAbs >= m2) {
          return plural(ms3, msAbs, m2, "minute");
        }
        if (msAbs >= s2) {
          return plural(ms3, msAbs, s2, "second");
        }
        return ms3 + " ms";
      }
      __name(fmtLong, "fmtLong");
      function plural(ms3, msAbs, n2, name) {
        var isPlural = msAbs >= n2 * 1.5;
        return Math.round(ms3 / n2) + " " + name + (isPlural ? "s" : "");
      }
      __name(plural, "plural");
    }
  });

  // ../../node_modules/.pnpm/debug@4.3.7_supports-color@8.1.1/node_modules/debug/src/common.js
  var require_common = __commonJS({
    "../../node_modules/.pnpm/debug@4.3.7_supports-color@8.1.1/node_modules/debug/src/common.js"(exports2, module2) {
      "use strict";
      function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        createDebug.destroy = destroy2;
        Object.keys(env).forEach((key) => {
          createDebug[key] = env[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          let hash = 0;
          for (let i2 = 0; i2 < namespace.length; i2++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i2);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        __name(selectColor, "selectColor");
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug(...args) {
            if (!debug.enabled) {
              return;
            }
            const self2 = debug;
            const curr = Number(/* @__PURE__ */ new Date());
            const ms3 = curr - (prevTime || curr);
            self2.diff = ms3;
            self2.prev = prevTime;
            self2.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format3) => {
              if (match2 === "%%") {
                return "%";
              }
              index++;
              const formatter = createDebug.formatters[format3];
              if (typeof formatter === "function") {
                const val = args[index];
                match2 = formatter.call(self2, val);
                args.splice(index, 1);
                index--;
              }
              return match2;
            });
            createDebug.formatArgs.call(self2, args);
            const logFn = self2.log || createDebug.log;
            logFn.apply(self2, args);
          }
          __name(debug, "debug");
          debug.namespace = namespace;
          debug.useColors = createDebug.useColors();
          debug.color = createDebug.selectColor(namespace);
          debug.extend = extend5;
          debug.destroy = createDebug.destroy;
          Object.defineProperty(debug, "enabled", {
            enumerable: true,
            configurable: false,
            get: /* @__PURE__ */ __name(() => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }
              return enabledCache;
            }, "get"),
            set: /* @__PURE__ */ __name((v3) => {
              enableOverride = v3;
            }, "set")
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug);
          }
          return debug;
        }
        __name(createDebug, "createDebug");
        function extend5(namespace, delimiter3) {
          const newDebug = createDebug(this.namespace + (typeof delimiter3 === "undefined" ? ":" : delimiter3) + namespace);
          newDebug.log = this.log;
          return newDebug;
        }
        __name(extend5, "extend");
        function enable(namespaces2) {
          createDebug.save(namespaces2);
          createDebug.namespaces = namespaces2;
          createDebug.names = [];
          createDebug.skips = [];
          let i2;
          const split = (typeof namespaces2 === "string" ? namespaces2 : "").split(/[\s,]+/);
          const len = split.length;
          for (i2 = 0; i2 < len; i2++) {
            if (!split[i2]) {
              continue;
            }
            namespaces2 = split[i2].replace(/\*/g, ".*?");
            if (namespaces2[0] === "-") {
              createDebug.skips.push(new RegExp("^" + namespaces2.slice(1) + "$"));
            } else {
              createDebug.names.push(new RegExp("^" + namespaces2 + "$"));
            }
          }
        }
        __name(enable, "enable");
        function disable() {
          const namespaces2 = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
          ].join(",");
          createDebug.enable("");
          return namespaces2;
        }
        __name(disable, "disable");
        function enabled(name) {
          if (name[name.length - 1] === "*") {
            return true;
          }
          let i2;
          let len;
          for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
            if (createDebug.skips[i2].test(name)) {
              return false;
            }
          }
          for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
            if (createDebug.names[i2].test(name)) {
              return true;
            }
          }
          return false;
        }
        __name(enabled, "enabled");
        function toNamespace(regexp) {
          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        __name(toNamespace, "toNamespace");
        function coerce(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        __name(coerce, "coerce");
        function destroy2() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        __name(destroy2, "destroy");
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      __name(setup, "setup");
      module2.exports = setup;
    }
  });

  // ../../node_modules/.pnpm/debug@4.3.7_supports-color@8.1.1/node_modules/debug/src/browser.js
  var require_browser = __commonJS({
    "../../node_modules/.pnpm/debug@4.3.7_supports-color@8.1.1/node_modules/debug/src/browser.js"(exports2, module2) {
      "use strict";
      exports2.formatArgs = formatArgs;
      exports2.save = save;
      exports2.load = load2;
      exports2.useColors = useColors;
      exports2.storage = localstorage();
      exports2.destroy = /* @__PURE__ */ (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports2.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        let m2;
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
        typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      __name(useColors, "useColors");
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c3 = "color: " + this.color;
        args.splice(1, 0, c3, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match2) => {
          if (match2 === "%%") {
            return;
          }
          index++;
          if (match2 === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c3);
      }
      __name(formatArgs, "formatArgs");
      exports2.log = console.debug || console.log || (() => {
      });
      function save(namespaces2) {
        try {
          if (namespaces2) {
            exports2.storage.setItem("debug", namespaces2);
          } else {
            exports2.storage.removeItem("debug");
          }
        } catch (error3) {
        }
      }
      __name(save, "save");
      function load2() {
        let r2;
        try {
          r2 = exports2.storage.getItem("debug");
        } catch (error3) {
        }
        if (!r2 && typeof process !== "undefined" && "env" in process) {
          r2 = process.env.DEBUG;
        }
        return r2;
      }
      __name(load2, "load");
      function localstorage() {
        try {
          return localStorage;
        } catch (error3) {
        }
      }
      __name(localstorage, "localstorage");
      module2.exports = require_common()(exports2);
      var { formatters } = module2.exports;
      formatters.j = function(v3) {
        try {
          return JSON.stringify(v3);
        } catch (error3) {
          return "[UnexpectedJSONParseError]: " + error3.message;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/@iconify+utils@2.1.33/node_modules/@iconify/utils/lib/index.mjs
  var import_debug;
  var init_lib = __esm({
    "../../node_modules/.pnpm/@iconify+utils@2.1.33/node_modules/@iconify/utils/lib/index.mjs"() {
      "use strict";
      init_name();
      init_get_icon();
      init_build();
      init_id();
      init_html();
      import_debug = __toESM(require_browser(), 1);
    }
  });

  // src/rendering-util/icons.ts
  var unknownIcon, iconsStore, loaderStore, registerIconPacks, getRegisteredIconData, getIconSVG;
  var init_icons = __esm({
    "src/rendering-util/icons.ts"() {
      "use strict";
      init_logger();
      init_lib();
      unknownIcon = {
        body: '<g><rect width="80" height="80" style="fill: #087ebf; stroke-width: 0px;"/><text transform="translate(21.16 64.67)" style="fill: #fff; font-family: ArialMT, Arial; font-size: 67.75px;"><tspan x="0" y="0">?</tspan></text></g>',
        height: 80,
        width: 80
      };
      iconsStore = /* @__PURE__ */ new Map();
      loaderStore = /* @__PURE__ */ new Map();
      registerIconPacks = /* @__PURE__ */ __name((iconLoaders) => {
        for (const iconLoader of iconLoaders) {
          if (!iconLoader.name) {
            throw new Error(
              'Invalid icon loader. Must have a "name" property with non-empty string value.'
            );
          }
          log.debug("Registering icon pack:", iconLoader.name);
          if ("loader" in iconLoader) {
            loaderStore.set(iconLoader.name, iconLoader.loader);
          } else if ("icons" in iconLoader) {
            iconsStore.set(iconLoader.name, iconLoader.icons);
          } else {
            log.error("Invalid icon loader:", iconLoader);
            throw new Error('Invalid icon loader. Must have either "icons" or "loader" property.');
          }
        }
      }, "registerIconPacks");
      getRegisteredIconData = /* @__PURE__ */ __name(async (iconName, fallbackPrefix) => {
        const data5 = stringToIcon(iconName, true, fallbackPrefix !== void 0);
        if (!data5) {
          throw new Error(`Invalid icon name: ${iconName}`);
        }
        const prefix = data5.prefix || fallbackPrefix;
        if (!prefix) {
          throw new Error(`Icon name must contain a prefix: ${iconName}`);
        }
        let icons = iconsStore.get(prefix);
        if (!icons) {
          const loader27 = loaderStore.get(prefix);
          if (!loader27) {
            throw new Error(`Icon set not found: ${data5.prefix}`);
          }
          try {
            const loaded = await loader27();
            icons = { ...loaded, prefix };
            iconsStore.set(prefix, icons);
          } catch (e3) {
            log.error(e3);
            throw new Error(`Failed to load icon set: ${data5.prefix}`);
          }
        }
        const iconData = getIconData(icons, data5.name);
        if (!iconData) {
          throw new Error(`Icon not found: ${iconName}`);
        }
        return iconData;
      }, "getRegisteredIconData");
      getIconSVG = /* @__PURE__ */ __name(async (iconName, customisations) => {
        let iconData;
        try {
          iconData = await getRegisteredIconData(iconName, customisations?.fallbackPrefix);
        } catch (e3) {
          log.error(e3);
          iconData = unknownIcon;
        }
        const renderData = iconToSVG(iconData, customisations);
        const svg2 = iconToHTML(replaceIDs(renderData.body), renderData.attributes);
        return svg2;
      }, "getIconSVG");
    }
  });

  // ../../node_modules/.pnpm/ts-dedent@2.2.0/node_modules/ts-dedent/esm/index.js
  function dedent(templ) {
    var values2 = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      values2[_i - 1] = arguments[_i];
    }
    var strings = Array.from(typeof templ === "string" ? [templ] : templ);
    strings[strings.length - 1] = strings[strings.length - 1].replace(/\r?\n([\t ]*)$/, "");
    var indentLengths = strings.reduce(function(arr, str2) {
      var matches33 = str2.match(/\n([\t ]+|(?!\s).)/g);
      if (matches33) {
        return arr.concat(matches33.map(function(match2) {
          var _a, _b;
          return (_b = (_a = match2.match(/[\t ]/g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
        }));
      }
      return arr;
    }, []);
    if (indentLengths.length) {
      var pattern_1 = new RegExp("\n[	 ]{" + Math.min.apply(Math, indentLengths) + "}", "g");
      strings = strings.map(function(str2) {
        return str2.replace(pattern_1, "\n");
      });
    }
    strings[0] = strings[0].replace(/^\r?\n/, "");
    var string3 = strings[0];
    values2.forEach(function(value2, i2) {
      var endentations = string3.match(/(?:^|\n)( *)$/);
      var endentation = endentations ? endentations[1] : "";
      var indentedValue = value2;
      if (typeof value2 === "string" && value2.includes("\n")) {
        indentedValue = String(value2).split("\n").map(function(str2, i3) {
          return i3 === 0 ? str2 : "" + endentation + str2;
        }).join("\n");
      }
      string3 += indentedValue + strings[i2 + 1];
    });
    return string3;
  }
  var init_esm = __esm({
    "../../node_modules/.pnpm/ts-dedent@2.2.0/node_modules/ts-dedent/esm/index.js"() {
      "use strict";
      __name(dedent, "dedent");
    }
  });

  // src/diagram-api/regexes.ts
  var frontMatterRegex, directiveRegex, anyCommentRegex;
  var init_regexes = __esm({
    "src/diagram-api/regexes.ts"() {
      "use strict";
      frontMatterRegex = /^-{3}\s*[\n\r](.*?)[\n\r]-{3}\s*[\n\r]+/s;
      directiveRegex = /%{2}{\s*(?:(\w+)\s*:|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi;
      anyCommentRegex = /\s*%%.*\n/gm;
    }
  });

  // src/errors.ts
  var UnknownDiagramError;
  var init_errors = __esm({
    "src/errors.ts"() {
      "use strict";
      UnknownDiagramError = class extends Error {
        static {
          __name(this, "UnknownDiagramError");
        }
        constructor(message) {
          super(message);
          this.name = "UnknownDiagramError";
        }
      };
    }
  });

  // src/diagram-api/detectType.ts
  var detectors, detectType, registerLazyLoadedDiagrams, addDetector, getDiagramLoader;
  var init_detectType = __esm({
    "src/diagram-api/detectType.ts"() {
      "use strict";
      init_logger();
      init_regexes();
      init_errors();
      detectors = {};
      detectType = /* @__PURE__ */ __name(function(text4, config6) {
        text4 = text4.replace(frontMatterRegex, "").replace(directiveRegex, "").replace(anyCommentRegex, "\n");
        for (const [key, { detector: detector26 }] of Object.entries(detectors)) {
          const diagram25 = detector26(text4, config6);
          if (diagram25) {
            return key;
          }
        }
        throw new UnknownDiagramError(
          `No diagram type detected matching given configuration for text: ${text4}`
        );
      }, "detectType");
      registerLazyLoadedDiagrams = /* @__PURE__ */ __name((...diagrams2) => {
        for (const { id: id28, detector: detector26, loader: loader27 } of diagrams2) {
          addDetector(id28, detector26, loader27);
        }
      }, "registerLazyLoadedDiagrams");
      addDetector = /* @__PURE__ */ __name((key, detector26, loader27) => {
        if (detectors[key]) {
          log.warn(`Detector with key ${key} already exists. Overwriting.`);
        }
        detectors[key] = { detector: detector26, loader: loader27 };
        log.debug(`Detector with key ${key} added${loader27 ? " with loader" : ""}`);
      }, "addDetector");
      getDiagramLoader = /* @__PURE__ */ __name((key) => {
        return detectors[key].loader;
      }, "getDiagramLoader");
    }
  });

  // src/diagrams/c4/parser/c4Diagram.jison
  var parser, c4Diagram_default;
  var init_c4Diagram = __esm({
    "src/diagrams/c4/parser/c4Diagram.jison"() {
      "use strict";
      parser = function() {
        var o2 = /* @__PURE__ */ __name(function(k2, v3, o3, l2) {
          for (o3 = o3 || {}, l2 = k2.length; l2--; o3[k2[l2]] = v3) ;
          return o3;
        }, "o"), $V0 = [1, 24], $V1 = [1, 25], $V2 = [1, 26], $V3 = [1, 27], $V4 = [1, 28], $V5 = [1, 63], $V6 = [1, 64], $V7 = [1, 65], $V8 = [1, 66], $V9 = [1, 67], $Va = [1, 68], $Vb = [1, 69], $Vc = [1, 29], $Vd = [1, 30], $Ve = [1, 31], $Vf = [1, 32], $Vg = [1, 33], $Vh = [1, 34], $Vi = [1, 35], $Vj = [1, 36], $Vk = [1, 37], $Vl = [1, 38], $Vm = [1, 39], $Vn = [1, 40], $Vo = [1, 41], $Vp = [1, 42], $Vq = [1, 43], $Vr = [1, 44], $Vs = [1, 45], $Vt = [1, 46], $Vu = [1, 47], $Vv = [1, 48], $Vw = [1, 50], $Vx = [1, 51], $Vy = [1, 52], $Vz = [1, 53], $VA = [1, 54], $VB = [1, 55], $VC = [1, 56], $VD = [1, 57], $VE = [1, 58], $VF = [1, 59], $VG = [1, 60], $VH = [14, 42], $VI = [14, 34, 36, 37, 38, 39, 40, 41, 42, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74], $VJ = [12, 14, 34, 36, 37, 38, 39, 40, 41, 42, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74], $VK = [1, 82], $VL = [1, 83], $VM = [1, 84], $VN = [1, 85], $VO = [12, 14, 42], $VP = [12, 14, 33, 42], $VQ = [12, 14, 33, 42, 76, 77, 79, 80], $VR = [12, 33], $VS = [34, 36, 37, 38, 39, 40, 41, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74];
        var parser23 = {
          trace: /* @__PURE__ */ __name(function trace() {
          }, "trace"),
          yy: {},
          symbols_: { "error": 2, "start": 3, "mermaidDoc": 4, "direction": 5, "direction_tb": 6, "direction_bt": 7, "direction_rl": 8, "direction_lr": 9, "graphConfig": 10, "C4_CONTEXT": 11, "NEWLINE": 12, "statements": 13, "EOF": 14, "C4_CONTAINER": 15, "C4_COMPONENT": 16, "C4_DYNAMIC": 17, "C4_DEPLOYMENT": 18, "otherStatements": 19, "diagramStatements": 20, "otherStatement": 21, "title": 22, "accDescription": 23, "acc_title": 24, "acc_title_value": 25, "acc_descr": 26, "acc_descr_value": 27, "acc_descr_multiline_value": 28, "boundaryStatement": 29, "boundaryStartStatement": 30, "boundaryStopStatement": 31, "boundaryStart": 32, "LBRACE": 33, "ENTERPRISE_BOUNDARY": 34, "attributes": 35, "SYSTEM_BOUNDARY": 36, "BOUNDARY": 37, "CONTAINER_BOUNDARY": 38, "NODE": 39, "NODE_L": 40, "NODE_R": 41, "RBRACE": 42, "diagramStatement": 43, "PERSON": 44, "PERSON_EXT": 45, "SYSTEM": 46, "SYSTEM_DB": 47, "SYSTEM_QUEUE": 48, "SYSTEM_EXT": 49, "SYSTEM_EXT_DB": 50, "SYSTEM_EXT_QUEUE": 51, "CONTAINER": 52, "CONTAINER_DB": 53, "CONTAINER_QUEUE": 54, "CONTAINER_EXT": 55, "CONTAINER_EXT_DB": 56, "CONTAINER_EXT_QUEUE": 57, "COMPONENT": 58, "COMPONENT_DB": 59, "COMPONENT_QUEUE": 60, "COMPONENT_EXT": 61, "COMPONENT_EXT_DB": 62, "COMPONENT_EXT_QUEUE": 63, "REL": 64, "BIREL": 65, "REL_U": 66, "REL_D": 67, "REL_L": 68, "REL_R": 69, "REL_B": 70, "REL_INDEX": 71, "UPDATE_EL_STYLE": 72, "UPDATE_REL_STYLE": 73, "UPDATE_LAYOUT_CONFIG": 74, "attribute": 75, "STR": 76, "STR_KEY": 77, "STR_VALUE": 78, "ATTRIBUTE": 79, "ATTRIBUTE_EMPTY": 80, "$accept": 0, "$end": 1 },
          terminals_: { 2: "error", 6: "direction_tb", 7: "direction_bt", 8: "direction_rl", 9: "direction_lr", 11: "C4_CONTEXT", 12: "NEWLINE", 14: "EOF", 15: "C4_CONTAINER", 16: "C4_COMPONENT", 17: "C4_DYNAMIC", 18: "C4_DEPLOYMENT", 22: "title", 23: "accDescription", 24: "acc_title", 25: "acc_title_value", 26: "acc_descr", 27: "acc_descr_value", 28: "acc_descr_multiline_value", 33: "LBRACE", 34: "ENTERPRISE_BOUNDARY", 36: "SYSTEM_BOUNDARY", 37: "BOUNDARY", 38: "CONTAINER_BOUNDARY", 39: "NODE", 40: "NODE_L", 41: "NODE_R", 42: "RBRACE", 44: "PERSON", 45: "PERSON_EXT", 46: "SYSTEM", 47: "SYSTEM_DB", 48: "SYSTEM_QUEUE", 49: "SYSTEM_EXT", 50: "SYSTEM_EXT_DB", 51: "SYSTEM_EXT_QUEUE", 52: "CONTAINER", 53: "CONTAINER_DB", 54: "CONTAINER_QUEUE", 55: "CONTAINER_EXT", 56: "CONTAINER_EXT_DB", 57: "CONTAINER_EXT_QUEUE", 58: "COMPONENT", 59: "COMPONENT_DB", 60: "COMPONENT_QUEUE", 61: "COMPONENT_EXT", 62: "COMPONENT_EXT_DB", 63: "COMPONENT_EXT_QUEUE", 64: "REL", 65: "BIREL", 66: "REL_U", 67: "REL_D", 68: "REL_L", 69: "REL_R", 70: "REL_B", 71: "REL_INDEX", 72: "UPDATE_EL_STYLE", 73: "UPDATE_REL_STYLE", 74: "UPDATE_LAYOUT_CONFIG", 76: "STR", 77: "STR_KEY", 78: "STR_VALUE", 79: "ATTRIBUTE", 80: "ATTRIBUTE_EMPTY" },
          productions_: [0, [3, 1], [3, 1], [5, 1], [5, 1], [5, 1], [5, 1], [4, 1], [10, 4], [10, 4], [10, 4], [10, 4], [10, 4], [13, 1], [13, 1], [13, 2], [19, 1], [19, 2], [19, 3], [21, 1], [21, 1], [21, 2], [21, 2], [21, 1], [29, 3], [30, 3], [30, 3], [30, 4], [32, 2], [32, 2], [32, 2], [32, 2], [32, 2], [32, 2], [32, 2], [31, 1], [20, 1], [20, 2], [20, 3], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 1], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [35, 1], [35, 2], [75, 1], [75, 2], [75, 1], [75, 1]],
          performAction: /* @__PURE__ */ __name(function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
            var $0 = $$.length - 1;
            switch (yystate) {
              case 3:
                yy.setDirection("TB");
                break;
              case 4:
                yy.setDirection("BT");
                break;
              case 5:
                yy.setDirection("RL");
                break;
              case 6:
                yy.setDirection("LR");
                break;
              case 8:
              case 9:
              case 10:
              case 11:
              case 12:
                yy.setC4Type($$[$0 - 3]);
                break;
              case 19:
                yy.setTitle($$[$0].substring(6));
                this.$ = $$[$0].substring(6);
                break;
              case 20:
                yy.setAccDescription($$[$0].substring(15));
                this.$ = $$[$0].substring(15);
                break;
              case 21:
                this.$ = $$[$0].trim();
                yy.setTitle(this.$);
                break;
              case 22:
              case 23:
                this.$ = $$[$0].trim();
                yy.setAccDescription(this.$);
                break;
              case 28:
                $$[$0].splice(2, 0, "ENTERPRISE");
                yy.addPersonOrSystemBoundary(...$$[$0]);
                this.$ = $$[$0];
                break;
              case 29:
                $$[$0].splice(2, 0, "SYSTEM");
                yy.addPersonOrSystemBoundary(...$$[$0]);
                this.$ = $$[$0];
                break;
              case 30:
                yy.addPersonOrSystemBoundary(...$$[$0]);
                this.$ = $$[$0];
                break;
              case 31:
                $$[$0].splice(2, 0, "CONTAINER");
                yy.addContainerBoundary(...$$[$0]);
                this.$ = $$[$0];
                break;
              case 32:
                yy.addDeploymentNode("node", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 33:
                yy.addDeploymentNode("nodeL", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 34:
                yy.addDeploymentNode("nodeR", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 35:
                yy.popBoundaryParseStack();
                break;
              case 39:
                yy.addPersonOrSystem("person", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 40:
                yy.addPersonOrSystem("external_person", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 41:
                yy.addPersonOrSystem("system", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 42:
                yy.addPersonOrSystem("system_db", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 43:
                yy.addPersonOrSystem("system_queue", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 44:
                yy.addPersonOrSystem("external_system", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 45:
                yy.addPersonOrSystem("external_system_db", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 46:
                yy.addPersonOrSystem("external_system_queue", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 47:
                yy.addContainer("container", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 48:
                yy.addContainer("container_db", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 49:
                yy.addContainer("container_queue", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 50:
                yy.addContainer("external_container", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 51:
                yy.addContainer("external_container_db", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 52:
                yy.addContainer("external_container_queue", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 53:
                yy.addComponent("component", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 54:
                yy.addComponent("component_db", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 55:
                yy.addComponent("component_queue", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 56:
                yy.addComponent("external_component", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 57:
                yy.addComponent("external_component_db", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 58:
                yy.addComponent("external_component_queue", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 60:
                yy.addRel("rel", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 61:
                yy.addRel("birel", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 62:
                yy.addRel("rel_u", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 63:
                yy.addRel("rel_d", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 64:
                yy.addRel("rel_l", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 65:
                yy.addRel("rel_r", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 66:
                yy.addRel("rel_b", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 67:
                $$[$0].splice(0, 1);
                yy.addRel("rel", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 68:
                yy.updateElStyle("update_el_style", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 69:
                yy.updateRelStyle("update_rel_style", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 70:
                yy.updateLayoutConfig("update_layout_config", ...$$[$0]);
                this.$ = $$[$0];
                break;
              case 71:
                this.$ = [$$[$0]];
                break;
              case 72:
                $$[$0].unshift($$[$0 - 1]);
                this.$ = $$[$0];
                break;
              case 73:
              case 75:
                this.$ = $$[$0].trim();
                break;
              case 74:
                let kv = {};
                kv[$$[$0 - 1].trim()] = $$[$0].trim();
                this.$ = kv;
                break;
              case 76:
                this.$ = "";
                break;
            }
          }, "anonymous"),
          table: [{ 3: 1, 4: 2, 5: 3, 6: [1, 5], 7: [1, 6], 8: [1, 7], 9: [1, 8], 10: 4, 11: [1, 9], 15: [1, 10], 16: [1, 11], 17: [1, 12], 18: [1, 13] }, { 1: [3] }, { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 7] }, { 1: [2, 3] }, { 1: [2, 4] }, { 1: [2, 5] }, { 1: [2, 6] }, { 12: [1, 14] }, { 12: [1, 15] }, { 12: [1, 16] }, { 12: [1, 17] }, { 12: [1, 18] }, { 13: 19, 19: 20, 20: 21, 21: 22, 22: $V0, 23: $V1, 24: $V2, 26: $V3, 28: $V4, 29: 49, 30: 61, 32: 62, 34: $V5, 36: $V6, 37: $V7, 38: $V8, 39: $V9, 40: $Va, 41: $Vb, 43: 23, 44: $Vc, 45: $Vd, 46: $Ve, 47: $Vf, 48: $Vg, 49: $Vh, 50: $Vi, 51: $Vj, 52: $Vk, 53: $Vl, 54: $Vm, 55: $Vn, 56: $Vo, 57: $Vp, 58: $Vq, 59: $Vr, 60: $Vs, 61: $Vt, 62: $Vu, 63: $Vv, 64: $Vw, 65: $Vx, 66: $Vy, 67: $Vz, 68: $VA, 69: $VB, 70: $VC, 71: $VD, 72: $VE, 73: $VF, 74: $VG }, { 13: 70, 19: 20, 20: 21, 21: 22, 22: $V0, 23: $V1, 24: $V2, 26: $V3, 28: $V4, 29: 49, 30: 61, 32: 62, 34: $V5, 36: $V6, 37: $V7, 38: $V8, 39: $V9, 40: $Va, 41: $Vb, 43: 23, 44: $Vc, 45: $Vd, 46: $Ve, 47: $Vf, 48: $Vg, 49: $Vh, 50: $Vi, 51: $Vj, 52: $Vk, 53: $Vl, 54: $Vm, 55: $Vn, 56: $Vo, 57: $Vp, 58: $Vq, 59: $Vr, 60: $Vs, 61: $Vt, 62: $Vu, 63: $Vv, 64: $Vw, 65: $Vx, 66: $Vy, 67: $Vz, 68: $VA, 69: $VB, 70: $VC, 71: $VD, 72: $VE, 73: $VF, 74: $VG }, { 13: 71, 19: 20, 20: 21, 21: 22, 22: $V0, 23: $V1, 24: $V2, 26: $V3, 28: $V4, 29: 49, 30: 61, 32: 62, 34: $V5, 36: $V6, 37: $V7, 38: $V8, 39: $V9, 40: $Va, 41: $Vb, 43: 23, 44: $Vc, 45: $Vd, 46: $Ve, 47: $Vf, 48: $Vg, 49: $Vh, 50: $Vi, 51: $Vj, 52: $Vk, 53: $Vl, 54: $Vm, 55: $Vn, 56: $Vo, 57: $Vp, 58: $Vq, 59: $Vr, 60: $Vs, 61: $Vt, 62: $Vu, 63: $Vv, 64: $Vw, 65: $Vx, 66: $Vy, 67: $Vz, 68: $VA, 69: $VB, 70: $VC, 71: $VD, 72: $VE, 73: $VF, 74: $VG }, { 13: 72, 19: 20, 20: 21, 21: 22, 22: $V0, 23: $V1, 24: $V2, 26: $V3, 28: $V4, 29: 49, 30: 61, 32: 62, 34: $V5, 36: $V6, 37: $V7, 38: $V8, 39: $V9, 40: $Va, 41: $Vb, 43: 23, 44: $Vc, 45: $Vd, 46: $Ve, 47: $Vf, 48: $Vg, 49: $Vh, 50: $Vi, 51: $Vj, 52: $Vk, 53: $Vl, 54: $Vm, 55: $Vn, 56: $Vo, 57: $Vp, 58: $Vq, 59: $Vr, 60: $Vs, 61: $Vt, 62: $Vu, 63: $Vv, 64: $Vw, 65: $Vx, 66: $Vy, 67: $Vz, 68: $VA, 69: $VB, 70: $VC, 71: $VD, 72: $VE, 73: $VF, 74: $VG }, { 13: 73, 19: 20, 20: 21, 21: 22, 22: $V0, 23: $V1, 24: $V2, 26: $V3, 28: $V4, 29: 49, 30: 61, 32: 62, 34: $V5, 36: $V6, 37: $V7, 38: $V8, 39: $V9, 40: $Va, 41: $Vb, 43: 23, 44: $Vc, 45: $Vd, 46: $Ve, 47: $Vf, 48: $Vg, 49: $Vh, 50: $Vi, 51: $Vj, 52: $Vk, 53: $Vl, 54: $Vm, 55: $Vn, 56: $Vo, 57: $Vp, 58: $Vq, 59: $Vr, 60: $Vs, 61: $Vt, 62: $Vu, 63: $Vv, 64: $Vw, 65: $Vx, 66: $Vy, 67: $Vz, 68: $VA, 69: $VB, 70: $VC, 71: $VD, 72: $VE, 73: $VF, 74: $VG }, { 14: [1, 74] }, o2($VH, [2, 13], { 43: 23, 29: 49, 30: 61, 32: 62, 20: 75, 34: $V5, 36: $V6, 37: $V7, 38: $V8, 39: $V9, 40: $Va, 41: $Vb, 44: $Vc, 45: $Vd, 46: $Ve, 47: $Vf, 48: $Vg, 49: $Vh, 50: $Vi, 51: $Vj, 52: $Vk, 53: $Vl, 54: $Vm, 55: $Vn, 56: $Vo, 57: $Vp, 58: $Vq, 59: $Vr, 60: $Vs, 61: $Vt, 62: $Vu, 63: $Vv, 64: $Vw, 65: $Vx, 66: $Vy, 67: $Vz, 68: $VA, 69: $VB, 70: $VC, 71: $VD, 72: $VE, 73: $VF, 74: $VG }), o2($VH, [2, 14]), o2($VI, [2, 16], { 12: [1, 76] }), o2($VH, [2, 36], { 12: [1, 77] }), o2($VJ, [2, 19]), o2($VJ, [2, 20]), { 25: [1, 78] }, { 27: [1, 79] }, o2($VJ, [2, 23]), { 35: 80, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 86, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 87, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 88, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 89, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 90, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 91, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 92, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 93, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 94, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 95, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 96, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 97, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 98, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 99, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 100, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 101, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 102, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 103, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 104, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, o2($VO, [2, 59]), { 35: 105, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 106, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 107, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 108, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 109, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 110, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 111, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 112, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 113, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 114, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 115, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 20: 116, 29: 49, 30: 61, 32: 62, 34: $V5, 36: $V6, 37: $V7, 38: $V8, 39: $V9, 40: $Va, 41: $Vb, 43: 23, 44: $Vc, 45: $Vd, 46: $Ve, 47: $Vf, 48: $Vg, 49: $Vh, 50: $Vi, 51: $Vj, 52: $Vk, 53: $Vl, 54: $Vm, 55: $Vn, 56: $Vo, 57: $Vp, 58: $Vq, 59: $Vr, 60: $Vs, 61: $Vt, 62: $Vu, 63: $Vv, 64: $Vw, 65: $Vx, 66: $Vy, 67: $Vz, 68: $VA, 69: $VB, 70: $VC, 71: $VD, 72: $VE, 73: $VF, 74: $VG }, { 12: [1, 118], 33: [1, 117] }, { 35: 119, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 120, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 121, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 122, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 123, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 124, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 35: 125, 75: 81, 76: $VK, 77: $VL, 79: $VM, 80: $VN }, { 14: [1, 126] }, { 14: [1, 127] }, { 14: [1, 128] }, { 14: [1, 129] }, { 1: [2, 8] }, o2($VH, [2, 15]), o2($VI, [2, 17], { 21: 22, 19: 130, 22: $V0, 23: $V1, 24: $V2, 26: $V3, 28: $V4 }), o2($VH, [2, 37], { 19: 20, 20: 21, 21: 22, 43: 23, 29: 49, 30: 61, 32: 62, 13: 131, 22: $V0, 23: $V1, 24: $V2, 26: $V3, 28: $V4, 34: $V5, 36: $V6, 37: $V7, 38: $V8, 39: $V9, 40: $Va, 41: $Vb, 44: $Vc, 45: $Vd, 46: $Ve, 47: $Vf, 48: $Vg, 49: $Vh, 50: $Vi, 51: $Vj, 52: $Vk, 53: $Vl, 54: $Vm, 55: $Vn, 56: $Vo, 57: $Vp, 58: $Vq, 59: $Vr, 60: $Vs, 61: $Vt, 62: $Vu, 63: $Vv, 64: $Vw, 65: $Vx, 66: $Vy, 67: $Vz, 68: $VA, 69: $VB, 70: $VC, 71: $VD, 72: $VE, 73: $VF, 74: $VG }), o2($VJ, [2, 21]), o2($VJ, [2, 22]), o2($VO, [2, 39]), o2($VP, [2, 71], { 75: 81, 35: 132, 76: $VK, 77: $VL, 79: $VM, 80: $VN }), o2($VQ, [2, 73]), { 78: [1, 133] }, o2($VQ, [2, 75]), o2($VQ, [2, 76]), o2($VO, [2, 40]), o2($VO, [2, 41]), o2($VO, [2, 42]), o2($VO, [2, 43]), o2($VO, [2, 44]), o2($VO, [2, 45]), o2($VO, [2, 46]), o2($VO, [2, 47]), o2($VO, [2, 48]), o2($VO, [2, 49]), o2($VO, [2, 50]), o2($VO, [2, 51]), o2($VO, [2, 52]), o2($VO, [2, 53]), o2($VO, [2, 54]), o2($VO, [2, 55]), o2($VO, [2, 56]), o2($VO, [2, 57]), o2($VO, [2, 58]), o2($VO, [2, 60]), o2($VO, [2, 61]), o2($VO, [2, 62]), o2($VO, [2, 63]), o2($VO, [2, 64]), o2($VO, [2, 65]), o2($VO, [2, 66]), o2($VO, [2, 67]), o2($VO, [2, 68]), o2($VO, [2, 69]), o2($VO, [2, 70]), { 31: 134, 42: [1, 135] }, { 12: [1, 136] }, { 33: [1, 137] }, o2($VR, [2, 28]), o2($VR, [2, 29]), o2($VR, [2, 30]), o2($VR, [2, 31]), o2($VR, [2, 32]), o2($VR, [2, 33]), o2($VR, [2, 34]), { 1: [2, 9] }, { 1: [2, 10] }, { 1: [2, 11] }, { 1: [2, 12] }, o2($VI, [2, 18]), o2($VH, [2, 38]), o2($VP, [2, 72]), o2($VQ, [2, 74]), o2($VO, [2, 24]), o2($VO, [2, 35]), o2($VS, [2, 25]), o2($VS, [2, 26], { 12: [1, 138] }), o2($VS, [2, 27])],
          defaultActions: { 2: [2, 1], 3: [2, 2], 4: [2, 7], 5: [2, 3], 6: [2, 4], 7: [2, 5], 8: [2, 6], 74: [2, 8], 126: [2, 9], 127: [2, 10], 128: [2, 11], 129: [2, 12] },
          parseError: /* @__PURE__ */ __name(function parseError(str2, hash) {
            if (hash.recoverable) {
              this.trace(str2);
            } else {
              var error3 = new Error(str2);
              error3.hash = hash;
              throw error3;
            }
          }, "parseError"),
          parse: /* @__PURE__ */ __name(function parse8(input) {
            var self2 = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF2 = 1;
            var args = lstack.slice.call(arguments, 1);
            var lexer3 = Object.create(this.lexer);
            var sharedState = { yy: {} };
            for (var k2 in this.yy) {
              if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
                sharedState.yy[k2] = this.yy[k2];
              }
            }
            lexer3.setInput(input, sharedState.yy);
            sharedState.yy.lexer = lexer3;
            sharedState.yy.parser = this;
            if (typeof lexer3.yylloc == "undefined") {
              lexer3.yylloc = {};
            }
            var yyloc = lexer3.yylloc;
            lstack.push(yyloc);
            var ranges = lexer3.options && lexer3.options.ranges;
            if (typeof sharedState.yy.parseError === "function") {
              this.parseError = sharedState.yy.parseError;
            } else {
              this.parseError = Object.getPrototypeOf(this).parseError;
            }
            function popStack(n2) {
              stack.length = stack.length - 2 * n2;
              vstack.length = vstack.length - n2;
              lstack.length = lstack.length - n2;
            }
            __name(popStack, "popStack");
            function lex2() {
              var token2;
              token2 = tstack.pop() || lexer3.lex() || EOF2;
              if (typeof token2 !== "number") {
                if (token2 instanceof Array) {
                  tstack = token2;
                  token2 = tstack.pop();
                }
                token2 = self2.symbols_[token2] || token2;
              }
              return token2;
            }
            __name(lex2, "lex");
            var symbol, preErrorSymbol, state5, action, a2, r2, yyval = {}, p3, len, newState2, expected;
            while (true) {
              state5 = stack[stack.length - 1];
              if (this.defaultActions[state5]) {
                action = this.defaultActions[state5];
              } else {
                if (symbol === null || typeof symbol == "undefined") {
                  symbol = lex2();
                }
                action = table[state5] && table[state5][symbol];
              }
              if (typeof action === "undefined" || !action.length || !action[0]) {
                var errStr = "";
                expected = [];
                for (p3 in table[state5]) {
                  if (this.terminals_[p3] && p3 > TERROR) {
                    expected.push("'" + this.terminals_[p3] + "'");
                  }
                }
                if (lexer3.showPosition) {
                  errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer3.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                } else {
                  errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF2 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                }
                this.parseError(errStr, {
                  text: lexer3.match,
                  token: this.terminals_[symbol] || symbol,
                  line: lexer3.yylineno,
                  loc: yyloc,
                  expected
                });
              }
              if (action[0] instanceof Array && action.length > 1) {
                throw new Error("Parse Error: multiple actions possible at state: " + state5 + ", token: " + symbol);
              }
              switch (action[0]) {
                case 1:
                  stack.push(symbol);
                  vstack.push(lexer3.yytext);
                  lstack.push(lexer3.yylloc);
                  stack.push(action[1]);
                  symbol = null;
                  if (!preErrorSymbol) {
                    yyleng = lexer3.yyleng;
                    yytext = lexer3.yytext;
                    yylineno = lexer3.yylineno;
                    yyloc = lexer3.yylloc;
                    if (recovering > 0) {
                      recovering--;
                    }
                  } else {
                    symbol = preErrorSymbol;
                    preErrorSymbol = null;
                  }
                  break;
                case 2:
                  len = this.productions_[action[1]][1];
                  yyval.$ = vstack[vstack.length - len];
                  yyval._$ = {
                    first_line: lstack[lstack.length - (len || 1)].first_line,
                    last_line: lstack[lstack.length - 1].last_line,
                    first_column: lstack[lstack.length - (len || 1)].first_column,
                    last_column: lstack[lstack.length - 1].last_column
                  };
                  if (ranges) {
                    yyval._$.range = [
                      lstack[lstack.length - (len || 1)].range[0],
                      lstack[lstack.length - 1].range[1]
                    ];
                  }
                  r2 = this.performAction.apply(yyval, [
                    yytext,
                    yyleng,
                    yylineno,
                    sharedState.yy,
                    action[1],
                    vstack,
                    lstack
                  ].concat(args));
                  if (typeof r2 !== "undefined") {
                    return r2;
                  }
                  if (len) {
                    stack = stack.slice(0, -1 * len * 2);
                    vstack = vstack.slice(0, -1 * len);
                    lstack = lstack.slice(0, -1 * len);
                  }
                  stack.push(this.productions_[action[1]][0]);
                  vstack.push(yyval.$);
                  lstack.push(yyval._$);
                  newState2 = table[stack[stack.length - 2]][stack[stack.length - 1]];
                  stack.push(newState2);
                  break;
                case 3:
                  return true;
              }
            }
            return true;
          }, "parse")
        };
        var lexer2 = /* @__PURE__ */ function() {
          var lexer3 = {
            EOF: 1,
            parseError: /* @__PURE__ */ __name(function parseError(str2, hash) {
              if (this.yy.parser) {
                this.yy.parser.parseError(str2, hash);
              } else {
                throw new Error(str2);
              }
            }, "parseError"),
            // resets the lexer, sets new input
            setInput: /* @__PURE__ */ __name(function(input, yy) {
              this.yy = yy || this.yy || {};
              this._input = input;
              this._more = this._backtrack = this.done = false;
              this.yylineno = this.yyleng = 0;
              this.yytext = this.matched = this.match = "";
              this.conditionStack = ["INITIAL"];
              this.yylloc = {
                first_line: 1,
                first_column: 0,
                last_line: 1,
                last_column: 0
              };
              if (this.options.ranges) {
                this.yylloc.range = [0, 0];
              }
              this.offset = 0;
              return this;
            }, "setInput"),
            // consumes and returns one char from the input
            input: /* @__PURE__ */ __name(function() {
              var ch = this._input[0];
              this.yytext += ch;
              this.yyleng++;
              this.offset++;
              this.match += ch;
              this.matched += ch;
              var lines = ch.match(/(?:\r\n?|\n).*/g);
              if (lines) {
                this.yylineno++;
                this.yylloc.last_line++;
              } else {
                this.yylloc.last_column++;
              }
              if (this.options.ranges) {
                this.yylloc.range[1]++;
              }
              this._input = this._input.slice(1);
              return ch;
            }, "input"),
            // unshifts one char (or a string) into the input
            unput: /* @__PURE__ */ __name(function(ch) {
              var len = ch.length;
              var lines = ch.split(/(?:\r\n?|\n)/g);
              this._input = ch + this._input;
              this.yytext = this.yytext.substr(0, this.yytext.length - len);
              this.offset -= len;
              var oldLines = this.match.split(/(?:\r\n?|\n)/g);
              this.match = this.match.substr(0, this.match.length - 1);
              this.matched = this.matched.substr(0, this.matched.length - 1);
              if (lines.length - 1) {
                this.yylineno -= lines.length - 1;
              }
              var r2 = this.yylloc.range;
              this.yylloc = {
                first_line: this.yylloc.first_line,
                last_line: this.yylineno + 1,
                first_column: this.yylloc.first_column,
                last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
              };
              if (this.options.ranges) {
                this.yylloc.range = [r2[0], r2[0] + this.yyleng - len];
              }
              this.yyleng = this.yytext.length;
              return this;
            }, "unput"),
            // When called from action, caches matched text and appends it on next action
            more: /* @__PURE__ */ __name(function() {
              this._more = true;
              return this;
            }, "more"),
            // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
            reject: /* @__PURE__ */ __name(function() {
              if (this.options.backtrack_lexer) {
                this._backtrack = true;
              } else {
                return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
                  text: "",
                  token: null,
                  line: this.yylineno
                });
              }
              return this;
            }, "reject"),
            // retain first n characters of the match
            less: /* @__PURE__ */ __name(function(n2) {
              this.unput(this.match.slice(n2));
            }, "less"),
            // displays already matched input, i.e. for error messages
            pastInput: /* @__PURE__ */ __name(function() {
              var past = this.matched.substr(0, this.matched.length - this.match.length);
              return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
            }, "pastInput"),
            // displays upcoming input, i.e. for error messages
            upcomingInput: /* @__PURE__ */ __name(function() {
              var next3 = this.match;
              if (next3.length < 20) {
                next3 += this._input.substr(0, 20 - next3.length);
              }
              return (next3.substr(0, 20) + (next3.length > 20 ? "..." : "")).replace(/\n/g, "");
            }, "upcomingInput"),
            // displays the character position where the lexing error occurred, i.e. for error messages
            showPosition: /* @__PURE__ */ __name(function() {
              var pre = this.pastInput();
              var c3 = new Array(pre.length + 1).join("-");
              return pre + this.upcomingInput() + "\n" + c3 + "^";
            }, "showPosition"),
            // test the lexed token: return FALSE when not a match, otherwise return token
            test_match: /* @__PURE__ */ __name(function(match2, indexed_rule) {
              var token2, lines, backup;
              if (this.options.backtrack_lexer) {
                backup = {
                  yylineno: this.yylineno,
                  yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                  },
                  yytext: this.yytext,
                  match: this.match,
                  matches: this.matches,
                  matched: this.matched,
                  yyleng: this.yyleng,
                  offset: this.offset,
                  _more: this._more,
                  _input: this._input,
                  yy: this.yy,
                  conditionStack: this.conditionStack.slice(0),
                  done: this.done
                };
                if (this.options.ranges) {
                  backup.yylloc.range = this.yylloc.range.slice(0);
                }
              }
              lines = match2[0].match(/(?:\r\n?|\n).*/g);
              if (lines) {
                this.yylineno += lines.length;
              }
              this.yylloc = {
                first_line: this.yylloc.last_line,
                last_line: this.yylineno + 1,
                first_column: this.yylloc.last_column,
                last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match2[0].length
              };
              this.yytext += match2[0];
              this.match += match2[0];
              this.matches = match2;
              this.yyleng = this.yytext.length;
              if (this.options.ranges) {
                this.yylloc.range = [this.offset, this.offset += this.yyleng];
              }
              this._more = false;
              this._backtrack = false;
              this._input = this._input.slice(match2[0].length);
              this.matched += match2[0];
              token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
              if (this.done && this._input) {
                this.done = false;
              }
              if (token2) {
                return token2;
              } else if (this._backtrack) {
                for (var k2 in backup) {
                  this[k2] = backup[k2];
                }
                return false;
              }
              return false;
            }, "test_match"),
            // return next match in input
            next: /* @__PURE__ */ __name(function() {
              if (this.done) {
                return this.EOF;
              }
              if (!this._input) {
                this.done = true;
              }
              var token2, match2, tempMatch, index;
              if (!this._more) {
                this.yytext = "";
                this.match = "";
              }
              var rules = this._currentRules();
              for (var i2 = 0; i2 < rules.length; i2++) {
                tempMatch = this._input.match(this.rules[rules[i2]]);
                if (tempMatch && (!match2 || tempMatch[0].length > match2[0].length)) {
                  match2 = tempMatch;
                  index = i2;
                  if (this.options.backtrack_lexer) {
                    token2 = this.test_match(tempMatch, rules[i2]);
                    if (token2 !== false) {
                      return token2;
                    } else if (this._backtrack) {
                      match2 = false;
                      continue;
                    } else {
                      return false;
                    }
                  } else if (!this.options.flex) {
                    break;
                  }
                }
              }
              if (match2) {
                token2 = this.test_match(match2, rules[index]);
                if (token2 !== false) {
                  return token2;
                }
                return false;
              }
              if (this._input === "") {
                return this.EOF;
              } else {
                return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
                  text: "",
                  token: null,
                  line: this.yylineno
                });
              }
            }, "next"),
            // return next match that has a token
            lex: /* @__PURE__ */ __name(function lex2() {
              var r2 = this.next();
              if (r2) {
                return r2;
              } else {
                return this.lex();
              }
            }, "lex"),
            // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
            begin: /* @__PURE__ */ __name(function begin(condition) {
              this.conditionStack.push(condition);
            }, "begin"),
            // pop the previously active lexer condition state off the condition stack
            popState: /* @__PURE__ */ __name(function popState() {
              var n2 = this.conditionStack.length - 1;
              if (n2 > 0) {
                return this.conditionStack.pop();
              } else {
                return this.conditionStack[0];
              }
            }, "popState"),
            // produce the lexer rule set which is active for the currently active lexer condition state
            _currentRules: /* @__PURE__ */ __name(function _currentRules() {
              if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
              } else {
                return this.conditions["INITIAL"].rules;
              }
            }, "_currentRules"),
            // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
            topState: /* @__PURE__ */ __name(function topState(n2) {
              n2 = this.conditionStack.length - 1 - Math.abs(n2 || 0);
              if (n2 >= 0) {
                return this.conditionStack[n2];
              } else {
                return "INITIAL";
              }
            }, "topState"),
            // alias for begin(condition)
            pushState: /* @__PURE__ */ __name(function pushState(condition) {
              this.begin(condition);
            }, "pushState"),
            // return the number of states currently on the stack
            stateStackSize: /* @__PURE__ */ __name(function stateStackSize() {
              return this.conditionStack.length;
            }, "stateStackSize"),
            options: {},
            performAction: /* @__PURE__ */ __name(function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
              var YYSTATE = YY_START;
              switch ($avoiding_name_collisions) {
                case 0:
                  return 6;
                  break;
                case 1:
                  return 7;
                  break;
                case 2:
                  return 8;
                  break;
                case 3:
                  return 9;
                  break;
                case 4:
                  return 22;
                  break;
                case 5:
                  return 23;
                  break;
                case 6:
                  this.begin("acc_title");
                  return 24;
                  break;
                case 7:
                  this.popState();
                  return "acc_title_value";
                  break;
                case 8:
                  this.begin("acc_descr");
                  return 26;
                  break;
                case 9:
                  this.popState();
                  return "acc_descr_value";
                  break;
                case 10:
                  this.begin("acc_descr_multiline");
                  break;
                case 11:
                  this.popState();
                  break;
                case 12:
                  return "acc_descr_multiline_value";
                  break;
                case 13:
                  break;
                case 14:
                  c;
                  break;
                case 15:
                  return 12;
                  break;
                case 16:
                  break;
                case 17:
                  return 11;
                  break;
                case 18:
                  return 15;
                  break;
                case 19:
                  return 16;
                  break;
                case 20:
                  return 17;
                  break;
                case 21:
                  return 18;
                  break;
                case 22:
                  this.begin("person_ext");
                  return 45;
                  break;
                case 23:
                  this.begin("person");
                  return 44;
                  break;
                case 24:
                  this.begin("system_ext_queue");
                  return 51;
                  break;
                case 25:
                  this.begin("system_ext_db");
                  return 50;
                  break;
                case 26:
                  this.begin("system_ext");
                  return 49;
                  break;
                case 27:
                  this.begin("system_queue");
                  return 48;
                  break;
                case 28:
                  this.begin("system_db");
                  return 47;
                  break;
                case 29:
                  this.begin("system");
                  return 46;
                  break;
                case 30:
                  this.begin("boundary");
                  return 37;
                  break;
                case 31:
                  this.begin("enterprise_boundary");
                  return 34;
                  break;
                case 32:
                  this.begin("system_boundary");
                  return 36;
                  break;
                case 33:
                  this.begin("container_ext_queue");
                  return 57;
                  break;
                case 34:
                  this.begin("container_ext_db");
                  return 56;
                  break;
                case 35:
                  this.begin("container_ext");
                  return 55;
                  break;
                case 36:
                  this.begin("container_queue");
                  return 54;
                  break;
                case 37:
                  this.begin("container_db");
                  return 53;
                  break;
                case 38:
                  this.begin("container");
                  return 52;
                  break;
                case 39:
                  this.begin("container_boundary");
                  return 38;
                  break;
                case 40:
                  this.begin("component_ext_queue");
                  return 63;
                  break;
                case 41:
                  this.begin("component_ext_db");
                  return 62;
                  break;
                case 42:
                  this.begin("component_ext");
                  return 61;
                  break;
                case 43:
                  this.begin("component_queue");
                  return 60;
                  break;
                case 44:
                  this.begin("component_db");
                  return 59;
                  break;
                case 45:
                  this.begin("component");
                  return 58;
                  break;
                case 46:
                  this.begin("node");
                  return 39;
                  break;
                case 47:
                  this.begin("node");
                  return 39;
                  break;
                case 48:
                  this.begin("node_l");
                  return 40;
                  break;
                case 49:
                  this.begin("node_r");
                  return 41;
                  break;
                case 50:
                  this.begin("rel");
                  return 64;
                  break;
                case 51:
                  this.begin("birel");
                  return 65;
                  break;
                case 52:
                  this.begin("rel_u");
                  return 66;
                  break;
                case 53:
                  this.begin("rel_u");
                  return 66;
                  break;
                case 54:
                  this.begin("rel_d");
                  return 67;
                  break;
                case 55:
                  this.begin("rel_d");
                  return 67;
                  break;
                case 56:
                  this.begin("rel_l");
                  return 68;
                  break;
                case 57:
                  this.begin("rel_l");
                  return 68;
                  break;
                case 58:
                  this.begin("rel_r");
                  return 69;
                  break;
                case 59:
                  this.begin("rel_r");
                  return 69;
                  break;
                case 60:
                  this.begin("rel_b");
                  return 70;
                  break;
                case 61:
                  this.begin("rel_index");
                  return 71;
                  break;
                case 62:
                  this.begin("update_el_style");
                  return 72;
                  break;
                case 63:
                  this.begin("update_rel_style");
                  return 73;
                  break;
                case 64:
                  this.begin("update_layout_config");
                  return 74;
                  break;
                case 65:
                  return "EOF_IN_STRUCT";
                  break;
                case 66:
                  this.begin("attribute");
                  return "ATTRIBUTE_EMPTY";
                  break;
                case 67:
                  this.begin("attribute");
                  break;
                case 68:
                  this.popState();
                  this.popState();
                  break;
                case 69:
                  return 80;
                  break;
                case 70:
                  break;
                case 71:
                  return 80;
                  break;
                case 72:
                  this.begin("string");
                  break;
                case 73:
                  this.popState();
                  break;
                case 74:
                  return "STR";
                  break;
                case 75:
                  this.begin("string_kv");
                  break;
                case 76:
                  this.begin("string_kv_key");
                  return "STR_KEY";
                  break;
                case 77:
                  this.popState();
                  this.begin("string_kv_value");
                  break;
                case 78:
                  return "STR_VALUE";
                  break;
                case 79:
                  this.popState();
                  this.popState();
                  break;
                case 80:
                  return "STR";
                  break;
                case 81:
                  return "LBRACE";
                  break;
                case 82:
                  return "RBRACE";
                  break;
                case 83:
                  return "SPACE";
                  break;
                case 84:
                  return "EOL";
                  break;
                case 85:
                  return 14;
                  break;
              }
            }, "anonymous"),
            rules: [/^(?:.*direction\s+TB[^\n]*)/, /^(?:.*direction\s+BT[^\n]*)/, /^(?:.*direction\s+RL[^\n]*)/, /^(?:.*direction\s+LR[^\n]*)/, /^(?:title\s[^#\n;]+)/, /^(?:accDescription\s[^#\n;]+)/, /^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:%%(?!\{)*[^\n]*(\r?\n?)+)/, /^(?:%%[^\n]*(\r?\n)*)/, /^(?:\s*(\r?\n)+)/, /^(?:\s+)/, /^(?:C4Context\b)/, /^(?:C4Container\b)/, /^(?:C4Component\b)/, /^(?:C4Dynamic\b)/, /^(?:C4Deployment\b)/, /^(?:Person_Ext\b)/, /^(?:Person\b)/, /^(?:SystemQueue_Ext\b)/, /^(?:SystemDb_Ext\b)/, /^(?:System_Ext\b)/, /^(?:SystemQueue\b)/, /^(?:SystemDb\b)/, /^(?:System\b)/, /^(?:Boundary\b)/, /^(?:Enterprise_Boundary\b)/, /^(?:System_Boundary\b)/, /^(?:ContainerQueue_Ext\b)/, /^(?:ContainerDb_Ext\b)/, /^(?:Container_Ext\b)/, /^(?:ContainerQueue\b)/, /^(?:ContainerDb\b)/, /^(?:Container\b)/, /^(?:Container_Boundary\b)/, /^(?:ComponentQueue_Ext\b)/, /^(?:ComponentDb_Ext\b)/, /^(?:Component_Ext\b)/, /^(?:ComponentQueue\b)/, /^(?:ComponentDb\b)/, /^(?:Component\b)/, /^(?:Deployment_Node\b)/, /^(?:Node\b)/, /^(?:Node_L\b)/, /^(?:Node_R\b)/, /^(?:Rel\b)/, /^(?:BiRel\b)/, /^(?:Rel_Up\b)/, /^(?:Rel_U\b)/, /^(?:Rel_Down\b)/, /^(?:Rel_D\b)/, /^(?:Rel_Left\b)/, /^(?:Rel_L\b)/, /^(?:Rel_Right\b)/, /^(?:Rel_R\b)/, /^(?:Rel_Back\b)/, /^(?:RelIndex\b)/, /^(?:UpdateElementStyle\b)/, /^(?:UpdateRelStyle\b)/, /^(?:UpdateLayoutConfig\b)/, /^(?:$)/, /^(?:[(][ ]*[,])/, /^(?:[(])/, /^(?:[)])/, /^(?:,,)/, /^(?:,)/, /^(?:[ ]*["]["])/, /^(?:[ ]*["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:[ ]*[\$])/, /^(?:[^=]*)/, /^(?:[=][ ]*["])/, /^(?:[^"]+)/, /^(?:["])/, /^(?:[^,]+)/, /^(?:\{)/, /^(?:\})/, /^(?:[\s]+)/, /^(?:[\n\r]+)/, /^(?:$)/],
            conditions: { "acc_descr_multiline": { "rules": [11, 12], "inclusive": false }, "acc_descr": { "rules": [9], "inclusive": false }, "acc_title": { "rules": [7], "inclusive": false }, "string_kv_value": { "rules": [78, 79], "inclusive": false }, "string_kv_key": { "rules": [77], "inclusive": false }, "string_kv": { "rules": [76], "inclusive": false }, "string": { "rules": [73, 74], "inclusive": false }, "attribute": { "rules": [68, 69, 70, 71, 72, 75, 80], "inclusive": false }, "update_layout_config": { "rules": [65, 66, 67, 68], "inclusive": false }, "update_rel_style": { "rules": [65, 66, 67, 68], "inclusive": false }, "update_el_style": { "rules": [65, 66, 67, 68], "inclusive": false }, "rel_b": { "rules": [65, 66, 67, 68], "inclusive": false }, "rel_r": { "rules": [65, 66, 67, 68], "inclusive": false }, "rel_l": { "rules": [65, 66, 67, 68], "inclusive": false }, "rel_d": { "rules": [65, 66, 67, 68], "inclusive": false }, "rel_u": { "rules": [65, 66, 67, 68], "inclusive": false }, "rel_bi": { "rules": [], "inclusive": false }, "rel": { "rules": [65, 66, 67, 68], "inclusive": false }, "node_r": { "rules": [65, 66, 67, 68], "inclusive": false }, "node_l": { "rules": [65, 66, 67, 68], "inclusive": false }, "node": { "rules": [65, 66, 67, 68], "inclusive": false }, "index": { "rules": [], "inclusive": false }, "rel_index": { "rules": [65, 66, 67, 68], "inclusive": false }, "component_ext_queue": { "rules": [], "inclusive": false }, "component_ext_db": { "rules": [65, 66, 67, 68], "inclusive": false }, "component_ext": { "rules": [65, 66, 67, 68], "inclusive": false }, "component_queue": { "rules": [65, 66, 67, 68], "inclusive": false }, "component_db": { "rules": [65, 66, 67, 68], "inclusive": false }, "component": { "rules": [65, 66, 67, 68], "inclusive": false }, "container_boundary": { "rules": [65, 66, 67, 68], "inclusive": false }, "container_ext_queue": { "rules": [65, 66, 67, 68], "inclusive": false }, "container_ext_db": { "rules": [65, 66, 67, 68], "inclusive": false }, "container_ext": { "rules": [65, 66, 67, 68], "inclusive": false }, "container_queue": { "rules": [65, 66, 67, 68], "inclusive": false }, "container_db": { "rules": [65, 66, 67, 68], "inclusive": false }, "container": { "rules": [65, 66, 67, 68], "inclusive": false }, "birel": { "rules": [65, 66, 67, 68], "inclusive": false }, "system_boundary": { "rules": [65, 66, 67, 68], "inclusive": false }, "enterprise_boundary": { "rules": [65, 66, 67, 68], "inclusive": false }, "boundary": { "rules": [65, 66, 67, 68], "inclusive": false }, "system_ext_queue": { "rules": [65, 66, 67, 68], "inclusive": false }, "system_ext_db": { "rules": [65, 66, 67, 68], "inclusive": false }, "system_ext": { "rules": [65, 66, 67, 68], "inclusive": false }, "system_queue": { "rules": [65, 66, 67, 68], "inclusive": false }, "system_db": { "rules": [65, 66, 67, 68], "inclusive": false }, "system": { "rules": [65, 66, 67, 68], "inclusive": false }, "person_ext": { "rules": [65, 66, 67, 68], "inclusive": false }, "person": { "rules": [65, 66, 67, 68], "inclusive": false }, "INITIAL": { "rules": [0, 1, 2, 3, 4, 5, 6, 8, 10, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 81, 82, 83, 84, 85], "inclusive": true } }
          };
          return lexer3;
        }();
        parser23.lexer = lexer2;
        function Parser3() {
          this.yy = {};
        }
        __name(Parser3, "Parser");
        Parser3.prototype = parser23;
        parser23.Parser = Parser3;
        return new Parser3();
      }();
      parser.parser = parser;
      c4Diagram_default = parser;
    }
  });

  // src/assignWithDepth.ts
  var assignWithDepth, assignWithDepth_default;
  var init_assignWithDepth = __esm({
    "src/assignWithDepth.ts"() {
      "use strict";
      assignWithDepth = /* @__PURE__ */ __name((dst, src, { depth = 2, clobber = false } = {}) => {
        const config6 = { depth, clobber };
        if (Array.isArray(src) && !Array.isArray(dst)) {
          src.forEach((s2) => assignWithDepth(dst, s2, config6));
          return dst;
        } else if (Array.isArray(src) && Array.isArray(dst)) {
          src.forEach((s2) => {
            if (!dst.includes(s2)) {
              dst.push(s2);
            }
          });
          return dst;
        }
        if (dst === void 0 || depth <= 0) {
          if (dst !== void 0 && dst !== null && typeof dst === "object" && typeof src === "object") {
            return Object.assign(dst, src);
          } else {
            return src;
          }
        }
        if (src !== void 0 && typeof dst === "object" && typeof src === "object") {
          Object.keys(src).forEach((key) => {
            if (typeof src[key] === "object" && (dst[key] === void 0 || typeof dst[key] === "object")) {
              if (dst[key] === void 0) {
                dst[key] = Array.isArray(src[key]) ? [] : {};
              }
              dst[key] = assignWithDepth(dst[key], src[key], { depth: depth - 1, clobber });
            } else if (clobber || typeof dst[key] !== "object" && typeof src[key] !== "object") {
              dst[key] = src[key];
            }
          });
        }
        return dst;
      }, "assignWithDepth");
      assignWithDepth_default = assignWithDepth;
    }
  });

  // ../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/utils/channel.js
  var Channel, channel_default;
  var init_channel = __esm({
    "../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/utils/channel.js"() {
      "use strict";
      Channel = {
        /* CLAMP */
        min: {
          r: 0,
          g: 0,
          b: 0,
          s: 0,
          l: 0,
          a: 0
        },
        max: {
          r: 255,
          g: 255,
          b: 255,
          h: 360,
          s: 100,
          l: 100,
          a: 1
        },
        clamp: {
          r: /* @__PURE__ */ __name((r2) => r2 >= 255 ? 255 : r2 < 0 ? 0 : r2, "r"),
          g: /* @__PURE__ */ __name((g2) => g2 >= 255 ? 255 : g2 < 0 ? 0 : g2, "g"),
          b: /* @__PURE__ */ __name((b2) => b2 >= 255 ? 255 : b2 < 0 ? 0 : b2, "b"),
          h: /* @__PURE__ */ __name((h2) => h2 % 360, "h"),
          s: /* @__PURE__ */ __name((s2) => s2 >= 100 ? 100 : s2 < 0 ? 0 : s2, "s"),
          l: /* @__PURE__ */ __name((l2) => l2 >= 100 ? 100 : l2 < 0 ? 0 : l2, "l"),
          a: /* @__PURE__ */ __name((a2) => a2 >= 1 ? 1 : a2 < 0 ? 0 : a2, "a")
        },
        /* CONVERSION */
        //SOURCE: https://planetcalc.com/7779
        toLinear: /* @__PURE__ */ __name((c3) => {
          const n2 = c3 / 255;
          return c3 > 0.03928 ? Math.pow((n2 + 0.055) / 1.055, 2.4) : n2 / 12.92;
        }, "toLinear"),
        //SOURCE: https://gist.github.com/mjackson/5311256
        hue2rgb: /* @__PURE__ */ __name((p3, q2, t4) => {
          if (t4 < 0)
            t4 += 1;
          if (t4 > 1)
            t4 -= 1;
          if (t4 < 1 / 6)
            return p3 + (q2 - p3) * 6 * t4;
          if (t4 < 1 / 2)
            return q2;
          if (t4 < 2 / 3)
            return p3 + (q2 - p3) * (2 / 3 - t4) * 6;
          return p3;
        }, "hue2rgb"),
        hsl2rgb: /* @__PURE__ */ __name(({ h: h2, s: s2, l: l2 }, channel2) => {
          if (!s2)
            return l2 * 2.55;
          h2 /= 360;
          s2 /= 100;
          l2 /= 100;
          const q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
          const p3 = 2 * l2 - q2;
          switch (channel2) {
            case "r":
              return Channel.hue2rgb(p3, q2, h2 + 1 / 3) * 255;
            case "g":
              return Channel.hue2rgb(p3, q2, h2) * 255;
            case "b":
              return Channel.hue2rgb(p3, q2, h2 - 1 / 3) * 255;
          }
        }, "hsl2rgb"),
        rgb2hsl: /* @__PURE__ */ __name(({ r: r2, g: g2, b: b2 }, channel2) => {
          r2 /= 255;
          g2 /= 255;
          b2 /= 255;
          const max10 = Math.max(r2, g2, b2);
          const min9 = Math.min(r2, g2, b2);
          const l2 = (max10 + min9) / 2;
          if (channel2 === "l")
            return l2 * 100;
          if (max10 === min9)
            return 0;
          const d2 = max10 - min9;
          const s2 = l2 > 0.5 ? d2 / (2 - max10 - min9) : d2 / (max10 + min9);
          if (channel2 === "s")
            return s2 * 100;
          switch (max10) {
            case r2:
              return ((g2 - b2) / d2 + (g2 < b2 ? 6 : 0)) * 60;
            case g2:
              return ((b2 - r2) / d2 + 2) * 60;
            case b2:
              return ((r2 - g2) / d2 + 4) * 60;
            default:
              return -1;
          }
        }, "rgb2hsl")
      };
      channel_default = Channel;
    }
  });

  // ../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/utils/lang.js
  var Lang, lang_default;
  var init_lang = __esm({
    "../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/utils/lang.js"() {
      "use strict";
      Lang = {
        /* API */
        clamp: /* @__PURE__ */ __name((number7, lower2, upper) => {
          if (lower2 > upper)
            return Math.min(lower2, Math.max(upper, number7));
          return Math.min(upper, Math.max(lower2, number7));
        }, "clamp"),
        round: /* @__PURE__ */ __name((number7) => {
          return Math.round(number7 * 1e10) / 1e10;
        }, "round")
      };
      lang_default = Lang;
    }
  });

  // ../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/utils/unit.js
  var Unit, unit_default;
  var init_unit = __esm({
    "../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/utils/unit.js"() {
      "use strict";
      Unit = {
        /* API */
        dec2hex: /* @__PURE__ */ __name((dec) => {
          const hex2 = Math.round(dec).toString(16);
          return hex2.length > 1 ? hex2 : `0${hex2}`;
        }, "dec2hex")
      };
      unit_default = Unit;
    }
  });

  // ../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/utils/index.js
  var Utils, utils_default;
  var init_utils = __esm({
    "../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/utils/index.js"() {
      "use strict";
      init_channel();
      init_lang();
      init_unit();
      Utils = {
        channel: channel_default,
        lang: lang_default,
        unit: unit_default
      };
      utils_default = Utils;
    }
  });

  // ../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/constants.js
  var DEC2HEX, TYPE;
  var init_constants = __esm({
    "../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/constants.js"() {
      "use strict";
      init_utils();
      DEC2HEX = {};
      for (let i2 = 0; i2 <= 255; i2++)
        DEC2HEX[i2] = utils_default.unit.dec2hex(i2);
      TYPE = {
        ALL: 0,
        RGB: 1,
        HSL: 2
      };
    }
  });

  // ../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/channels/type.js
  var Type, type_default;
  var init_type = __esm({
    "../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/channels/type.js"() {
      "use strict";
      init_constants();
      Type = class {
        static {
          __name(this, "Type");
        }
        constructor() {
          this.type = TYPE.ALL;
        }
        /* API */
        get() {
          return this.type;
        }
        set(type3) {
          if (this.type && this.type !== type3)
            throw new Error("Cannot change both RGB and HSL channels at the same time");
          this.type = type3;
        }
        reset() {
          this.type = TYPE.ALL;
        }
        is(type3) {
          return this.type === type3;
        }
      };
      type_default = Type;
    }
  });

  // ../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/channels/index.js
  var Channels, channels_default;
  var init_channels = __esm({
    "../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/channels/index.js"() {
      "use strict";
      init_utils();
      init_type();
      init_constants();
      Channels = class {
        static {
          __name(this, "Channels");
        }
        /* CONSTRUCTOR */
        constructor(data5, color2) {
          this.color = color2;
          this.changed = false;
          this.data = data5;
          this.type = new type_default();
        }
        /* API */
        set(data5, color2) {
          this.color = color2;
          this.changed = false;
          this.data = data5;
          this.type.type = TYPE.ALL;
          return this;
        }
        /* HELPERS */
        _ensureHSL() {
          const data5 = this.data;
          const { h: h2, s: s2, l: l2 } = data5;
          if (h2 === void 0)
            data5.h = utils_default.channel.rgb2hsl(data5, "h");
          if (s2 === void 0)
            data5.s = utils_default.channel.rgb2hsl(data5, "s");
          if (l2 === void 0)
            data5.l = utils_default.channel.rgb2hsl(data5, "l");
        }
        _ensureRGB() {
          const data5 = this.data;
          const { r: r2, g: g2, b: b2 } = data5;
          if (r2 === void 0)
            data5.r = utils_default.channel.hsl2rgb(data5, "r");
          if (g2 === void 0)
            data5.g = utils_default.channel.hsl2rgb(data5, "g");
          if (b2 === void 0)
            data5.b = utils_default.channel.hsl2rgb(data5, "b");
        }
        /* GETTERS */
        get r() {
          const data5 = this.data;
          const r2 = data5.r;
          if (!this.type.is(TYPE.HSL) && r2 !== void 0)
            return r2;
          this._ensureHSL();
          return utils_default.channel.hsl2rgb(data5, "r");
        }
        get g() {
          const data5 = this.data;
          const g2 = data5.g;
          if (!this.type.is(TYPE.HSL) && g2 !== void 0)
            return g2;
          this._ensureHSL();
          return utils_default.channel.hsl2rgb(data5, "g");
        }
        get b() {
          const data5 = this.data;
          const b2 = data5.b;
          if (!this.type.is(TYPE.HSL) && b2 !== void 0)
            return b2;
          this._ensureHSL();
          return utils_default.channel.hsl2rgb(data5, "b");
        }
        get h() {
          const data5 = this.data;
          const h2 = data5.h;
          if (!this.type.is(TYPE.RGB) && h2 !== void 0)
            return h2;
          this._ensureRGB();
          return utils_default.channel.rgb2hsl(data5, "h");
        }
        get s() {
          const data5 = this.data;
          const s2 = data5.s;
          if (!this.type.is(TYPE.RGB) && s2 !== void 0)
            return s2;
          this._ensureRGB();
          return utils_default.channel.rgb2hsl(data5, "s");
        }
        get l() {
          const data5 = this.data;
          const l2 = data5.l;
          if (!this.type.is(TYPE.RGB) && l2 !== void 0)
            return l2;
          this._ensureRGB();
          return utils_default.channel.rgb2hsl(data5, "l");
        }
        get a() {
          return this.data.a;
        }
        /* SETTERS */
        set r(r2) {
          this.type.set(TYPE.RGB);
          this.changed = true;
          this.data.r = r2;
        }
        set g(g2) {
          this.type.set(TYPE.RGB);
          this.changed = true;
          this.data.g = g2;
        }
        set b(b2) {
          this.type.set(TYPE.RGB);
          this.changed = true;
          this.data.b = b2;
        }
        set h(h2) {
          this.type.set(TYPE.HSL);
          this.changed = true;
          this.data.h = h2;
        }
        set s(s2) {
          this.type.set(TYPE.HSL);
          this.changed = true;
          this.data.s = s2;
        }
        set l(l2) {
          this.type.set(TYPE.HSL);
          this.changed = true;
          this.data.l = l2;
        }
        set a(a2) {
          this.changed = true;
          this.data.a = a2;
        }
      };
      channels_default = Channels;
    }
  });

  // ../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/channels/reusable.js
  var channels, reusable_default;
  var init_reusable = __esm({
    "../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/channels/reusable.js"() {
      "use strict";
      init_channels();
      channels = new channels_default({ r: 0, g: 0, b: 0, a: 0 }, "transparent");
      reusable_default = channels;
    }
  });

  // ../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/color/hex.js
  var Hex, hex_default;
  var init_hex = __esm({
    "../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/color/hex.js"() {
      "use strict";
      init_reusable();
      init_constants();
      Hex = {
        /* VARIABLES */
        re: /^#((?:[a-f0-9]{2}){2,4}|[a-f0-9]{3})$/i,
        /* API */
        parse: /* @__PURE__ */ __name((color2) => {
          if (color2.charCodeAt(0) !== 35)
            return;
          const match2 = color2.match(Hex.re);
          if (!match2)
            return;
          const hex2 = match2[1];
          const dec = parseInt(hex2, 16);
          const length2 = hex2.length;
          const hasAlpha = length2 % 4 === 0;
          const isFullLength = length2 > 4;
          const multiplier = isFullLength ? 1 : 17;
          const bits = isFullLength ? 8 : 4;
          const bitsOffset = hasAlpha ? 0 : -1;
          const mask = isFullLength ? 255 : 15;
          return reusable_default.set({
            r: (dec >> bits * (bitsOffset + 3) & mask) * multiplier,
            g: (dec >> bits * (bitsOffset + 2) & mask) * multiplier,
            b: (dec >> bits * (bitsOffset + 1) & mask) * multiplier,
            a: hasAlpha ? (dec & mask) * multiplier / 255 : 1
          }, color2);
        }, "parse"),
        stringify: /* @__PURE__ */ __name((channels2) => {
          const { r: r2, g: g2, b: b2, a: a2 } = channels2;
          if (a2 < 1) {
            return `#${DEC2HEX[Math.round(r2)]}${DEC2HEX[Math.round(g2)]}${DEC2HEX[Math.round(b2)]}${DEC2HEX[Math.round(a2 * 255)]}`;
          } else {
            return `#${DEC2HEX[Math.round(r2)]}${DEC2HEX[Math.round(g2)]}${DEC2HEX[Math.round(b2)]}`;
          }
        }, "stringify")
      };
      hex_default = Hex;
    }
  });

  // ../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/color/hsl.js
  var HSL, hsl_default;
  var init_hsl = __esm({
    "../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/color/hsl.js"() {
      "use strict";
      init_utils();
      init_reusable();
      HSL = {
        /* VARIABLES */
        re: /^hsla?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(?:deg|grad|rad|turn)?)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(%)?))?\s*?\)$/i,
        hueRe: /^(.+?)(deg|grad|rad|turn)$/i,
        /* HELPERS */
        _hue2deg: /* @__PURE__ */ __name((hue2) => {
          const match2 = hue2.match(HSL.hueRe);
          if (match2) {
            const [, number7, unit2] = match2;
            switch (unit2) {
              case "grad":
                return utils_default.channel.clamp.h(parseFloat(number7) * 0.9);
              case "rad":
                return utils_default.channel.clamp.h(parseFloat(number7) * 180 / Math.PI);
              case "turn":
                return utils_default.channel.clamp.h(parseFloat(number7) * 360);
            }
          }
          return utils_default.channel.clamp.h(parseFloat(hue2));
        }, "_hue2deg"),
        /* API */
        parse: /* @__PURE__ */ __name((color2) => {
          const charCode = color2.charCodeAt(0);
          if (charCode !== 104 && charCode !== 72)
            return;
          const match2 = color2.match(HSL.re);
          if (!match2)
            return;
          const [, h2, s2, l2, a2, isAlphaPercentage] = match2;
          return reusable_default.set({
            h: HSL._hue2deg(h2),
            s: utils_default.channel.clamp.s(parseFloat(s2)),
            l: utils_default.channel.clamp.l(parseFloat(l2)),
            a: a2 ? utils_default.channel.clamp.a(isAlphaPercentage ? parseFloat(a2) / 100 : parseFloat(a2)) : 1
          }, color2);
        }, "parse"),
        stringify: /* @__PURE__ */ __name((channels2) => {
          const { h: h2, s: s2, l: l2, a: a2 } = channels2;
          if (a2 < 1) {
            return `hsla(${utils_default.lang.round(h2)}, ${utils_default.lang.round(s2)}%, ${utils_default.lang.round(l2)}%, ${a2})`;
          } else {
            return `hsl(${utils_default.lang.round(h2)}, ${utils_default.lang.round(s2)}%, ${utils_default.lang.round(l2)}%)`;
          }
        }, "stringify")
      };
      hsl_default = HSL;
    }
  });

  // ../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/color/keyword.js
  var Keyword, keyword_default;
  var init_keyword = __esm({
    "../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/color/keyword.js"() {
      "use strict";
      init_hex();
      Keyword = {
        /* VARIABLES */
        colors: {
          aliceblue: "#f0f8ff",
          antiquewhite: "#faebd7",
          aqua: "#00ffff",
          aquamarine: "#7fffd4",
          azure: "#f0ffff",
          beige: "#f5f5dc",
          bisque: "#ffe4c4",
          black: "#000000",
          blanchedalmond: "#ffebcd",
          blue: "#0000ff",
          blueviolet: "#8a2be2",
          brown: "#a52a2a",
          burlywood: "#deb887",
          cadetblue: "#5f9ea0",
          chartreuse: "#7fff00",
          chocolate: "#d2691e",
          coral: "#ff7f50",
          cornflowerblue: "#6495ed",
          cornsilk: "#fff8dc",
          crimson: "#dc143c",
          cyanaqua: "#00ffff",
          darkblue: "#00008b",
          darkcyan: "#008b8b",
          darkgoldenrod: "#b8860b",
          darkgray: "#a9a9a9",
          darkgreen: "#006400",
          darkgrey: "#a9a9a9",
          darkkhaki: "#bdb76b",
          darkmagenta: "#8b008b",
          darkolivegreen: "#556b2f",
          darkorange: "#ff8c00",
          darkorchid: "#9932cc",
          darkred: "#8b0000",
          darksalmon: "#e9967a",
          darkseagreen: "#8fbc8f",
          darkslateblue: "#483d8b",
          darkslategray: "#2f4f4f",
          darkslategrey: "#2f4f4f",
          darkturquoise: "#00ced1",
          darkviolet: "#9400d3",
          deeppink: "#ff1493",
          deepskyblue: "#00bfff",
          dimgray: "#696969",
          dimgrey: "#696969",
          dodgerblue: "#1e90ff",
          firebrick: "#b22222",
          floralwhite: "#fffaf0",
          forestgreen: "#228b22",
          fuchsia: "#ff00ff",
          gainsboro: "#dcdcdc",
          ghostwhite: "#f8f8ff",
          gold: "#ffd700",
          goldenrod: "#daa520",
          gray: "#808080",
          green: "#008000",
          greenyellow: "#adff2f",
          grey: "#808080",
          honeydew: "#f0fff0",
          hotpink: "#ff69b4",
          indianred: "#cd5c5c",
          indigo: "#4b0082",
          ivory: "#fffff0",
          khaki: "#f0e68c",
          lavender: "#e6e6fa",
          lavenderblush: "#fff0f5",
          lawngreen: "#7cfc00",
          lemonchiffon: "#fffacd",
          lightblue: "#add8e6",
          lightcoral: "#f08080",
          lightcyan: "#e0ffff",
          lightgoldenrodyellow: "#fafad2",
          lightgray: "#d3d3d3",
          lightgreen: "#90ee90",
          lightgrey: "#d3d3d3",
          lightpink: "#ffb6c1",
          lightsalmon: "#ffa07a",
          lightseagreen: "#20b2aa",
          lightskyblue: "#87cefa",
          lightslategray: "#778899",
          lightslategrey: "#778899",
          lightsteelblue: "#b0c4de",
          lightyellow: "#ffffe0",
          lime: "#00ff00",
          limegreen: "#32cd32",
          linen: "#faf0e6",
          magenta: "#ff00ff",
          maroon: "#800000",
          mediumaquamarine: "#66cdaa",
          mediumblue: "#0000cd",
          mediumorchid: "#ba55d3",
          mediumpurple: "#9370db",
          mediumseagreen: "#3cb371",
          mediumslateblue: "#7b68ee",
          mediumspringgreen: "#00fa9a",
          mediumturquoise: "#48d1cc",
          mediumvioletred: "#c71585",
          midnightblue: "#191970",
          mintcream: "#f5fffa",
          mistyrose: "#ffe4e1",
          moccasin: "#ffe4b5",
          navajowhite: "#ffdead",
          navy: "#000080",
          oldlace: "#fdf5e6",
          olive: "#808000",
          olivedrab: "#6b8e23",
          orange: "#ffa500",
          orangered: "#ff4500",
          orchid: "#da70d6",
          palegoldenrod: "#eee8aa",
          palegreen: "#98fb98",
          paleturquoise: "#afeeee",
          palevioletred: "#db7093",
          papayawhip: "#ffefd5",
          peachpuff: "#ffdab9",
          peru: "#cd853f",
          pink: "#ffc0cb",
          plum: "#dda0dd",
          powderblue: "#b0e0e6",
          purple: "#800080",
          rebeccapurple: "#663399",
          red: "#ff0000",
          rosybrown: "#bc8f8f",
          royalblue: "#4169e1",
          saddlebrown: "#8b4513",
          salmon: "#fa8072",
          sandybrown: "#f4a460",
          seagreen: "#2e8b57",
          seashell: "#fff5ee",
          sienna: "#a0522d",
          silver: "#c0c0c0",
          skyblue: "#87ceeb",
          slateblue: "#6a5acd",
          slategray: "#708090",
          slategrey: "#708090",
          snow: "#fffafa",
          springgreen: "#00ff7f",
          tan: "#d2b48c",
          teal: "#008080",
          thistle: "#d8bfd8",
          transparent: "#00000000",
          turquoise: "#40e0d0",
          violet: "#ee82ee",
          wheat: "#f5deb3",
          white: "#ffffff",
          whitesmoke: "#f5f5f5",
          yellow: "#ffff00",
          yellowgreen: "#9acd32"
        },
        /* API */
        parse: /* @__PURE__ */ __name((color2) => {
          color2 = color2.toLowerCase();
          const hex2 = Keyword.colors[color2];
          if (!hex2)
            return;
          return hex_default.parse(hex2);
        }, "parse"),
        stringify: /* @__PURE__ */ __name((channels2) => {
          const hex2 = hex_default.stringify(channels2);
          for (const name in Keyword.colors) {
            if (Keyword.colors[name] === hex2)
              return name;
          }
          return;
        }, "stringify")
      };
      keyword_default = Keyword;
    }
  });

  // ../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/color/rgb.js
  var RGB, rgb_default;
  var init_rgb = __esm({
    "../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/color/rgb.js"() {
      "use strict";
      init_utils();
      init_reusable();
      RGB = {
        /* VARIABLES */
        re: /^rgba?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?)))?\s*?\)$/i,
        /* API */
        parse: /* @__PURE__ */ __name((color2) => {
          const charCode = color2.charCodeAt(0);
          if (charCode !== 114 && charCode !== 82)
            return;
          const match2 = color2.match(RGB.re);
          if (!match2)
            return;
          const [, r2, isRedPercentage, g2, isGreenPercentage, b2, isBluePercentage, a2, isAlphaPercentage] = match2;
          return reusable_default.set({
            r: utils_default.channel.clamp.r(isRedPercentage ? parseFloat(r2) * 2.55 : parseFloat(r2)),
            g: utils_default.channel.clamp.g(isGreenPercentage ? parseFloat(g2) * 2.55 : parseFloat(g2)),
            b: utils_default.channel.clamp.b(isBluePercentage ? parseFloat(b2) * 2.55 : parseFloat(b2)),
            a: a2 ? utils_default.channel.clamp.a(isAlphaPercentage ? parseFloat(a2) / 100 : parseFloat(a2)) : 1
          }, color2);
        }, "parse"),
        stringify: /* @__PURE__ */ __name((channels2) => {
          const { r: r2, g: g2, b: b2, a: a2 } = channels2;
          if (a2 < 1) {
            return `rgba(${utils_default.lang.round(r2)}, ${utils_default.lang.round(g2)}, ${utils_default.lang.round(b2)}, ${utils_default.lang.round(a2)})`;
          } else {
            return `rgb(${utils_default.lang.round(r2)}, ${utils_default.lang.round(g2)}, ${utils_default.lang.round(b2)})`;
          }
        }, "stringify")
      };
      rgb_default = RGB;
    }
  });

  // ../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/color/index.js
  var Color, color_default;
  var init_color = __esm({
    "../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/color/index.js"() {
      "use strict";
      init_hex();
      init_hsl();
      init_keyword();
      init_rgb();
      init_constants();
      Color = {
        /* VARIABLES */
        format: {
          keyword: keyword_default,
          hex: hex_default,
          rgb: rgb_default,
          rgba: rgb_default,
          hsl: hsl_default,
          hsla: hsl_default
        },
        /* API */
        parse: /* @__PURE__ */ __name((color2) => {
          if (typeof color2 !== "string")
            return color2;
          const channels2 = hex_default.parse(color2) || rgb_default.parse(color2) || hsl_default.parse(color2) || keyword_default.parse(color2);
          if (channels2)
            return channels2;
          throw new Error(`Unsupported color format: "${color2}"`);
        }, "parse"),
        stringify: /* @__PURE__ */ __name((channels2) => {
          if (!channels2.changed && channels2.color)
            return channels2.color;
          if (channels2.type.is(TYPE.HSL) || channels2.data.r === void 0) {
            return hsl_default.stringify(channels2);
          } else if (channels2.a < 1 || !Number.isInteger(channels2.r) || !Number.isInteger(channels2.g) || !Number.isInteger(channels2.b)) {
            return rgb_default.stringify(channels2);
          } else {
            return hex_default.stringify(channels2);
          }
        }, "stringify")
      };
      color_default = Color;
    }
  });

  // ../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/methods/change.js
  var change, change_default;
  var init_change = __esm({
    "../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/methods/change.js"() {
      "use strict";
      init_utils();
      init_color();
      change = /* @__PURE__ */ __name((color2, channels2) => {
        const ch = color_default.parse(color2);
        for (const c3 in channels2) {
          ch[c3] = utils_default.channel.clamp[c3](channels2[c3]);
        }
        return color_default.stringify(ch);
      }, "change");
      change_default = change;
    }
  });

  // ../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/methods/rgba.js
  var rgba, rgba_default;
  var init_rgba = __esm({
    "../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/methods/rgba.js"() {
      "use strict";
      init_utils();
      init_reusable();
      init_color();
      init_change();
      rgba = /* @__PURE__ */ __name((r2, g2, b2 = 0, a2 = 1) => {
        if (typeof r2 !== "number")
          return change_default(r2, { a: g2 });
        const channels2 = reusable_default.set({
          r: utils_default.channel.clamp.r(r2),
          g: utils_default.channel.clamp.g(g2),
          b: utils_default.channel.clamp.b(b2),
          a: utils_default.channel.clamp.a(a2)
        });
        return color_default.stringify(channels2);
      }, "rgba");
      rgba_default = rgba;
    }
  });

  // ../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/methods/channel.js
  var channel, channel_default2;
  var init_channel2 = __esm({
    "../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/methods/channel.js"() {
      "use strict";
      init_utils();
      init_color();
      channel = /* @__PURE__ */ __name((color2, channel2) => {
        return utils_default.lang.round(color_default.parse(color2)[channel2]);
      }, "channel");
      channel_default2 = channel;
    }
  });

  // ../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/methods/luminance.js
  var luminance, luminance_default;
  var init_luminance = __esm({
    "../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/methods/luminance.js"() {
      "use strict";
      init_utils();
      init_color();
      luminance = /* @__PURE__ */ __name((color2) => {
        const { r: r2, g: g2, b: b2 } = color_default.parse(color2);
        const luminance2 = 0.2126 * utils_default.channel.toLinear(r2) + 0.7152 * utils_default.channel.toLinear(g2) + 0.0722 * utils_default.channel.toLinear(b2);
        return utils_default.lang.round(luminance2);
      }, "luminance");
      luminance_default = luminance;
    }
  });

  // ../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/methods/is_light.js
  var isLight, is_light_default;
  var init_is_light = __esm({
    "../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/methods/is_light.js"() {
      "use strict";
      init_luminance();
      isLight = /* @__PURE__ */ __name((color2) => {
        return luminance_default(color2) >= 0.5;
      }, "isLight");
      is_light_default = isLight;
    }
  });

  // ../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/methods/is_dark.js
  var isDark, is_dark_default;
  var init_is_dark = __esm({
    "../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/methods/is_dark.js"() {
      "use strict";
      init_is_light();
      isDark = /* @__PURE__ */ __name((color2) => {
        return !is_light_default(color2);
      }, "isDark");
      is_dark_default = isDark;
    }
  });

  // ../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/methods/adjust_channel.js
  var adjustChannel, adjust_channel_default;
  var init_adjust_channel = __esm({
    "../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/methods/adjust_channel.js"() {
      "use strict";
      init_utils();
      init_color();
      adjustChannel = /* @__PURE__ */ __name((color2, channel2, amount) => {
        const channels2 = color_default.parse(color2);
        const amountCurrent = channels2[channel2];
        const amountNext = utils_default.channel.clamp[channel2](amountCurrent + amount);
        if (amountCurrent !== amountNext)
          channels2[channel2] = amountNext;
        return color_default.stringify(channels2);
      }, "adjustChannel");
      adjust_channel_default = adjustChannel;
    }
  });

  // ../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/methods/lighten.js
  var lighten, lighten_default;
  var init_lighten = __esm({
    "../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/methods/lighten.js"() {
      "use strict";
      init_adjust_channel();
      lighten = /* @__PURE__ */ __name((color2, amount) => {
        return adjust_channel_default(color2, "l", amount);
      }, "lighten");
      lighten_default = lighten;
    }
  });

  // ../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/methods/darken.js
  var darken, darken_default;
  var init_darken = __esm({
    "../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/methods/darken.js"() {
      "use strict";
      init_adjust_channel();
      darken = /* @__PURE__ */ __name((color2, amount) => {
        return adjust_channel_default(color2, "l", -amount);
      }, "darken");
      darken_default = darken;
    }
  });

  // ../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/methods/adjust.js
  var adjust, adjust_default;
  var init_adjust = __esm({
    "../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/methods/adjust.js"() {
      "use strict";
      init_color();
      init_change();
      adjust = /* @__PURE__ */ __name((color2, channels2) => {
        const ch = color_default.parse(color2);
        const changes = {};
        for (const c3 in channels2) {
          if (!channels2[c3])
            continue;
          changes[c3] = ch[c3] + channels2[c3];
        }
        return change_default(color2, changes);
      }, "adjust");
      adjust_default = adjust;
    }
  });

  // ../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/methods/mix.js
  var mix, mix_default;
  var init_mix = __esm({
    "../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/methods/mix.js"() {
      "use strict";
      init_color();
      init_rgba();
      mix = /* @__PURE__ */ __name((color1, color2, weight8 = 50) => {
        const { r: r1, g: g1, b: b1, a: a1 } = color_default.parse(color1);
        const { r: r2, g: g2, b: b2, a: a2 } = color_default.parse(color2);
        const weightScale = weight8 / 100;
        const weightNormalized = weightScale * 2 - 1;
        const alphaDelta = a1 - a2;
        const weight1combined = weightNormalized * alphaDelta === -1 ? weightNormalized : (weightNormalized + alphaDelta) / (1 + weightNormalized * alphaDelta);
        const weight1 = (weight1combined + 1) / 2;
        const weight22 = 1 - weight1;
        const r3 = r1 * weight1 + r2 * weight22;
        const g3 = g1 * weight1 + g2 * weight22;
        const b3 = b1 * weight1 + b2 * weight22;
        const a3 = a1 * weightScale + a2 * (1 - weightScale);
        return rgba_default(r3, g3, b3, a3);
      }, "mix");
      mix_default = mix;
    }
  });

  // ../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/methods/invert.js
  var invert, invert_default;
  var init_invert = __esm({
    "../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/methods/invert.js"() {
      "use strict";
      init_color();
      init_mix();
      invert = /* @__PURE__ */ __name((color2, weight8 = 100) => {
        const inverse = color_default.parse(color2);
        inverse.r = 255 - inverse.r;
        inverse.g = 255 - inverse.g;
        inverse.b = 255 - inverse.b;
        return mix_default(inverse, color2, weight8);
      }, "invert");
      invert_default = invert;
    }
  });

  // ../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/methods/index.js
  var init_methods = __esm({
    "../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/methods/index.js"() {
      "use strict";
      init_rgba();
      init_channel2();
      init_is_dark();
      init_lighten();
      init_darken();
      init_adjust();
      init_invert();
    }
  });

  // ../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/index.js
  var init_dist = __esm({
    "../../node_modules/.pnpm/khroma@2.1.0/node_modules/khroma/dist/index.js"() {
      "use strict";
      init_methods();
    }
  });

  // src/themes/erDiagram-oldHardcodedValues.ts
  var oldAttributeBackgroundColorOdd, oldAttributeBackgroundColorEven;
  var init_erDiagram_oldHardcodedValues = __esm({
    "src/themes/erDiagram-oldHardcodedValues.ts"() {
      "use strict";
      oldAttributeBackgroundColorOdd = "#ffffff";
      oldAttributeBackgroundColorEven = "#f2f2f2";
    }
  });

  // src/themes/theme-helpers.js
  var mkBorder;
  var init_theme_helpers = __esm({
    "src/themes/theme-helpers.js"() {
      "use strict";
      init_dist();
      mkBorder = /* @__PURE__ */ __name((col, darkMode) => darkMode ? adjust_default(col, { s: -40, l: 10 }) : adjust_default(col, { s: -40, l: -10 }), "mkBorder");
    }
  });

  // src/themes/theme-base.js
  var Theme, getThemeVariables;
  var init_theme_base = __esm({
    "src/themes/theme-base.js"() {
      "use strict";
      init_dist();
      init_erDiagram_oldHardcodedValues();
      init_theme_helpers();
      Theme = class {
        static {
          __name(this, "Theme");
        }
        constructor() {
          this.background = "#f4f4f4";
          this.primaryColor = "#fff4dd";
          this.noteBkgColor = "#fff5ad";
          this.noteTextColor = "#333";
          this.THEME_COLOR_LIMIT = 12;
          this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
          this.fontSize = "16px";
        }
        updateColors() {
          this.primaryTextColor = this.primaryTextColor || (this.darkMode ? "#eee" : "#333");
          this.secondaryColor = this.secondaryColor || adjust_default(this.primaryColor, { h: -120 });
          this.tertiaryColor = this.tertiaryColor || adjust_default(this.primaryColor, { h: 180, l: 5 });
          this.primaryBorderColor = this.primaryBorderColor || mkBorder(this.primaryColor, this.darkMode);
          this.secondaryBorderColor = this.secondaryBorderColor || mkBorder(this.secondaryColor, this.darkMode);
          this.tertiaryBorderColor = this.tertiaryBorderColor || mkBorder(this.tertiaryColor, this.darkMode);
          this.noteBorderColor = this.noteBorderColor || mkBorder(this.noteBkgColor, this.darkMode);
          this.noteBkgColor = this.noteBkgColor || "#fff5ad";
          this.noteTextColor = this.noteTextColor || "#333";
          this.secondaryTextColor = this.secondaryTextColor || invert_default(this.secondaryColor);
          this.tertiaryTextColor = this.tertiaryTextColor || invert_default(this.tertiaryColor);
          this.lineColor = this.lineColor || invert_default(this.background);
          this.arrowheadColor = this.arrowheadColor || invert_default(this.background);
          this.textColor = this.textColor || this.primaryTextColor;
          this.border2 = this.border2 || this.tertiaryBorderColor;
          this.nodeBkg = this.nodeBkg || this.primaryColor;
          this.mainBkg = this.mainBkg || this.primaryColor;
          this.nodeBorder = this.nodeBorder || this.primaryBorderColor;
          this.clusterBkg = this.clusterBkg || this.tertiaryColor;
          this.clusterBorder = this.clusterBorder || this.tertiaryBorderColor;
          this.defaultLinkColor = this.defaultLinkColor || this.lineColor;
          this.titleColor = this.titleColor || this.tertiaryTextColor;
          this.edgeLabelBackground = this.edgeLabelBackground || (this.darkMode ? darken_default(this.secondaryColor, 30) : this.secondaryColor);
          this.nodeTextColor = this.nodeTextColor || this.primaryTextColor;
          this.actorBorder = this.actorBorder || this.primaryBorderColor;
          this.actorBkg = this.actorBkg || this.mainBkg;
          this.actorTextColor = this.actorTextColor || this.primaryTextColor;
          this.actorLineColor = this.actorLineColor || this.actorBorder;
          this.labelBoxBkgColor = this.labelBoxBkgColor || this.actorBkg;
          this.signalColor = this.signalColor || this.textColor;
          this.signalTextColor = this.signalTextColor || this.textColor;
          this.labelBoxBorderColor = this.labelBoxBorderColor || this.actorBorder;
          this.labelTextColor = this.labelTextColor || this.actorTextColor;
          this.loopTextColor = this.loopTextColor || this.actorTextColor;
          this.activationBorderColor = this.activationBorderColor || darken_default(this.secondaryColor, 10);
          this.activationBkgColor = this.activationBkgColor || this.secondaryColor;
          this.sequenceNumberColor = this.sequenceNumberColor || invert_default(this.lineColor);
          this.sectionBkgColor = this.sectionBkgColor || this.tertiaryColor;
          this.altSectionBkgColor = this.altSectionBkgColor || "white";
          this.sectionBkgColor = this.sectionBkgColor || this.secondaryColor;
          this.sectionBkgColor2 = this.sectionBkgColor2 || this.primaryColor;
          this.excludeBkgColor = this.excludeBkgColor || "#eeeeee";
          this.taskBorderColor = this.taskBorderColor || this.primaryBorderColor;
          this.taskBkgColor = this.taskBkgColor || this.primaryColor;
          this.activeTaskBorderColor = this.activeTaskBorderColor || this.primaryColor;
          this.activeTaskBkgColor = this.activeTaskBkgColor || lighten_default(this.primaryColor, 23);
          this.gridColor = this.gridColor || "lightgrey";
          this.doneTaskBkgColor = this.doneTaskBkgColor || "lightgrey";
          this.doneTaskBorderColor = this.doneTaskBorderColor || "grey";
          this.critBorderColor = this.critBorderColor || "#ff8888";
          this.critBkgColor = this.critBkgColor || "red";
          this.todayLineColor = this.todayLineColor || "red";
          this.taskTextColor = this.taskTextColor || this.textColor;
          this.taskTextOutsideColor = this.taskTextOutsideColor || this.textColor;
          this.taskTextLightColor = this.taskTextLightColor || this.textColor;
          this.taskTextColor = this.taskTextColor || this.primaryTextColor;
          this.taskTextDarkColor = this.taskTextDarkColor || this.textColor;
          this.taskTextClickableColor = this.taskTextClickableColor || "#003163";
          this.personBorder = this.personBorder || this.primaryBorderColor;
          this.personBkg = this.personBkg || this.mainBkg;
          this.transitionColor = this.transitionColor || this.lineColor;
          this.transitionLabelColor = this.transitionLabelColor || this.textColor;
          this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
          this.stateBkg = this.stateBkg || this.mainBkg;
          this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
          this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
          this.altBackground = this.altBackground || this.tertiaryColor;
          this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
          this.compositeBorder = this.compositeBorder || this.nodeBorder;
          this.innerEndBackground = this.nodeBorder;
          this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
          this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
          this.transitionColor = this.transitionColor || this.lineColor;
          this.specialStateColor = this.lineColor;
          this.cScale0 = this.cScale0 || this.primaryColor;
          this.cScale1 = this.cScale1 || this.secondaryColor;
          this.cScale2 = this.cScale2 || this.tertiaryColor;
          this.cScale3 = this.cScale3 || adjust_default(this.primaryColor, { h: 30 });
          this.cScale4 = this.cScale4 || adjust_default(this.primaryColor, { h: 60 });
          this.cScale5 = this.cScale5 || adjust_default(this.primaryColor, { h: 90 });
          this.cScale6 = this.cScale6 || adjust_default(this.primaryColor, { h: 120 });
          this.cScale7 = this.cScale7 || adjust_default(this.primaryColor, { h: 150 });
          this.cScale8 = this.cScale8 || adjust_default(this.primaryColor, { h: 210, l: 150 });
          this.cScale9 = this.cScale9 || adjust_default(this.primaryColor, { h: 270 });
          this.cScale10 = this.cScale10 || adjust_default(this.primaryColor, { h: 300 });
          this.cScale11 = this.cScale11 || adjust_default(this.primaryColor, { h: 330 });
          if (this.darkMode) {
            for (let i2 = 0; i2 < this.THEME_COLOR_LIMIT; i2++) {
              this["cScale" + i2] = darken_default(this["cScale" + i2], 75);
            }
          } else {
            for (let i2 = 0; i2 < this.THEME_COLOR_LIMIT; i2++) {
              this["cScale" + i2] = darken_default(this["cScale" + i2], 25);
            }
          }
          for (let i2 = 0; i2 < this.THEME_COLOR_LIMIT; i2++) {
            this["cScaleInv" + i2] = this["cScaleInv" + i2] || invert_default(this["cScale" + i2]);
          }
          for (let i2 = 0; i2 < this.THEME_COLOR_LIMIT; i2++) {
            if (this.darkMode) {
              this["cScalePeer" + i2] = this["cScalePeer" + i2] || lighten_default(this["cScale" + i2], 10);
            } else {
              this["cScalePeer" + i2] = this["cScalePeer" + i2] || darken_default(this["cScale" + i2], 10);
            }
          }
          this.scaleLabelColor = this.scaleLabelColor || this.labelTextColor;
          for (let i2 = 0; i2 < this.THEME_COLOR_LIMIT; i2++) {
            this["cScaleLabel" + i2] = this["cScaleLabel" + i2] || this.scaleLabelColor;
          }
          const multiplier = this.darkMode ? -4 : -1;
          for (let i2 = 0; i2 < 5; i2++) {
            this["surface" + i2] = this["surface" + i2] || adjust_default(this.mainBkg, { h: 180, s: -15, l: multiplier * (5 + i2 * 3) });
            this["surfacePeer" + i2] = this["surfacePeer" + i2] || adjust_default(this.mainBkg, { h: 180, s: -15, l: multiplier * (8 + i2 * 3) });
          }
          this.classText = this.classText || this.textColor;
          this.fillType0 = this.fillType0 || this.primaryColor;
          this.fillType1 = this.fillType1 || this.secondaryColor;
          this.fillType2 = this.fillType2 || adjust_default(this.primaryColor, { h: 64 });
          this.fillType3 = this.fillType3 || adjust_default(this.secondaryColor, { h: 64 });
          this.fillType4 = this.fillType4 || adjust_default(this.primaryColor, { h: -64 });
          this.fillType5 = this.fillType5 || adjust_default(this.secondaryColor, { h: -64 });
          this.fillType6 = this.fillType6 || adjust_default(this.primaryColor, { h: 128 });
          this.fillType7 = this.fillType7 || adjust_default(this.secondaryColor, { h: 128 });
          this.pie1 = this.pie1 || this.primaryColor;
          this.pie2 = this.pie2 || this.secondaryColor;
          this.pie3 = this.pie3 || this.tertiaryColor;
          this.pie4 = this.pie4 || adjust_default(this.primaryColor, { l: -10 });
          this.pie5 = this.pie5 || adjust_default(this.secondaryColor, { l: -10 });
          this.pie6 = this.pie6 || adjust_default(this.tertiaryColor, { l: -10 });
          this.pie7 = this.pie7 || adjust_default(this.primaryColor, { h: 60, l: -10 });
          this.pie8 = this.pie8 || adjust_default(this.primaryColor, { h: -60, l: -10 });
          this.pie9 = this.pie9 || adjust_default(this.primaryColor, { h: 120, l: 0 });
          this.pie10 = this.pie10 || adjust_default(this.primaryColor, { h: 60, l: -20 });
          this.pie11 = this.pie11 || adjust_default(this.primaryColor, { h: -60, l: -20 });
          this.pie12 = this.pie12 || adjust_default(this.primaryColor, { h: 120, l: -10 });
          this.pieTitleTextSize = this.pieTitleTextSize || "25px";
          this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
          this.pieSectionTextSize = this.pieSectionTextSize || "17px";
          this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
          this.pieLegendTextSize = this.pieLegendTextSize || "17px";
          this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
          this.pieStrokeColor = this.pieStrokeColor || "black";
          this.pieStrokeWidth = this.pieStrokeWidth || "2px";
          this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px";
          this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black";
          this.pieOpacity = this.pieOpacity || "0.7";
          this.archEdgeColor = this.archEdgeColor || "#777";
          this.archEdgeArrowColor = this.archEdgeArrowColor || "#777";
          this.archEdgeWidth = this.archEdgeWidth || "3";
          this.archGroupBorderColor = this.archGroupBorderColor || "#000";
          this.archGroupBorderWidth = this.archGroupBorderWidth || "2px";
          this.quadrant1Fill = this.quadrant1Fill || this.primaryColor;
          this.quadrant2Fill = this.quadrant2Fill || adjust_default(this.primaryColor, { r: 5, g: 5, b: 5 });
          this.quadrant3Fill = this.quadrant3Fill || adjust_default(this.primaryColor, { r: 10, g: 10, b: 10 });
          this.quadrant4Fill = this.quadrant4Fill || adjust_default(this.primaryColor, { r: 15, g: 15, b: 15 });
          this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor;
          this.quadrant2TextFill = this.quadrant2TextFill || adjust_default(this.primaryTextColor, { r: -5, g: -5, b: -5 });
          this.quadrant3TextFill = this.quadrant3TextFill || adjust_default(this.primaryTextColor, { r: -10, g: -10, b: -10 });
          this.quadrant4TextFill = this.quadrant4TextFill || adjust_default(this.primaryTextColor, { r: -15, g: -15, b: -15 });
          this.quadrantPointFill = this.quadrantPointFill || is_dark_default(this.quadrant1Fill) ? lighten_default(this.quadrant1Fill) : darken_default(this.quadrant1Fill);
          this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor;
          this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor;
          this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor;
          this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor;
          this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor;
          this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor;
          this.xyChart = {
            backgroundColor: this.xyChart?.backgroundColor || this.background,
            titleColor: this.xyChart?.titleColor || this.primaryTextColor,
            xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
            xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
            xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
            xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
            yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
            yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
            yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
            yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
            plotColorPalette: this.xyChart?.plotColorPalette || "#FFF4DD,#FFD8B1,#FFA07A,#ECEFF1,#D6DBDF,#C3E0A8,#FFB6A4,#FFD74D,#738FA7,#FFFFF0"
          };
          this.requirementBackground = this.requirementBackground || this.primaryColor;
          this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
          this.requirementBorderSize = this.requirementBorderSize || "1";
          this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
          this.relationColor = this.relationColor || this.lineColor;
          this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? darken_default(this.secondaryColor, 30) : this.secondaryColor);
          this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
          this.git0 = this.git0 || this.primaryColor;
          this.git1 = this.git1 || this.secondaryColor;
          this.git2 = this.git2 || this.tertiaryColor;
          this.git3 = this.git3 || adjust_default(this.primaryColor, { h: -30 });
          this.git4 = this.git4 || adjust_default(this.primaryColor, { h: -60 });
          this.git5 = this.git5 || adjust_default(this.primaryColor, { h: -90 });
          this.git6 = this.git6 || adjust_default(this.primaryColor, { h: 60 });
          this.git7 = this.git7 || adjust_default(this.primaryColor, { h: 120 });
          if (this.darkMode) {
            this.git0 = lighten_default(this.git0, 25);
            this.git1 = lighten_default(this.git1, 25);
            this.git2 = lighten_default(this.git2, 25);
            this.git3 = lighten_default(this.git3, 25);
            this.git4 = lighten_default(this.git4, 25);
            this.git5 = lighten_default(this.git5, 25);
            this.git6 = lighten_default(this.git6, 25);
            this.git7 = lighten_default(this.git7, 25);
          } else {
            this.git0 = darken_default(this.git0, 25);
            this.git1 = darken_default(this.git1, 25);
            this.git2 = darken_default(this.git2, 25);
            this.git3 = darken_default(this.git3, 25);
            this.git4 = darken_default(this.git4, 25);
            this.git5 = darken_default(this.git5, 25);
            this.git6 = darken_default(this.git6, 25);
            this.git7 = darken_default(this.git7, 25);
          }
          this.gitInv0 = this.gitInv0 || invert_default(this.git0);
          this.gitInv1 = this.gitInv1 || invert_default(this.git1);
          this.gitInv2 = this.gitInv2 || invert_default(this.git2);
          this.gitInv3 = this.gitInv3 || invert_default(this.git3);
          this.gitInv4 = this.gitInv4 || invert_default(this.git4);
          this.gitInv5 = this.gitInv5 || invert_default(this.git5);
          this.gitInv6 = this.gitInv6 || invert_default(this.git6);
          this.gitInv7 = this.gitInv7 || invert_default(this.git7);
          this.branchLabelColor = this.branchLabelColor || (this.darkMode ? "black" : this.labelTextColor);
          this.gitBranchLabel0 = this.gitBranchLabel0 || this.branchLabelColor;
          this.gitBranchLabel1 = this.gitBranchLabel1 || this.branchLabelColor;
          this.gitBranchLabel2 = this.gitBranchLabel2 || this.branchLabelColor;
          this.gitBranchLabel3 = this.gitBranchLabel3 || this.branchLabelColor;
          this.gitBranchLabel4 = this.gitBranchLabel4 || this.branchLabelColor;
          this.gitBranchLabel5 = this.gitBranchLabel5 || this.branchLabelColor;
          this.gitBranchLabel6 = this.gitBranchLabel6 || this.branchLabelColor;
          this.gitBranchLabel7 = this.gitBranchLabel7 || this.branchLabelColor;
          this.tagLabelColor = this.tagLabelColor || this.primaryTextColor;
          this.tagLabelBackground = this.tagLabelBackground || this.primaryColor;
          this.tagLabelBorder = this.tagBorder || this.primaryBorderColor;
          this.tagLabelFontSize = this.tagLabelFontSize || "10px";
          this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor;
          this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor;
          this.commitLabelFontSize = this.commitLabelFontSize || "10px";
          this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || oldAttributeBackgroundColorOdd;
          this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || oldAttributeBackgroundColorEven;
        }
        calculate(overrides) {
          if (typeof overrides !== "object") {
            this.updateColors();
            return;
          }
          const keys3 = Object.keys(overrides);
          keys3.forEach((k2) => {
            this[k2] = overrides[k2];
          });
          this.updateColors();
          keys3.forEach((k2) => {
            this[k2] = overrides[k2];
          });
        }
      };
      getThemeVariables = /* @__PURE__ */ __name((userOverrides) => {
        const theme = new Theme();
        theme.calculate(userOverrides);
        return theme;
      }, "getThemeVariables");
    }
  });

  // src/themes/theme-dark.js
  var Theme2, getThemeVariables2;
  var init_theme_dark = __esm({
    "src/themes/theme-dark.js"() {
      "use strict";
      init_dist();
      init_theme_helpers();
      Theme2 = class {
        static {
          __name(this, "Theme");
        }
        constructor() {
          this.background = "#333";
          this.primaryColor = "#1f2020";
          this.secondaryColor = lighten_default(this.primaryColor, 16);
          this.tertiaryColor = adjust_default(this.primaryColor, { h: -160 });
          this.primaryBorderColor = invert_default(this.background);
          this.secondaryBorderColor = mkBorder(this.secondaryColor, this.darkMode);
          this.tertiaryBorderColor = mkBorder(this.tertiaryColor, this.darkMode);
          this.primaryTextColor = invert_default(this.primaryColor);
          this.secondaryTextColor = invert_default(this.secondaryColor);
          this.tertiaryTextColor = invert_default(this.tertiaryColor);
          this.lineColor = invert_default(this.background);
          this.textColor = invert_default(this.background);
          this.mainBkg = "#1f2020";
          this.secondBkg = "calculated";
          this.mainContrastColor = "lightgrey";
          this.darkTextColor = lighten_default(invert_default("#323D47"), 10);
          this.lineColor = "calculated";
          this.border1 = "#ccc";
          this.border2 = rgba_default(255, 255, 255, 0.25);
          this.arrowheadColor = "calculated";
          this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
          this.fontSize = "16px";
          this.labelBackground = "#181818";
          this.textColor = "#ccc";
          this.THEME_COLOR_LIMIT = 12;
          this.nodeBkg = "calculated";
          this.nodeBorder = "calculated";
          this.clusterBkg = "calculated";
          this.clusterBorder = "calculated";
          this.defaultLinkColor = "calculated";
          this.titleColor = "#F9FFFE";
          this.edgeLabelBackground = "calculated";
          this.actorBorder = "calculated";
          this.actorBkg = "calculated";
          this.actorTextColor = "calculated";
          this.actorLineColor = "calculated";
          this.signalColor = "calculated";
          this.signalTextColor = "calculated";
          this.labelBoxBkgColor = "calculated";
          this.labelBoxBorderColor = "calculated";
          this.labelTextColor = "calculated";
          this.loopTextColor = "calculated";
          this.noteBorderColor = "calculated";
          this.noteBkgColor = "#fff5ad";
          this.noteTextColor = "calculated";
          this.activationBorderColor = "calculated";
          this.activationBkgColor = "calculated";
          this.sequenceNumberColor = "black";
          this.sectionBkgColor = darken_default("#EAE8D9", 30);
          this.altSectionBkgColor = "calculated";
          this.sectionBkgColor2 = "#EAE8D9";
          this.excludeBkgColor = darken_default(this.sectionBkgColor, 10);
          this.taskBorderColor = rgba_default(255, 255, 255, 70);
          this.taskBkgColor = "calculated";
          this.taskTextColor = "calculated";
          this.taskTextLightColor = "calculated";
          this.taskTextOutsideColor = "calculated";
          this.taskTextClickableColor = "#003163";
          this.activeTaskBorderColor = rgba_default(255, 255, 255, 50);
          this.activeTaskBkgColor = "#81B1DB";
          this.gridColor = "calculated";
          this.doneTaskBkgColor = "calculated";
          this.doneTaskBorderColor = "grey";
          this.critBorderColor = "#E83737";
          this.critBkgColor = "#E83737";
          this.taskTextDarkColor = "calculated";
          this.todayLineColor = "#DB5757";
          this.personBorder = this.primaryBorderColor;
          this.personBkg = this.mainBkg;
          this.archEdgeColor = "calculated";
          this.archEdgeArrowColor = "calculated";
          this.archEdgeWidth = "3";
          this.archGroupBorderColor = this.primaryBorderColor;
          this.archGroupBorderWidth = "2px";
          this.labelColor = "calculated";
          this.errorBkgColor = "#a44141";
          this.errorTextColor = "#ddd";
        }
        updateColors() {
          this.secondBkg = lighten_default(this.mainBkg, 16);
          this.lineColor = this.mainContrastColor;
          this.arrowheadColor = this.mainContrastColor;
          this.nodeBkg = this.mainBkg;
          this.nodeBorder = this.border1;
          this.clusterBkg = this.secondBkg;
          this.clusterBorder = this.border2;
          this.defaultLinkColor = this.lineColor;
          this.edgeLabelBackground = lighten_default(this.labelBackground, 25);
          this.actorBorder = this.border1;
          this.actorBkg = this.mainBkg;
          this.actorTextColor = this.mainContrastColor;
          this.actorLineColor = this.actorBorder;
          this.signalColor = this.mainContrastColor;
          this.signalTextColor = this.mainContrastColor;
          this.labelBoxBkgColor = this.actorBkg;
          this.labelBoxBorderColor = this.actorBorder;
          this.labelTextColor = this.mainContrastColor;
          this.loopTextColor = this.mainContrastColor;
          this.noteBorderColor = this.secondaryBorderColor;
          this.noteBkgColor = this.secondBkg;
          this.noteTextColor = this.secondaryTextColor;
          this.activationBorderColor = this.border1;
          this.activationBkgColor = this.secondBkg;
          this.altSectionBkgColor = this.background;
          this.taskBkgColor = lighten_default(this.mainBkg, 23);
          this.taskTextColor = this.darkTextColor;
          this.taskTextLightColor = this.mainContrastColor;
          this.taskTextOutsideColor = this.taskTextLightColor;
          this.gridColor = this.mainContrastColor;
          this.doneTaskBkgColor = this.mainContrastColor;
          this.taskTextDarkColor = this.darkTextColor;
          this.archEdgeColor = this.lineColor;
          this.archEdgeArrowColor = this.lineColor;
          this.transitionColor = this.transitionColor || this.lineColor;
          this.transitionLabelColor = this.transitionLabelColor || this.textColor;
          this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
          this.stateBkg = this.stateBkg || this.mainBkg;
          this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
          this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
          this.altBackground = this.altBackground || "#555";
          this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
          this.compositeBorder = this.compositeBorder || this.nodeBorder;
          this.innerEndBackground = this.primaryBorderColor;
          this.specialStateColor = "#f4f4f4";
          this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
          this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
          this.fillType0 = this.primaryColor;
          this.fillType1 = this.secondaryColor;
          this.fillType2 = adjust_default(this.primaryColor, { h: 64 });
          this.fillType3 = adjust_default(this.secondaryColor, { h: 64 });
          this.fillType4 = adjust_default(this.primaryColor, { h: -64 });
          this.fillType5 = adjust_default(this.secondaryColor, { h: -64 });
          this.fillType6 = adjust_default(this.primaryColor, { h: 128 });
          this.fillType7 = adjust_default(this.secondaryColor, { h: 128 });
          this.cScale1 = this.cScale1 || "#0b0000";
          this.cScale2 = this.cScale2 || "#4d1037";
          this.cScale3 = this.cScale3 || "#3f5258";
          this.cScale4 = this.cScale4 || "#4f2f1b";
          this.cScale5 = this.cScale5 || "#6e0a0a";
          this.cScale6 = this.cScale6 || "#3b0048";
          this.cScale7 = this.cScale7 || "#995a01";
          this.cScale8 = this.cScale8 || "#154706";
          this.cScale9 = this.cScale9 || "#161722";
          this.cScale10 = this.cScale10 || "#00296f";
          this.cScale11 = this.cScale11 || "#01629c";
          this.cScale12 = this.cScale12 || "#010029";
          this.cScale0 = this.cScale0 || this.primaryColor;
          this.cScale1 = this.cScale1 || this.secondaryColor;
          this.cScale2 = this.cScale2 || this.tertiaryColor;
          this.cScale3 = this.cScale3 || adjust_default(this.primaryColor, { h: 30 });
          this.cScale4 = this.cScale4 || adjust_default(this.primaryColor, { h: 60 });
          this.cScale5 = this.cScale5 || adjust_default(this.primaryColor, { h: 90 });
          this.cScale6 = this.cScale6 || adjust_default(this.primaryColor, { h: 120 });
          this.cScale7 = this.cScale7 || adjust_default(this.primaryColor, { h: 150 });
          this.cScale8 = this.cScale8 || adjust_default(this.primaryColor, { h: 210 });
          this.cScale9 = this.cScale9 || adjust_default(this.primaryColor, { h: 270 });
          this.cScale10 = this.cScale10 || adjust_default(this.primaryColor, { h: 300 });
          this.cScale11 = this.cScale11 || adjust_default(this.primaryColor, { h: 330 });
          for (let i2 = 0; i2 < this.THEME_COLOR_LIMIT; i2++) {
            this["cScaleInv" + i2] = this["cScaleInv" + i2] || invert_default(this["cScale" + i2]);
          }
          for (let i2 = 0; i2 < this.THEME_COLOR_LIMIT; i2++) {
            this["cScalePeer" + i2] = this["cScalePeer" + i2] || lighten_default(this["cScale" + i2], 10);
          }
          for (let i2 = 0; i2 < 5; i2++) {
            this["surface" + i2] = this["surface" + i2] || adjust_default(this.mainBkg, { h: 30, s: -30, l: -(-10 + i2 * 4) });
            this["surfacePeer" + i2] = this["surfacePeer" + i2] || adjust_default(this.mainBkg, { h: 30, s: -30, l: -(-7 + i2 * 4) });
          }
          this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor);
          for (let i2 = 0; i2 < this.THEME_COLOR_LIMIT; i2++) {
            this["cScaleLabel" + i2] = this["cScaleLabel" + i2] || this.scaleLabelColor;
          }
          for (let i2 = 0; i2 < this.THEME_COLOR_LIMIT; i2++) {
            this["pie" + i2] = this["cScale" + i2];
          }
          this.pieTitleTextSize = this.pieTitleTextSize || "25px";
          this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
          this.pieSectionTextSize = this.pieSectionTextSize || "17px";
          this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
          this.pieLegendTextSize = this.pieLegendTextSize || "17px";
          this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
          this.pieStrokeColor = this.pieStrokeColor || "black";
          this.pieStrokeWidth = this.pieStrokeWidth || "2px";
          this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px";
          this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black";
          this.pieOpacity = this.pieOpacity || "0.7";
          this.quadrant1Fill = this.quadrant1Fill || this.primaryColor;
          this.quadrant2Fill = this.quadrant2Fill || adjust_default(this.primaryColor, { r: 5, g: 5, b: 5 });
          this.quadrant3Fill = this.quadrant3Fill || adjust_default(this.primaryColor, { r: 10, g: 10, b: 10 });
          this.quadrant4Fill = this.quadrant4Fill || adjust_default(this.primaryColor, { r: 15, g: 15, b: 15 });
          this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor;
          this.quadrant2TextFill = this.quadrant2TextFill || adjust_default(this.primaryTextColor, { r: -5, g: -5, b: -5 });
          this.quadrant3TextFill = this.quadrant3TextFill || adjust_default(this.primaryTextColor, { r: -10, g: -10, b: -10 });
          this.quadrant4TextFill = this.quadrant4TextFill || adjust_default(this.primaryTextColor, { r: -15, g: -15, b: -15 });
          this.quadrantPointFill = this.quadrantPointFill || is_dark_default(this.quadrant1Fill) ? lighten_default(this.quadrant1Fill) : darken_default(this.quadrant1Fill);
          this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor;
          this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor;
          this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor;
          this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor;
          this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor;
          this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor;
          this.xyChart = {
            backgroundColor: this.xyChart?.backgroundColor || this.background,
            titleColor: this.xyChart?.titleColor || this.primaryTextColor,
            xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
            xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
            xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
            xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
            yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
            yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
            yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
            yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
            plotColorPalette: this.xyChart?.plotColorPalette || "#3498db,#2ecc71,#e74c3c,#f1c40f,#bdc3c7,#ffffff,#34495e,#9b59b6,#1abc9c,#e67e22"
          };
          this.packet = {
            startByteColor: this.primaryTextColor,
            endByteColor: this.primaryTextColor,
            labelColor: this.primaryTextColor,
            titleColor: this.primaryTextColor,
            blockStrokeColor: this.primaryTextColor,
            blockFillColor: this.background
          };
          this.classText = this.primaryTextColor;
          this.requirementBackground = this.requirementBackground || this.primaryColor;
          this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
          this.requirementBorderSize = this.requirementBorderSize || "1";
          this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
          this.relationColor = this.relationColor || this.lineColor;
          this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? darken_default(this.secondaryColor, 30) : this.secondaryColor);
          this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
          this.git0 = lighten_default(this.secondaryColor, 20);
          this.git1 = lighten_default(this.pie2 || this.secondaryColor, 20);
          this.git2 = lighten_default(this.pie3 || this.tertiaryColor, 20);
          this.git3 = lighten_default(this.pie4 || adjust_default(this.primaryColor, { h: -30 }), 20);
          this.git4 = lighten_default(this.pie5 || adjust_default(this.primaryColor, { h: -60 }), 20);
          this.git5 = lighten_default(this.pie6 || adjust_default(this.primaryColor, { h: -90 }), 10);
          this.git6 = lighten_default(this.pie7 || adjust_default(this.primaryColor, { h: 60 }), 10);
          this.git7 = lighten_default(this.pie8 || adjust_default(this.primaryColor, { h: 120 }), 20);
          this.gitInv0 = this.gitInv0 || invert_default(this.git0);
          this.gitInv1 = this.gitInv1 || invert_default(this.git1);
          this.gitInv2 = this.gitInv2 || invert_default(this.git2);
          this.gitInv3 = this.gitInv3 || invert_default(this.git3);
          this.gitInv4 = this.gitInv4 || invert_default(this.git4);
          this.gitInv5 = this.gitInv5 || invert_default(this.git5);
          this.gitInv6 = this.gitInv6 || invert_default(this.git6);
          this.gitInv7 = this.gitInv7 || invert_default(this.git7);
          this.gitBranchLabel0 = this.gitBranchLabel0 || invert_default(this.labelTextColor);
          this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor;
          this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor;
          this.gitBranchLabel3 = this.gitBranchLabel3 || invert_default(this.labelTextColor);
          this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor;
          this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor;
          this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor;
          this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor;
          this.tagLabelColor = this.tagLabelColor || this.primaryTextColor;
          this.tagLabelBackground = this.tagLabelBackground || this.primaryColor;
          this.tagLabelBorder = this.tagBorder || this.primaryBorderColor;
          this.tagLabelFontSize = this.tagLabelFontSize || "10px";
          this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor;
          this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor;
          this.commitLabelFontSize = this.commitLabelFontSize || "10px";
          this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || lighten_default(this.background, 12);
          this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || lighten_default(this.background, 2);
          this.nodeBorder = this.nodeBorder || "#999";
        }
        calculate(overrides) {
          if (typeof overrides !== "object") {
            this.updateColors();
            return;
          }
          const keys3 = Object.keys(overrides);
          keys3.forEach((k2) => {
            this[k2] = overrides[k2];
          });
          this.updateColors();
          keys3.forEach((k2) => {
            this[k2] = overrides[k2];
          });
        }
      };
      getThemeVariables2 = /* @__PURE__ */ __name((userOverrides) => {
        const theme = new Theme2();
        theme.calculate(userOverrides);
        return theme;
      }, "getThemeVariables");
    }
  });

  // src/themes/theme-default.js
  var Theme3, getThemeVariables3;
  var init_theme_default = __esm({
    "src/themes/theme-default.js"() {
      "use strict";
      init_dist();
      init_theme_helpers();
      init_erDiagram_oldHardcodedValues();
      Theme3 = class {
        static {
          __name(this, "Theme");
        }
        constructor() {
          this.background = "#f4f4f4";
          this.primaryColor = "#ECECFF";
          this.secondaryColor = adjust_default(this.primaryColor, { h: 120 });
          this.secondaryColor = "#ffffde";
          this.tertiaryColor = adjust_default(this.primaryColor, { h: -160 });
          this.primaryBorderColor = mkBorder(this.primaryColor, this.darkMode);
          this.secondaryBorderColor = mkBorder(this.secondaryColor, this.darkMode);
          this.tertiaryBorderColor = mkBorder(this.tertiaryColor, this.darkMode);
          this.primaryTextColor = invert_default(this.primaryColor);
          this.secondaryTextColor = invert_default(this.secondaryColor);
          this.tertiaryTextColor = invert_default(this.tertiaryColor);
          this.lineColor = invert_default(this.background);
          this.textColor = invert_default(this.background);
          this.background = "white";
          this.mainBkg = "#ECECFF";
          this.secondBkg = "#ffffde";
          this.lineColor = "#333333";
          this.border1 = "#9370DB";
          this.border2 = "#aaaa33";
          this.arrowheadColor = "#333333";
          this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
          this.fontSize = "16px";
          this.labelBackground = "rgba(232,232,232, 0.8)";
          this.textColor = "#333";
          this.THEME_COLOR_LIMIT = 12;
          this.nodeBkg = "calculated";
          this.nodeBorder = "calculated";
          this.clusterBkg = "calculated";
          this.clusterBorder = "calculated";
          this.defaultLinkColor = "calculated";
          this.titleColor = "calculated";
          this.edgeLabelBackground = "calculated";
          this.actorBorder = "calculated";
          this.actorBkg = "calculated";
          this.actorTextColor = "black";
          this.actorLineColor = "calculated";
          this.signalColor = "calculated";
          this.signalTextColor = "calculated";
          this.labelBoxBkgColor = "calculated";
          this.labelBoxBorderColor = "calculated";
          this.labelTextColor = "calculated";
          this.loopTextColor = "calculated";
          this.noteBorderColor = "calculated";
          this.noteBkgColor = "#fff5ad";
          this.noteTextColor = "calculated";
          this.activationBorderColor = "#666";
          this.activationBkgColor = "#f4f4f4";
          this.sequenceNumberColor = "white";
          this.sectionBkgColor = "calculated";
          this.altSectionBkgColor = "calculated";
          this.sectionBkgColor2 = "calculated";
          this.excludeBkgColor = "#eeeeee";
          this.taskBorderColor = "calculated";
          this.taskBkgColor = "calculated";
          this.taskTextLightColor = "calculated";
          this.taskTextColor = this.taskTextLightColor;
          this.taskTextDarkColor = "calculated";
          this.taskTextOutsideColor = this.taskTextDarkColor;
          this.taskTextClickableColor = "calculated";
          this.activeTaskBorderColor = "calculated";
          this.activeTaskBkgColor = "calculated";
          this.gridColor = "calculated";
          this.doneTaskBkgColor = "calculated";
          this.doneTaskBorderColor = "calculated";
          this.critBorderColor = "calculated";
          this.critBkgColor = "calculated";
          this.todayLineColor = "calculated";
          this.sectionBkgColor = rgba_default(102, 102, 255, 0.49);
          this.altSectionBkgColor = "white";
          this.sectionBkgColor2 = "#fff400";
          this.taskBorderColor = "#534fbc";
          this.taskBkgColor = "#8a90dd";
          this.taskTextLightColor = "white";
          this.taskTextColor = "calculated";
          this.taskTextDarkColor = "black";
          this.taskTextOutsideColor = "calculated";
          this.taskTextClickableColor = "#003163";
          this.activeTaskBorderColor = "#534fbc";
          this.activeTaskBkgColor = "#bfc7ff";
          this.gridColor = "lightgrey";
          this.doneTaskBkgColor = "lightgrey";
          this.doneTaskBorderColor = "grey";
          this.critBorderColor = "#ff8888";
          this.critBkgColor = "red";
          this.todayLineColor = "red";
          this.personBorder = this.primaryBorderColor;
          this.personBkg = this.mainBkg;
          this.archEdgeColor = "calculated";
          this.archEdgeArrowColor = "calculated";
          this.archEdgeWidth = "3";
          this.archGroupBorderColor = this.primaryBorderColor;
          this.archGroupBorderWidth = "2px";
          this.labelColor = "black";
          this.errorBkgColor = "#552222";
          this.errorTextColor = "#552222";
          this.updateColors();
        }
        updateColors() {
          this.cScale0 = this.cScale0 || this.primaryColor;
          this.cScale1 = this.cScale1 || this.secondaryColor;
          this.cScale2 = this.cScale2 || this.tertiaryColor;
          this.cScale3 = this.cScale3 || adjust_default(this.primaryColor, { h: 30 });
          this.cScale4 = this.cScale4 || adjust_default(this.primaryColor, { h: 60 });
          this.cScale5 = this.cScale5 || adjust_default(this.primaryColor, { h: 90 });
          this.cScale6 = this.cScale6 || adjust_default(this.primaryColor, { h: 120 });
          this.cScale7 = this.cScale7 || adjust_default(this.primaryColor, { h: 150 });
          this.cScale8 = this.cScale8 || adjust_default(this.primaryColor, { h: 210 });
          this.cScale9 = this.cScale9 || adjust_default(this.primaryColor, { h: 270 });
          this.cScale10 = this.cScale10 || adjust_default(this.primaryColor, { h: 300 });
          this.cScale11 = this.cScale11 || adjust_default(this.primaryColor, { h: 330 });
          this["cScalePeer1"] = this["cScalePeer1"] || darken_default(this.secondaryColor, 45);
          this["cScalePeer2"] = this["cScalePeer2"] || darken_default(this.tertiaryColor, 40);
          for (let i2 = 0; i2 < this.THEME_COLOR_LIMIT; i2++) {
            this["cScale" + i2] = darken_default(this["cScale" + i2], 10);
            this["cScalePeer" + i2] = this["cScalePeer" + i2] || darken_default(this["cScale" + i2], 25);
          }
          for (let i2 = 0; i2 < this.THEME_COLOR_LIMIT; i2++) {
            this["cScaleInv" + i2] = this["cScaleInv" + i2] || adjust_default(this["cScale" + i2], { h: 180 });
          }
          for (let i2 = 0; i2 < 5; i2++) {
            this["surface" + i2] = this["surface" + i2] || adjust_default(this.mainBkg, { h: 30, l: -(5 + i2 * 5) });
            this["surfacePeer" + i2] = this["surfacePeer" + i2] || adjust_default(this.mainBkg, { h: 30, l: -(7 + i2 * 5) });
          }
          this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor;
          if (this.labelTextColor !== "calculated") {
            this.cScaleLabel0 = this.cScaleLabel0 || invert_default(this.labelTextColor);
            this.cScaleLabel3 = this.cScaleLabel3 || invert_default(this.labelTextColor);
            for (let i2 = 0; i2 < this.THEME_COLOR_LIMIT; i2++) {
              this["cScaleLabel" + i2] = this["cScaleLabel" + i2] || this.labelTextColor;
            }
          }
          this.nodeBkg = this.mainBkg;
          this.nodeBorder = this.border1;
          this.clusterBkg = this.secondBkg;
          this.clusterBorder = this.border2;
          this.defaultLinkColor = this.lineColor;
          this.titleColor = this.textColor;
          this.edgeLabelBackground = this.labelBackground;
          this.actorBorder = lighten_default(this.border1, 23);
          this.actorBkg = this.mainBkg;
          this.labelBoxBkgColor = this.actorBkg;
          this.signalColor = this.textColor;
          this.signalTextColor = this.textColor;
          this.labelBoxBorderColor = this.actorBorder;
          this.labelTextColor = this.actorTextColor;
          this.loopTextColor = this.actorTextColor;
          this.noteBorderColor = this.border2;
          this.noteTextColor = this.actorTextColor;
          this.actorLineColor = this.actorBorder;
          this.taskTextColor = this.taskTextLightColor;
          this.taskTextOutsideColor = this.taskTextDarkColor;
          this.archEdgeColor = this.lineColor;
          this.archEdgeArrowColor = this.lineColor;
          this.transitionColor = this.transitionColor || this.lineColor;
          this.transitionLabelColor = this.transitionLabelColor || this.textColor;
          this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
          this.stateBkg = this.stateBkg || this.mainBkg;
          this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
          this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
          this.altBackground = this.altBackground || "#f0f0f0";
          this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
          this.compositeBorder = this.compositeBorder || this.nodeBorder;
          this.innerEndBackground = this.nodeBorder;
          this.specialStateColor = this.lineColor;
          this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
          this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
          this.transitionColor = this.transitionColor || this.lineColor;
          this.classText = this.primaryTextColor;
          this.fillType0 = this.primaryColor;
          this.fillType1 = this.secondaryColor;
          this.fillType2 = adjust_default(this.primaryColor, { h: 64 });
          this.fillType3 = adjust_default(this.secondaryColor, { h: 64 });
          this.fillType4 = adjust_default(this.primaryColor, { h: -64 });
          this.fillType5 = adjust_default(this.secondaryColor, { h: -64 });
          this.fillType6 = adjust_default(this.primaryColor, { h: 128 });
          this.fillType7 = adjust_default(this.secondaryColor, { h: 128 });
          this.pie1 = this.pie1 || this.primaryColor;
          this.pie2 = this.pie2 || this.secondaryColor;
          this.pie3 = this.pie3 || adjust_default(this.tertiaryColor, { l: -40 });
          this.pie4 = this.pie4 || adjust_default(this.primaryColor, { l: -10 });
          this.pie5 = this.pie5 || adjust_default(this.secondaryColor, { l: -30 });
          this.pie6 = this.pie6 || adjust_default(this.tertiaryColor, { l: -20 });
          this.pie7 = this.pie7 || adjust_default(this.primaryColor, { h: 60, l: -20 });
          this.pie8 = this.pie8 || adjust_default(this.primaryColor, { h: -60, l: -40 });
          this.pie9 = this.pie9 || adjust_default(this.primaryColor, { h: 120, l: -40 });
          this.pie10 = this.pie10 || adjust_default(this.primaryColor, { h: 60, l: -40 });
          this.pie11 = this.pie11 || adjust_default(this.primaryColor, { h: -90, l: -40 });
          this.pie12 = this.pie12 || adjust_default(this.primaryColor, { h: 120, l: -30 });
          this.pieTitleTextSize = this.pieTitleTextSize || "25px";
          this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
          this.pieSectionTextSize = this.pieSectionTextSize || "17px";
          this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
          this.pieLegendTextSize = this.pieLegendTextSize || "17px";
          this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
          this.pieStrokeColor = this.pieStrokeColor || "black";
          this.pieStrokeWidth = this.pieStrokeWidth || "2px";
          this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px";
          this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black";
          this.pieOpacity = this.pieOpacity || "0.7";
          this.quadrant1Fill = this.quadrant1Fill || this.primaryColor;
          this.quadrant2Fill = this.quadrant2Fill || adjust_default(this.primaryColor, { r: 5, g: 5, b: 5 });
          this.quadrant3Fill = this.quadrant3Fill || adjust_default(this.primaryColor, { r: 10, g: 10, b: 10 });
          this.quadrant4Fill = this.quadrant4Fill || adjust_default(this.primaryColor, { r: 15, g: 15, b: 15 });
          this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor;
          this.quadrant2TextFill = this.quadrant2TextFill || adjust_default(this.primaryTextColor, { r: -5, g: -5, b: -5 });
          this.quadrant3TextFill = this.quadrant3TextFill || adjust_default(this.primaryTextColor, { r: -10, g: -10, b: -10 });
          this.quadrant4TextFill = this.quadrant4TextFill || adjust_default(this.primaryTextColor, { r: -15, g: -15, b: -15 });
          this.quadrantPointFill = this.quadrantPointFill || is_dark_default(this.quadrant1Fill) ? lighten_default(this.quadrant1Fill) : darken_default(this.quadrant1Fill);
          this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor;
          this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor;
          this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor;
          this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor;
          this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor;
          this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor;
          this.xyChart = {
            backgroundColor: this.xyChart?.backgroundColor || this.background,
            titleColor: this.xyChart?.titleColor || this.primaryTextColor,
            xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
            xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
            xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
            xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
            yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
            yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
            yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
            yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
            plotColorPalette: this.xyChart?.plotColorPalette || "#ECECFF,#8493A6,#FFC3A0,#DCDDE1,#B8E994,#D1A36F,#C3CDE6,#FFB6C1,#496078,#F8F3E3"
          };
          this.requirementBackground = this.requirementBackground || this.primaryColor;
          this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
          this.requirementBorderSize = this.requirementBorderSize || "1";
          this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
          this.relationColor = this.relationColor || this.lineColor;
          this.relationLabelBackground = this.relationLabelBackground || this.labelBackground;
          this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
          this.git0 = this.git0 || this.primaryColor;
          this.git1 = this.git1 || this.secondaryColor;
          this.git2 = this.git2 || this.tertiaryColor;
          this.git3 = this.git3 || adjust_default(this.primaryColor, { h: -30 });
          this.git4 = this.git4 || adjust_default(this.primaryColor, { h: -60 });
          this.git5 = this.git5 || adjust_default(this.primaryColor, { h: -90 });
          this.git6 = this.git6 || adjust_default(this.primaryColor, { h: 60 });
          this.git7 = this.git7 || adjust_default(this.primaryColor, { h: 120 });
          if (this.darkMode) {
            this.git0 = lighten_default(this.git0, 25);
            this.git1 = lighten_default(this.git1, 25);
            this.git2 = lighten_default(this.git2, 25);
            this.git3 = lighten_default(this.git3, 25);
            this.git4 = lighten_default(this.git4, 25);
            this.git5 = lighten_default(this.git5, 25);
            this.git6 = lighten_default(this.git6, 25);
            this.git7 = lighten_default(this.git7, 25);
          } else {
            this.git0 = darken_default(this.git0, 25);
            this.git1 = darken_default(this.git1, 25);
            this.git2 = darken_default(this.git2, 25);
            this.git3 = darken_default(this.git3, 25);
            this.git4 = darken_default(this.git4, 25);
            this.git5 = darken_default(this.git5, 25);
            this.git6 = darken_default(this.git6, 25);
            this.git7 = darken_default(this.git7, 25);
          }
          this.gitInv0 = this.gitInv0 || darken_default(invert_default(this.git0), 25);
          this.gitInv1 = this.gitInv1 || invert_default(this.git1);
          this.gitInv2 = this.gitInv2 || invert_default(this.git2);
          this.gitInv3 = this.gitInv3 || invert_default(this.git3);
          this.gitInv4 = this.gitInv4 || invert_default(this.git4);
          this.gitInv5 = this.gitInv5 || invert_default(this.git5);
          this.gitInv6 = this.gitInv6 || invert_default(this.git6);
          this.gitInv7 = this.gitInv7 || invert_default(this.git7);
          this.gitBranchLabel0 = this.gitBranchLabel0 || invert_default(this.labelTextColor);
          this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor;
          this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor;
          this.gitBranchLabel3 = this.gitBranchLabel3 || invert_default(this.labelTextColor);
          this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor;
          this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor;
          this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor;
          this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor;
          this.tagLabelColor = this.tagLabelColor || this.primaryTextColor;
          this.tagLabelBackground = this.tagLabelBackground || this.primaryColor;
          this.tagLabelBorder = this.tagBorder || this.primaryBorderColor;
          this.tagLabelFontSize = this.tagLabelFontSize || "10px";
          this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor;
          this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor;
          this.commitLabelFontSize = this.commitLabelFontSize || "10px";
          this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || oldAttributeBackgroundColorOdd;
          this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || oldAttributeBackgroundColorEven;
        }
        calculate(overrides) {
          if (typeof overrides !== "object") {
            this.updateColors();
            return;
          }
          const keys3 = Object.keys(overrides);
          keys3.forEach((k2) => {
            this[k2] = overrides[k2];
          });
          this.updateColors();
          keys3.forEach((k2) => {
            this[k2] = overrides[k2];
          });
        }
      };
      getThemeVariables3 = /* @__PURE__ */ __name((userOverrides) => {
        const theme = new Theme3();
        theme.calculate(userOverrides);
        return theme;
      }, "getThemeVariables");
    }
  });

  // src/themes/theme-forest.js
  var Theme4, getThemeVariables4;
  var init_theme_forest = __esm({
    "src/themes/theme-forest.js"() {
      "use strict";
      init_dist();
      init_erDiagram_oldHardcodedValues();
      init_theme_helpers();
      Theme4 = class {
        static {
          __name(this, "Theme");
        }
        constructor() {
          this.background = "#f4f4f4";
          this.primaryColor = "#cde498";
          this.secondaryColor = "#cdffb2";
          this.background = "white";
          this.mainBkg = "#cde498";
          this.secondBkg = "#cdffb2";
          this.lineColor = "green";
          this.border1 = "#13540c";
          this.border2 = "#6eaa49";
          this.arrowheadColor = "green";
          this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
          this.fontSize = "16px";
          this.tertiaryColor = lighten_default("#cde498", 10);
          this.primaryBorderColor = mkBorder(this.primaryColor, this.darkMode);
          this.secondaryBorderColor = mkBorder(this.secondaryColor, this.darkMode);
          this.tertiaryBorderColor = mkBorder(this.tertiaryColor, this.darkMode);
          this.primaryTextColor = invert_default(this.primaryColor);
          this.secondaryTextColor = invert_default(this.secondaryColor);
          this.tertiaryTextColor = invert_default(this.primaryColor);
          this.lineColor = invert_default(this.background);
          this.textColor = invert_default(this.background);
          this.THEME_COLOR_LIMIT = 12;
          this.nodeBkg = "calculated";
          this.nodeBorder = "calculated";
          this.clusterBkg = "calculated";
          this.clusterBorder = "calculated";
          this.defaultLinkColor = "calculated";
          this.titleColor = "#333";
          this.edgeLabelBackground = "#e8e8e8";
          this.actorBorder = "calculated";
          this.actorBkg = "calculated";
          this.actorTextColor = "black";
          this.actorLineColor = "calculated";
          this.signalColor = "#333";
          this.signalTextColor = "#333";
          this.labelBoxBkgColor = "calculated";
          this.labelBoxBorderColor = "#326932";
          this.labelTextColor = "calculated";
          this.loopTextColor = "calculated";
          this.noteBorderColor = "calculated";
          this.noteBkgColor = "#fff5ad";
          this.noteTextColor = "calculated";
          this.activationBorderColor = "#666";
          this.activationBkgColor = "#f4f4f4";
          this.sequenceNumberColor = "white";
          this.sectionBkgColor = "#6eaa49";
          this.altSectionBkgColor = "white";
          this.sectionBkgColor2 = "#6eaa49";
          this.excludeBkgColor = "#eeeeee";
          this.taskBorderColor = "calculated";
          this.taskBkgColor = "#487e3a";
          this.taskTextLightColor = "white";
          this.taskTextColor = "calculated";
          this.taskTextDarkColor = "black";
          this.taskTextOutsideColor = "calculated";
          this.taskTextClickableColor = "#003163";
          this.activeTaskBorderColor = "calculated";
          this.activeTaskBkgColor = "calculated";
          this.gridColor = "lightgrey";
          this.doneTaskBkgColor = "lightgrey";
          this.doneTaskBorderColor = "grey";
          this.critBorderColor = "#ff8888";
          this.critBkgColor = "red";
          this.todayLineColor = "red";
          this.personBorder = this.primaryBorderColor;
          this.personBkg = this.mainBkg;
          this.archEdgeColor = "calculated";
          this.archEdgeArrowColor = "calculated";
          this.archEdgeWidth = "3";
          this.archGroupBorderColor = this.primaryBorderColor;
          this.archGroupBorderWidth = "2px";
          this.labelColor = "black";
          this.errorBkgColor = "#552222";
          this.errorTextColor = "#552222";
        }
        updateColors() {
          this.actorBorder = darken_default(this.mainBkg, 20);
          this.actorBkg = this.mainBkg;
          this.labelBoxBkgColor = this.actorBkg;
          this.labelTextColor = this.actorTextColor;
          this.loopTextColor = this.actorTextColor;
          this.noteBorderColor = this.border2;
          this.noteTextColor = this.actorTextColor;
          this.actorLineColor = this.actorBorder;
          this.cScale0 = this.cScale0 || this.primaryColor;
          this.cScale1 = this.cScale1 || this.secondaryColor;
          this.cScale2 = this.cScale2 || this.tertiaryColor;
          this.cScale3 = this.cScale3 || adjust_default(this.primaryColor, { h: 30 });
          this.cScale4 = this.cScale4 || adjust_default(this.primaryColor, { h: 60 });
          this.cScale5 = this.cScale5 || adjust_default(this.primaryColor, { h: 90 });
          this.cScale6 = this.cScale6 || adjust_default(this.primaryColor, { h: 120 });
          this.cScale7 = this.cScale7 || adjust_default(this.primaryColor, { h: 150 });
          this.cScale8 = this.cScale8 || adjust_default(this.primaryColor, { h: 210 });
          this.cScale9 = this.cScale9 || adjust_default(this.primaryColor, { h: 270 });
          this.cScale10 = this.cScale10 || adjust_default(this.primaryColor, { h: 300 });
          this.cScale11 = this.cScale11 || adjust_default(this.primaryColor, { h: 330 });
          this["cScalePeer1"] = this["cScalePeer1"] || darken_default(this.secondaryColor, 45);
          this["cScalePeer2"] = this["cScalePeer2"] || darken_default(this.tertiaryColor, 40);
          for (let i2 = 0; i2 < this.THEME_COLOR_LIMIT; i2++) {
            this["cScale" + i2] = darken_default(this["cScale" + i2], 10);
            this["cScalePeer" + i2] = this["cScalePeer" + i2] || darken_default(this["cScale" + i2], 25);
          }
          for (let i2 = 0; i2 < this.THEME_COLOR_LIMIT; i2++) {
            this["cScaleInv" + i2] = this["cScaleInv" + i2] || adjust_default(this["cScale" + i2], { h: 180 });
          }
          this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor;
          for (let i2 = 0; i2 < this.THEME_COLOR_LIMIT; i2++) {
            this["cScaleLabel" + i2] = this["cScaleLabel" + i2] || this.scaleLabelColor;
          }
          for (let i2 = 0; i2 < 5; i2++) {
            this["surface" + i2] = this["surface" + i2] || adjust_default(this.mainBkg, { h: 30, s: -30, l: -(5 + i2 * 5) });
            this["surfacePeer" + i2] = this["surfacePeer" + i2] || adjust_default(this.mainBkg, { h: 30, s: -30, l: -(8 + i2 * 5) });
          }
          this.nodeBkg = this.mainBkg;
          this.nodeBorder = this.border1;
          this.clusterBkg = this.secondBkg;
          this.clusterBorder = this.border2;
          this.defaultLinkColor = this.lineColor;
          this.taskBorderColor = this.border1;
          this.taskTextColor = this.taskTextLightColor;
          this.taskTextOutsideColor = this.taskTextDarkColor;
          this.activeTaskBorderColor = this.taskBorderColor;
          this.activeTaskBkgColor = this.mainBkg;
          this.archEdgeColor = this.lineColor;
          this.archEdgeArrowColor = this.lineColor;
          this.transitionColor = this.transitionColor || this.lineColor;
          this.transitionLabelColor = this.transitionLabelColor || this.textColor;
          this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
          this.stateBkg = this.stateBkg || this.mainBkg;
          this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
          this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
          this.altBackground = this.altBackground || "#f0f0f0";
          this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
          this.compositeBorder = this.compositeBorder || this.nodeBorder;
          this.innerEndBackground = this.primaryBorderColor;
          this.specialStateColor = this.lineColor;
          this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
          this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
          this.transitionColor = this.transitionColor || this.lineColor;
          this.classText = this.primaryTextColor;
          this.fillType0 = this.primaryColor;
          this.fillType1 = this.secondaryColor;
          this.fillType2 = adjust_default(this.primaryColor, { h: 64 });
          this.fillType3 = adjust_default(this.secondaryColor, { h: 64 });
          this.fillType4 = adjust_default(this.primaryColor, { h: -64 });
          this.fillType5 = adjust_default(this.secondaryColor, { h: -64 });
          this.fillType6 = adjust_default(this.primaryColor, { h: 128 });
          this.fillType7 = adjust_default(this.secondaryColor, { h: 128 });
          this.pie1 = this.pie1 || this.primaryColor;
          this.pie2 = this.pie2 || this.secondaryColor;
          this.pie3 = this.pie3 || this.tertiaryColor;
          this.pie4 = this.pie4 || adjust_default(this.primaryColor, { l: -30 });
          this.pie5 = this.pie5 || adjust_default(this.secondaryColor, { l: -30 });
          this.pie6 = this.pie6 || adjust_default(this.tertiaryColor, { h: 40, l: -40 });
          this.pie7 = this.pie7 || adjust_default(this.primaryColor, { h: 60, l: -10 });
          this.pie8 = this.pie8 || adjust_default(this.primaryColor, { h: -60, l: -10 });
          this.pie9 = this.pie9 || adjust_default(this.primaryColor, { h: 120, l: 0 });
          this.pie10 = this.pie10 || adjust_default(this.primaryColor, { h: 60, l: -50 });
          this.pie11 = this.pie11 || adjust_default(this.primaryColor, { h: -60, l: -50 });
          this.pie12 = this.pie12 || adjust_default(this.primaryColor, { h: 120, l: -50 });
          this.pieTitleTextSize = this.pieTitleTextSize || "25px";
          this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
          this.pieSectionTextSize = this.pieSectionTextSize || "17px";
          this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
          this.pieLegendTextSize = this.pieLegendTextSize || "17px";
          this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
          this.pieStrokeColor = this.pieStrokeColor || "black";
          this.pieStrokeWidth = this.pieStrokeWidth || "2px";
          this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px";
          this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black";
          this.pieOpacity = this.pieOpacity || "0.7";
          this.quadrant1Fill = this.quadrant1Fill || this.primaryColor;
          this.quadrant2Fill = this.quadrant2Fill || adjust_default(this.primaryColor, { r: 5, g: 5, b: 5 });
          this.quadrant3Fill = this.quadrant3Fill || adjust_default(this.primaryColor, { r: 10, g: 10, b: 10 });
          this.quadrant4Fill = this.quadrant4Fill || adjust_default(this.primaryColor, { r: 15, g: 15, b: 15 });
          this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor;
          this.quadrant2TextFill = this.quadrant2TextFill || adjust_default(this.primaryTextColor, { r: -5, g: -5, b: -5 });
          this.quadrant3TextFill = this.quadrant3TextFill || adjust_default(this.primaryTextColor, { r: -10, g: -10, b: -10 });
          this.quadrant4TextFill = this.quadrant4TextFill || adjust_default(this.primaryTextColor, { r: -15, g: -15, b: -15 });
          this.quadrantPointFill = this.quadrantPointFill || is_dark_default(this.quadrant1Fill) ? lighten_default(this.quadrant1Fill) : darken_default(this.quadrant1Fill);
          this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor;
          this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor;
          this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor;
          this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor;
          this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor;
          this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor;
          this.packet = {
            startByteColor: this.primaryTextColor,
            endByteColor: this.primaryTextColor,
            labelColor: this.primaryTextColor,
            titleColor: this.primaryTextColor,
            blockStrokeColor: this.primaryTextColor,
            blockFillColor: this.mainBkg
          };
          this.xyChart = {
            backgroundColor: this.xyChart?.backgroundColor || this.background,
            titleColor: this.xyChart?.titleColor || this.primaryTextColor,
            xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
            xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
            xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
            xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
            yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
            yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
            yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
            yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
            plotColorPalette: this.xyChart?.plotColorPalette || "#CDE498,#FF6B6B,#A0D2DB,#D7BDE2,#F0F0F0,#FFC3A0,#7FD8BE,#FF9A8B,#FAF3E0,#FFF176"
          };
          this.requirementBackground = this.requirementBackground || this.primaryColor;
          this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
          this.requirementBorderSize = this.requirementBorderSize || "1";
          this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
          this.relationColor = this.relationColor || this.lineColor;
          this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground;
          this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
          this.git0 = this.git0 || this.primaryColor;
          this.git1 = this.git1 || this.secondaryColor;
          this.git2 = this.git2 || this.tertiaryColor;
          this.git3 = this.git3 || adjust_default(this.primaryColor, { h: -30 });
          this.git4 = this.git4 || adjust_default(this.primaryColor, { h: -60 });
          this.git5 = this.git5 || adjust_default(this.primaryColor, { h: -90 });
          this.git6 = this.git6 || adjust_default(this.primaryColor, { h: 60 });
          this.git7 = this.git7 || adjust_default(this.primaryColor, { h: 120 });
          if (this.darkMode) {
            this.git0 = lighten_default(this.git0, 25);
            this.git1 = lighten_default(this.git1, 25);
            this.git2 = lighten_default(this.git2, 25);
            this.git3 = lighten_default(this.git3, 25);
            this.git4 = lighten_default(this.git4, 25);
            this.git5 = lighten_default(this.git5, 25);
            this.git6 = lighten_default(this.git6, 25);
            this.git7 = lighten_default(this.git7, 25);
          } else {
            this.git0 = darken_default(this.git0, 25);
            this.git1 = darken_default(this.git1, 25);
            this.git2 = darken_default(this.git2, 25);
            this.git3 = darken_default(this.git3, 25);
            this.git4 = darken_default(this.git4, 25);
            this.git5 = darken_default(this.git5, 25);
            this.git6 = darken_default(this.git6, 25);
            this.git7 = darken_default(this.git7, 25);
          }
          this.gitInv0 = this.gitInv0 || invert_default(this.git0);
          this.gitInv1 = this.gitInv1 || invert_default(this.git1);
          this.gitInv2 = this.gitInv2 || invert_default(this.git2);
          this.gitInv3 = this.gitInv3 || invert_default(this.git3);
          this.gitInv4 = this.gitInv4 || invert_default(this.git4);
          this.gitInv5 = this.gitInv5 || invert_default(this.git5);
          this.gitInv6 = this.gitInv6 || invert_default(this.git6);
          this.gitInv7 = this.gitInv7 || invert_default(this.git7);
          this.gitBranchLabel0 = this.gitBranchLabel0 || invert_default(this.labelTextColor);
          this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor;
          this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor;
          this.gitBranchLabel3 = this.gitBranchLabel3 || invert_default(this.labelTextColor);
          this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor;
          this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor;
          this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor;
          this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor;
          this.tagLabelColor = this.tagLabelColor || this.primaryTextColor;
          this.tagLabelBackground = this.tagLabelBackground || this.primaryColor;
          this.tagLabelBorder = this.tagBorder || this.primaryBorderColor;
          this.tagLabelFontSize = this.tagLabelFontSize || "10px";
          this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor;
          this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor;
          this.commitLabelFontSize = this.commitLabelFontSize || "10px";
          this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || oldAttributeBackgroundColorOdd;
          this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || oldAttributeBackgroundColorEven;
        }
        calculate(overrides) {
          if (typeof overrides !== "object") {
            this.updateColors();
            return;
          }
          const keys3 = Object.keys(overrides);
          keys3.forEach((k2) => {
            this[k2] = overrides[k2];
          });
          this.updateColors();
          keys3.forEach((k2) => {
            this[k2] = overrides[k2];
          });
        }
      };
      getThemeVariables4 = /* @__PURE__ */ __name((userOverrides) => {
        const theme = new Theme4();
        theme.calculate(userOverrides);
        return theme;
      }, "getThemeVariables");
    }
  });

  // src/themes/theme-neutral.js
  var Theme5, getThemeVariables5;
  var init_theme_neutral = __esm({
    "src/themes/theme-neutral.js"() {
      "use strict";
      init_dist();
      init_theme_helpers();
      init_erDiagram_oldHardcodedValues();
      Theme5 = class {
        static {
          __name(this, "Theme");
        }
        constructor() {
          this.primaryColor = "#eee";
          this.contrast = "#707070";
          this.secondaryColor = lighten_default(this.contrast, 55);
          this.background = "#ffffff";
          this.tertiaryColor = adjust_default(this.primaryColor, { h: -160 });
          this.primaryBorderColor = mkBorder(this.primaryColor, this.darkMode);
          this.secondaryBorderColor = mkBorder(this.secondaryColor, this.darkMode);
          this.tertiaryBorderColor = mkBorder(this.tertiaryColor, this.darkMode);
          this.primaryTextColor = invert_default(this.primaryColor);
          this.secondaryTextColor = invert_default(this.secondaryColor);
          this.tertiaryTextColor = invert_default(this.tertiaryColor);
          this.lineColor = invert_default(this.background);
          this.textColor = invert_default(this.background);
          this.mainBkg = "#eee";
          this.secondBkg = "calculated";
          this.lineColor = "#666";
          this.border1 = "#999";
          this.border2 = "calculated";
          this.note = "#ffa";
          this.text = "#333";
          this.critical = "#d42";
          this.done = "#bbb";
          this.arrowheadColor = "#333333";
          this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
          this.fontSize = "16px";
          this.THEME_COLOR_LIMIT = 12;
          this.nodeBkg = "calculated";
          this.nodeBorder = "calculated";
          this.clusterBkg = "calculated";
          this.clusterBorder = "calculated";
          this.defaultLinkColor = "calculated";
          this.titleColor = "calculated";
          this.edgeLabelBackground = "white";
          this.actorBorder = "calculated";
          this.actorBkg = "calculated";
          this.actorTextColor = "calculated";
          this.actorLineColor = this.actorBorder;
          this.signalColor = "calculated";
          this.signalTextColor = "calculated";
          this.labelBoxBkgColor = "calculated";
          this.labelBoxBorderColor = "calculated";
          this.labelTextColor = "calculated";
          this.loopTextColor = "calculated";
          this.noteBorderColor = "calculated";
          this.noteBkgColor = "calculated";
          this.noteTextColor = "calculated";
          this.activationBorderColor = "#666";
          this.activationBkgColor = "#f4f4f4";
          this.sequenceNumberColor = "white";
          this.sectionBkgColor = "calculated";
          this.altSectionBkgColor = "white";
          this.sectionBkgColor2 = "calculated";
          this.excludeBkgColor = "#eeeeee";
          this.taskBorderColor = "calculated";
          this.taskBkgColor = "calculated";
          this.taskTextLightColor = "white";
          this.taskTextColor = "calculated";
          this.taskTextDarkColor = "calculated";
          this.taskTextOutsideColor = "calculated";
          this.taskTextClickableColor = "#003163";
          this.activeTaskBorderColor = "calculated";
          this.activeTaskBkgColor = "calculated";
          this.gridColor = "calculated";
          this.doneTaskBkgColor = "calculated";
          this.doneTaskBorderColor = "calculated";
          this.critBkgColor = "calculated";
          this.critBorderColor = "calculated";
          this.todayLineColor = "calculated";
          this.personBorder = this.primaryBorderColor;
          this.personBkg = this.mainBkg;
          this.archEdgeColor = "calculated";
          this.archEdgeArrowColor = "calculated";
          this.archEdgeWidth = "3";
          this.archGroupBorderColor = this.primaryBorderColor;
          this.archGroupBorderWidth = "2px";
          this.labelColor = "black";
          this.errorBkgColor = "#552222";
          this.errorTextColor = "#552222";
        }
        updateColors() {
          this.secondBkg = lighten_default(this.contrast, 55);
          this.border2 = this.contrast;
          this.actorBorder = lighten_default(this.border1, 23);
          this.actorBkg = this.mainBkg;
          this.actorTextColor = this.text;
          this.actorLineColor = this.actorBorder;
          this.signalColor = this.text;
          this.signalTextColor = this.text;
          this.labelBoxBkgColor = this.actorBkg;
          this.labelBoxBorderColor = this.actorBorder;
          this.labelTextColor = this.text;
          this.loopTextColor = this.text;
          this.noteBorderColor = "#999";
          this.noteBkgColor = "#666";
          this.noteTextColor = "#fff";
          this.cScale0 = this.cScale0 || "#555";
          this.cScale1 = this.cScale1 || "#F4F4F4";
          this.cScale2 = this.cScale2 || "#555";
          this.cScale3 = this.cScale3 || "#BBB";
          this.cScale4 = this.cScale4 || "#777";
          this.cScale5 = this.cScale5 || "#999";
          this.cScale6 = this.cScale6 || "#DDD";
          this.cScale7 = this.cScale7 || "#FFF";
          this.cScale8 = this.cScale8 || "#DDD";
          this.cScale9 = this.cScale9 || "#BBB";
          this.cScale10 = this.cScale10 || "#999";
          this.cScale11 = this.cScale11 || "#777";
          for (let i2 = 0; i2 < this.THEME_COLOR_LIMIT; i2++) {
            this["cScaleInv" + i2] = this["cScaleInv" + i2] || invert_default(this["cScale" + i2]);
          }
          for (let i2 = 0; i2 < this.THEME_COLOR_LIMIT; i2++) {
            if (this.darkMode) {
              this["cScalePeer" + i2] = this["cScalePeer" + i2] || lighten_default(this["cScale" + i2], 10);
            } else {
              this["cScalePeer" + i2] = this["cScalePeer" + i2] || darken_default(this["cScale" + i2], 10);
            }
          }
          this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor);
          this.cScaleLabel0 = this.cScaleLabel0 || this.cScale1;
          this.cScaleLabel2 = this.cScaleLabel2 || this.cScale1;
          for (let i2 = 0; i2 < this.THEME_COLOR_LIMIT; i2++) {
            this["cScaleLabel" + i2] = this["cScaleLabel" + i2] || this.scaleLabelColor;
          }
          for (let i2 = 0; i2 < 5; i2++) {
            this["surface" + i2] = this["surface" + i2] || adjust_default(this.mainBkg, { l: -(5 + i2 * 5) });
            this["surfacePeer" + i2] = this["surfacePeer" + i2] || adjust_default(this.mainBkg, { l: -(8 + i2 * 5) });
          }
          this.nodeBkg = this.mainBkg;
          this.nodeBorder = this.border1;
          this.clusterBkg = this.secondBkg;
          this.clusterBorder = this.border2;
          this.defaultLinkColor = this.lineColor;
          this.titleColor = this.text;
          this.sectionBkgColor = lighten_default(this.contrast, 30);
          this.sectionBkgColor2 = lighten_default(this.contrast, 30);
          this.taskBorderColor = darken_default(this.contrast, 10);
          this.taskBkgColor = this.contrast;
          this.taskTextColor = this.taskTextLightColor;
          this.taskTextDarkColor = this.text;
          this.taskTextOutsideColor = this.taskTextDarkColor;
          this.activeTaskBorderColor = this.taskBorderColor;
          this.activeTaskBkgColor = this.mainBkg;
          this.gridColor = lighten_default(this.border1, 30);
          this.doneTaskBkgColor = this.done;
          this.doneTaskBorderColor = this.lineColor;
          this.critBkgColor = this.critical;
          this.critBorderColor = darken_default(this.critBkgColor, 10);
          this.todayLineColor = this.critBkgColor;
          this.archEdgeColor = this.lineColor;
          this.archEdgeArrowColor = this.lineColor;
          this.transitionColor = this.transitionColor || "#000";
          this.transitionLabelColor = this.transitionLabelColor || this.textColor;
          this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
          this.stateBkg = this.stateBkg || this.mainBkg;
          this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
          this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
          this.altBackground = this.altBackground || "#f4f4f4";
          this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
          this.stateBorder = this.stateBorder || "#000";
          this.innerEndBackground = this.primaryBorderColor;
          this.specialStateColor = "#222";
          this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
          this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
          this.classText = this.primaryTextColor;
          this.fillType0 = this.primaryColor;
          this.fillType1 = this.secondaryColor;
          this.fillType2 = adjust_default(this.primaryColor, { h: 64 });
          this.fillType3 = adjust_default(this.secondaryColor, { h: 64 });
          this.fillType4 = adjust_default(this.primaryColor, { h: -64 });
          this.fillType5 = adjust_default(this.secondaryColor, { h: -64 });
          this.fillType6 = adjust_default(this.primaryColor, { h: 128 });
          this.fillType7 = adjust_default(this.secondaryColor, { h: 128 });
          for (let i2 = 0; i2 < this.THEME_COLOR_LIMIT; i2++) {
            this["pie" + i2] = this["cScale" + i2];
          }
          this.pie12 = this.pie0;
          this.pieTitleTextSize = this.pieTitleTextSize || "25px";
          this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
          this.pieSectionTextSize = this.pieSectionTextSize || "17px";
          this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
          this.pieLegendTextSize = this.pieLegendTextSize || "17px";
          this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
          this.pieStrokeColor = this.pieStrokeColor || "black";
          this.pieStrokeWidth = this.pieStrokeWidth || "2px";
          this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px";
          this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black";
          this.pieOpacity = this.pieOpacity || "0.7";
          this.quadrant1Fill = this.quadrant1Fill || this.primaryColor;
          this.quadrant2Fill = this.quadrant2Fill || adjust_default(this.primaryColor, { r: 5, g: 5, b: 5 });
          this.quadrant3Fill = this.quadrant3Fill || adjust_default(this.primaryColor, { r: 10, g: 10, b: 10 });
          this.quadrant4Fill = this.quadrant4Fill || adjust_default(this.primaryColor, { r: 15, g: 15, b: 15 });
          this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor;
          this.quadrant2TextFill = this.quadrant2TextFill || adjust_default(this.primaryTextColor, { r: -5, g: -5, b: -5 });
          this.quadrant3TextFill = this.quadrant3TextFill || adjust_default(this.primaryTextColor, { r: -10, g: -10, b: -10 });
          this.quadrant4TextFill = this.quadrant4TextFill || adjust_default(this.primaryTextColor, { r: -15, g: -15, b: -15 });
          this.quadrantPointFill = this.quadrantPointFill || is_dark_default(this.quadrant1Fill) ? lighten_default(this.quadrant1Fill) : darken_default(this.quadrant1Fill);
          this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor;
          this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor;
          this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor;
          this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor;
          this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor;
          this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor;
          this.xyChart = {
            backgroundColor: this.xyChart?.backgroundColor || this.background,
            titleColor: this.xyChart?.titleColor || this.primaryTextColor,
            xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
            xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
            xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
            xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
            yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
            yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
            yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
            yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
            plotColorPalette: this.xyChart?.plotColorPalette || "#EEE,#6BB8E4,#8ACB88,#C7ACD6,#E8DCC2,#FFB2A8,#FFF380,#7E8D91,#FFD8B1,#FAF3E0"
          };
          this.requirementBackground = this.requirementBackground || this.primaryColor;
          this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
          this.requirementBorderSize = this.requirementBorderSize || "1";
          this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
          this.relationColor = this.relationColor || this.lineColor;
          this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground;
          this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
          this.git0 = darken_default(this.pie1, 25) || this.primaryColor;
          this.git1 = this.pie2 || this.secondaryColor;
          this.git2 = this.pie3 || this.tertiaryColor;
          this.git3 = this.pie4 || adjust_default(this.primaryColor, { h: -30 });
          this.git4 = this.pie5 || adjust_default(this.primaryColor, { h: -60 });
          this.git5 = this.pie6 || adjust_default(this.primaryColor, { h: -90 });
          this.git6 = this.pie7 || adjust_default(this.primaryColor, { h: 60 });
          this.git7 = this.pie8 || adjust_default(this.primaryColor, { h: 120 });
          this.gitInv0 = this.gitInv0 || invert_default(this.git0);
          this.gitInv1 = this.gitInv1 || invert_default(this.git1);
          this.gitInv2 = this.gitInv2 || invert_default(this.git2);
          this.gitInv3 = this.gitInv3 || invert_default(this.git3);
          this.gitInv4 = this.gitInv4 || invert_default(this.git4);
          this.gitInv5 = this.gitInv5 || invert_default(this.git5);
          this.gitInv6 = this.gitInv6 || invert_default(this.git6);
          this.gitInv7 = this.gitInv7 || invert_default(this.git7);
          this.branchLabelColor = this.branchLabelColor || this.labelTextColor;
          this.gitBranchLabel0 = this.branchLabelColor;
          this.gitBranchLabel1 = "white";
          this.gitBranchLabel2 = this.branchLabelColor;
          this.gitBranchLabel3 = "white";
          this.gitBranchLabel4 = this.branchLabelColor;
          this.gitBranchLabel5 = this.branchLabelColor;
          this.gitBranchLabel6 = this.branchLabelColor;
          this.gitBranchLabel7 = this.branchLabelColor;
          this.tagLabelColor = this.tagLabelColor || this.primaryTextColor;
          this.tagLabelBackground = this.tagLabelBackground || this.primaryColor;
          this.tagLabelBorder = this.tagBorder || this.primaryBorderColor;
          this.tagLabelFontSize = this.tagLabelFontSize || "10px";
          this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor;
          this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor;
          this.commitLabelFontSize = this.commitLabelFontSize || "10px";
          this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || oldAttributeBackgroundColorOdd;
          this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || oldAttributeBackgroundColorEven;
        }
        calculate(overrides) {
          if (typeof overrides !== "object") {
            this.updateColors();
            return;
          }
          const keys3 = Object.keys(overrides);
          keys3.forEach((k2) => {
            this[k2] = overrides[k2];
          });
          this.updateColors();
          keys3.forEach((k2) => {
            this[k2] = overrides[k2];
          });
        }
      };
      getThemeVariables5 = /* @__PURE__ */ __name((userOverrides) => {
        const theme = new Theme5();
        theme.calculate(userOverrides);
        return theme;
      }, "getThemeVariables");
    }
  });

  // src/themes/index.js
  var themes_default;
  var init_themes = __esm({
    "src/themes/index.js"() {
      "use strict";
      init_theme_base();
      init_theme_dark();
      init_theme_default();
      init_theme_forest();
      init_theme_neutral();
      themes_default = {
        base: {
          getThemeVariables
        },
        dark: {
          getThemeVariables: getThemeVariables2
        },
        default: {
          getThemeVariables: getThemeVariables3
        },
        forest: {
          getThemeVariables: getThemeVariables4
        },
        neutral: {
          getThemeVariables: getThemeVariables5
        }
      };
    }
  });

  // src/schemas/config.schema.yaml?only-defaults=true
  var config_schema_default;
  var init_config_schema = __esm({
    "src/schemas/config.schema.yaml?only-defaults=true"() {
      "use strict";
      config_schema_default = {
        "flowchart": {
          "useMaxWidth": true,
          "titleTopMargin": 25,
          "subGraphTitleMargin": {
            "top": 0,
            "bottom": 0
          },
          "diagramPadding": 8,
          "htmlLabels": true,
          "nodeSpacing": 50,
          "rankSpacing": 50,
          "curve": "basis",
          "padding": 15,
          "defaultRenderer": "dagre-wrapper",
          "wrappingWidth": 200
        },
        "sequence": {
          "useMaxWidth": true,
          "hideUnusedParticipants": false,
          "activationWidth": 10,
          "diagramMarginX": 50,
          "diagramMarginY": 10,
          "actorMargin": 50,
          "width": 150,
          "height": 65,
          "boxMargin": 10,
          "boxTextMargin": 5,
          "noteMargin": 10,
          "messageMargin": 35,
          "messageAlign": "center",
          "mirrorActors": true,
          "forceMenus": false,
          "bottomMarginAdj": 1,
          "rightAngles": false,
          "showSequenceNumbers": false,
          "actorFontSize": 14,
          "actorFontFamily": '"Open Sans", sans-serif',
          "actorFontWeight": 400,
          "noteFontSize": 14,
          "noteFontFamily": '"trebuchet ms", verdana, arial, sans-serif',
          "noteFontWeight": 400,
          "noteAlign": "center",
          "messageFontSize": 16,
          "messageFontFamily": '"trebuchet ms", verdana, arial, sans-serif',
          "messageFontWeight": 400,
          "wrap": false,
          "wrapPadding": 10,
          "labelBoxWidth": 50,
          "labelBoxHeight": 20
        },
        "gantt": {
          "useMaxWidth": true,
          "titleTopMargin": 25,
          "barHeight": 20,
          "barGap": 4,
          "topPadding": 50,
          "rightPadding": 75,
          "leftPadding": 75,
          "gridLineStartPadding": 35,
          "fontSize": 11,
          "sectionFontSize": 11,
          "numberSectionStyles": 4,
          "axisFormat": "%Y-%m-%d",
          "topAxis": false,
          "displayMode": "",
          "weekday": "sunday"
        },
        "journey": {
          "useMaxWidth": true,
          "diagramMarginX": 50,
          "diagramMarginY": 10,
          "leftMargin": 150,
          "width": 150,
          "height": 50,
          "boxMargin": 10,
          "boxTextMargin": 5,
          "noteMargin": 10,
          "messageMargin": 35,
          "messageAlign": "center",
          "bottomMarginAdj": 1,
          "rightAngles": false,
          "taskFontSize": 14,
          "taskFontFamily": '"Open Sans", sans-serif',
          "taskMargin": 50,
          "activationWidth": 10,
          "textPlacement": "fo",
          "actorColours": [
            "#8FBC8F",
            "#7CFC00",
            "#00FFFF",
            "#20B2AA",
            "#B0E0E6",
            "#FFFFE0"
          ],
          "sectionFills": [
            "#191970",
            "#8B008B",
            "#4B0082",
            "#2F4F4F",
            "#800000",
            "#8B4513",
            "#00008B"
          ],
          "sectionColours": [
            "#fff"
          ]
        },
        "class": {
          "useMaxWidth": true,
          "titleTopMargin": 25,
          "arrowMarkerAbsolute": false,
          "dividerMargin": 10,
          "padding": 5,
          "textHeight": 10,
          "defaultRenderer": "dagre-wrapper",
          "htmlLabels": false,
          "hideEmptyMembersBox": false
        },
        "state": {
          "useMaxWidth": true,
          "titleTopMargin": 25,
          "dividerMargin": 10,
          "sizeUnit": 5,
          "padding": 8,
          "textHeight": 10,
          "titleShift": -15,
          "noteMargin": 10,
          "forkWidth": 70,
          "forkHeight": 7,
          "miniPadding": 2,
          "fontSizeFactor": 5.02,
          "fontSize": 24,
          "labelHeight": 16,
          "edgeLengthFactor": "20",
          "compositTitleSize": 35,
          "radius": 5,
          "defaultRenderer": "dagre-wrapper"
        },
        "er": {
          "useMaxWidth": true,
          "titleTopMargin": 25,
          "diagramPadding": 20,
          "layoutDirection": "TB",
          "minEntityWidth": 100,
          "minEntityHeight": 75,
          "entityPadding": 15,
          "stroke": "gray",
          "fill": "honeydew",
          "fontSize": 12
        },
        "pie": {
          "useMaxWidth": true,
          "textPosition": 0.75
        },
        "quadrantChart": {
          "useMaxWidth": true,
          "chartWidth": 500,
          "chartHeight": 500,
          "titleFontSize": 20,
          "titlePadding": 10,
          "quadrantPadding": 5,
          "xAxisLabelPadding": 5,
          "yAxisLabelPadding": 5,
          "xAxisLabelFontSize": 16,
          "yAxisLabelFontSize": 16,
          "quadrantLabelFontSize": 16,
          "quadrantTextTopPadding": 5,
          "pointTextPadding": 5,
          "pointLabelFontSize": 12,
          "pointRadius": 5,
          "xAxisPosition": "top",
          "yAxisPosition": "left",
          "quadrantInternalBorderStrokeWidth": 1,
          "quadrantExternalBorderStrokeWidth": 2
        },
        "xyChart": {
          "useMaxWidth": true,
          "width": 700,
          "height": 500,
          "titleFontSize": 20,
          "titlePadding": 10,
          "showTitle": true,
          "xAxis": {
            "$ref": "#/$defs/XYChartAxisConfig",
            "showLabel": true,
            "labelFontSize": 14,
            "labelPadding": 5,
            "showTitle": true,
            "titleFontSize": 16,
            "titlePadding": 5,
            "showTick": true,
            "tickLength": 5,
            "tickWidth": 2,
            "showAxisLine": true,
            "axisLineWidth": 2
          },
          "yAxis": {
            "$ref": "#/$defs/XYChartAxisConfig",
            "showLabel": true,
            "labelFontSize": 14,
            "labelPadding": 5,
            "showTitle": true,
            "titleFontSize": 16,
            "titlePadding": 5,
            "showTick": true,
            "tickLength": 5,
            "tickWidth": 2,
            "showAxisLine": true,
            "axisLineWidth": 2
          },
          "chartOrientation": "vertical",
          "plotReservedSpacePercent": 50
        },
        "requirement": {
          "useMaxWidth": true,
          "rect_fill": "#f9f9f9",
          "text_color": "#333",
          "rect_border_size": "0.5px",
          "rect_border_color": "#bbb",
          "rect_min_width": 200,
          "rect_min_height": 200,
          "fontSize": 14,
          "rect_padding": 10,
          "line_height": 20
        },
        "mindmap": {
          "useMaxWidth": true,
          "padding": 10,
          "maxNodeWidth": 200
        },
        "kanban": {
          "useMaxWidth": true,
          "padding": 8,
          "sectionWidth": 200,
          "ticketBaseUrl": ""
        },
        "timeline": {
          "useMaxWidth": true,
          "diagramMarginX": 50,
          "diagramMarginY": 10,
          "leftMargin": 150,
          "width": 150,
          "height": 50,
          "boxMargin": 10,
          "boxTextMargin": 5,
          "noteMargin": 10,
          "messageMargin": 35,
          "messageAlign": "center",
          "bottomMarginAdj": 1,
          "rightAngles": false,
          "taskFontSize": 14,
          "taskFontFamily": '"Open Sans", sans-serif',
          "taskMargin": 50,
          "activationWidth": 10,
          "textPlacement": "fo",
          "actorColours": [
            "#8FBC8F",
            "#7CFC00",
            "#00FFFF",
            "#20B2AA",
            "#B0E0E6",
            "#FFFFE0"
          ],
          "sectionFills": [
            "#191970",
            "#8B008B",
            "#4B0082",
            "#2F4F4F",
            "#800000",
            "#8B4513",
            "#00008B"
          ],
          "sectionColours": [
            "#fff"
          ],
          "disableMulticolor": false
        },
        "gitGraph": {
          "useMaxWidth": true,
          "titleTopMargin": 25,
          "diagramPadding": 8,
          "nodeLabel": {
            "width": 75,
            "height": 100,
            "x": -25,
            "y": 0
          },
          "mainBranchName": "main",
          "mainBranchOrder": 0,
          "showCommitLabel": true,
          "showBranches": true,
          "rotateCommitLabel": true,
          "parallelCommits": false,
          "arrowMarkerAbsolute": false
        },
        "c4": {
          "useMaxWidth": true,
          "diagramMarginX": 50,
          "diagramMarginY": 10,
          "c4ShapeMargin": 50,
          "c4ShapePadding": 20,
          "width": 216,
          "height": 60,
          "boxMargin": 10,
          "c4ShapeInRow": 4,
          "nextLinePaddingX": 0,
          "c4BoundaryInRow": 2,
          "personFontSize": 14,
          "personFontFamily": '"Open Sans", sans-serif',
          "personFontWeight": "normal",
          "external_personFontSize": 14,
          "external_personFontFamily": '"Open Sans", sans-serif',
          "external_personFontWeight": "normal",
          "systemFontSize": 14,
          "systemFontFamily": '"Open Sans", sans-serif',
          "systemFontWeight": "normal",
          "external_systemFontSize": 14,
          "external_systemFontFamily": '"Open Sans", sans-serif',
          "external_systemFontWeight": "normal",
          "system_dbFontSize": 14,
          "system_dbFontFamily": '"Open Sans", sans-serif',
          "system_dbFontWeight": "normal",
          "external_system_dbFontSize": 14,
          "external_system_dbFontFamily": '"Open Sans", sans-serif',
          "external_system_dbFontWeight": "normal",
          "system_queueFontSize": 14,
          "system_queueFontFamily": '"Open Sans", sans-serif',
          "system_queueFontWeight": "normal",
          "external_system_queueFontSize": 14,
          "external_system_queueFontFamily": '"Open Sans", sans-serif',
          "external_system_queueFontWeight": "normal",
          "boundaryFontSize": 14,
          "boundaryFontFamily": '"Open Sans", sans-serif',
          "boundaryFontWeight": "normal",
          "messageFontSize": 12,
          "messageFontFamily": '"Open Sans", sans-serif',
          "messageFontWeight": "normal",
          "containerFontSize": 14,
          "containerFontFamily": '"Open Sans", sans-serif',
          "containerFontWeight": "normal",
          "external_containerFontSize": 14,
          "external_containerFontFamily": '"Open Sans", sans-serif',
          "external_containerFontWeight": "normal",
          "container_dbFontSize": 14,
          "container_dbFontFamily": '"Open Sans", sans-serif',
          "container_dbFontWeight": "normal",
          "external_container_dbFontSize": 14,
          "external_container_dbFontFamily": '"Open Sans", sans-serif',
          "external_container_dbFontWeight": "normal",
          "container_queueFontSize": 14,
          "container_queueFontFamily": '"Open Sans", sans-serif',
          "container_queueFontWeight": "normal",
          "external_container_queueFontSize": 14,
          "external_container_queueFontFamily": '"Open Sans", sans-serif',
          "external_container_queueFontWeight": "normal",
          "componentFontSize": 14,
          "componentFontFamily": '"Open Sans", sans-serif',
          "componentFontWeight": "normal",
          "external_componentFontSize": 14,
          "external_componentFontFamily": '"Open Sans", sans-serif',
          "external_componentFontWeight": "normal",
          "component_dbFontSize": 14,
          "component_dbFontFamily": '"Open Sans", sans-serif',
          "component_dbFontWeight": "normal",
          "external_component_dbFontSize": 14,
          "external_component_dbFontFamily": '"Open Sans", sans-serif',
          "external_component_dbFontWeight": "normal",
          "component_queueFontSize": 14,
          "component_queueFontFamily": '"Open Sans", sans-serif',
          "component_queueFontWeight": "normal",
          "external_component_queueFontSize": 14,
          "external_component_queueFontFamily": '"Open Sans", sans-serif',
          "external_component_queueFontWeight": "normal",
          "wrap": true,
          "wrapPadding": 10,
          "person_bg_color": "#08427B",
          "person_border_color": "#073B6F",
          "external_person_bg_color": "#686868",
          "external_person_border_color": "#8A8A8A",
          "system_bg_color": "#1168BD",
          "system_border_color": "#3C7FC0",
          "system_db_bg_color": "#1168BD",
          "system_db_border_color": "#3C7FC0",
          "system_queue_bg_color": "#1168BD",
          "system_queue_border_color": "#3C7FC0",
          "external_system_bg_color": "#999999",
          "external_system_border_color": "#8A8A8A",
          "external_system_db_bg_color": "#999999",
          "external_system_db_border_color": "#8A8A8A",
          "external_system_queue_bg_color": "#999999",
          "external_system_queue_border_color": "#8A8A8A",
          "container_bg_color": "#438DD5",
          "container_border_color": "#3C7FC0",
          "container_db_bg_color": "#438DD5",
          "container_db_border_color": "#3C7FC0",
          "container_queue_bg_color": "#438DD5",
          "container_queue_border_color": "#3C7FC0",
          "external_container_bg_color": "#B3B3B3",
          "external_container_border_color": "#A6A6A6",
          "external_container_db_bg_color": "#B3B3B3",
          "external_container_db_border_color": "#A6A6A6",
          "external_container_queue_bg_color": "#B3B3B3",
          "external_container_queue_border_color": "#A6A6A6",
          "component_bg_color": "#85BBF0",
          "component_border_color": "#78A8D8",
          "component_db_bg_color": "#85BBF0",
          "component_db_border_color": "#78A8D8",
          "component_queue_bg_color": "#85BBF0",
          "component_queue_border_color": "#78A8D8",
          "external_component_bg_color": "#CCCCCC",
          "external_component_border_color": "#BFBFBF",
          "external_component_db_bg_color": "#CCCCCC",
          "external_component_db_border_color": "#BFBFBF",
          "external_component_queue_bg_color": "#CCCCCC",
          "external_component_queue_border_color": "#BFBFBF"
        },
        "sankey": {
          "useMaxWidth": true,
          "width": 600,
          "height": 400,
          "linkColor": "gradient",
          "nodeAlignment": "justify",
          "showValues": true,
          "prefix": "",
          "suffix": ""
        },
        "block": {
          "useMaxWidth": true,
          "padding": 8
        },
        "packet": {
          "useMaxWidth": true,
          "rowHeight": 32,
          "bitWidth": 32,
          "bitsPerRow": 32,
          "showBits": true,
          "paddingX": 5,
          "paddingY": 5
        },
        "architecture": {
          "useMaxWidth": true,
          "padding": 40,
          "iconSize": 80,
          "fontSize": 16
        },
        "theme": "default",
        "look": "classic",
        "handDrawnSeed": 0,
        "layout": "dagre",
        "maxTextSize": 5e4,
        "maxEdges": 500,
        "darkMode": false,
        "fontFamily": '"trebuchet ms", verdana, arial, sans-serif;',
        "logLevel": 5,
        "securityLevel": "strict",
        "startOnLoad": true,
        "arrowMarkerAbsolute": false,
        "secure": [
          "secure",
          "securityLevel",
          "startOnLoad",
          "maxTextSize",
          "suppressErrorRendering",
          "maxEdges"
        ],
        "legacyMathML": false,
        "forceLegacyMathML": false,
        "deterministicIds": false,
        "fontSize": 16,
        "markdownAutoWrap": true,
        "suppressErrorRendering": false
      };
    }
  });

  // src/defaultConfig.ts
  var config, keyify, configKeys, defaultConfig_default;
  var init_defaultConfig = __esm({
    "src/defaultConfig.ts"() {
      "use strict";
      init_themes();
      init_config_schema();
      config = {
        ...config_schema_default,
        // Set, even though they're `undefined` so that `configKeys` finds these keys
        // TODO: Should we replace these with `null` so that they can go in the JSON Schema?
        deterministicIDSeed: void 0,
        elk: {
          // mergeEdges is needed here to be considered
          mergeEdges: false,
          nodePlacementStrategy: "BRANDES_KOEPF"
        },
        themeCSS: void 0,
        // add non-JSON default config values
        themeVariables: themes_default.default.getThemeVariables(),
        sequence: {
          ...config_schema_default.sequence,
          messageFont: /* @__PURE__ */ __name(function() {
            return {
              fontFamily: this.messageFontFamily,
              fontSize: this.messageFontSize,
              fontWeight: this.messageFontWeight
            };
          }, "messageFont"),
          noteFont: /* @__PURE__ */ __name(function() {
            return {
              fontFamily: this.noteFontFamily,
              fontSize: this.noteFontSize,
              fontWeight: this.noteFontWeight
            };
          }, "noteFont"),
          actorFont: /* @__PURE__ */ __name(function() {
            return {
              fontFamily: this.actorFontFamily,
              fontSize: this.actorFontSize,
              fontWeight: this.actorFontWeight
            };
          }, "actorFont")
        },
        class: {
          hideEmptyMembersBox: false
        },
        gantt: {
          ...config_schema_default.gantt,
          tickInterval: void 0,
          useWidth: void 0
          // can probably be removed since `configKeys` already includes this
        },
        c4: {
          ...config_schema_default.c4,
          useWidth: void 0,
          personFont: /* @__PURE__ */ __name(function() {
            return {
              fontFamily: this.personFontFamily,
              fontSize: this.personFontSize,
              fontWeight: this.personFontWeight
            };
          }, "personFont"),
          external_personFont: /* @__PURE__ */ __name(function() {
            return {
              fontFamily: this.external_personFontFamily,
              fontSize: this.external_personFontSize,
              fontWeight: this.external_personFontWeight
            };
          }, "external_personFont"),
          systemFont: /* @__PURE__ */ __name(function() {
            return {
              fontFamily: this.systemFontFamily,
              fontSize: this.systemFontSize,
              fontWeight: this.systemFontWeight
            };
          }, "systemFont"),
          external_systemFont: /* @__PURE__ */ __name(function() {
            return {
              fontFamily: this.external_systemFontFamily,
              fontSize: this.external_systemFontSize,
              fontWeight: this.external_systemFontWeight
            };
          }, "external_systemFont"),
          system_dbFont: /* @__PURE__ */ __name(function() {
            return {
              fontFamily: this.system_dbFontFamily,
              fontSize: this.system_dbFontSize,
              fontWeight: this.system_dbFontWeight
            };
          }, "system_dbFont"),
          external_system_dbFont: /* @__PURE__ */ __name(function() {
            return {
              fontFamily: this.external_system_dbFontFamily,
              fontSize: this.external_system_dbFontSize,
              fontWeight: this.external_system_dbFontWeight
            };
          }, "external_system_dbFont"),
          system_queueFont: /* @__PURE__ */ __name(function() {
            return {
              fontFamily: this.system_queueFontFamily,
              fontSize: this.system_queueFontSize,
              fontWeight: this.system_queueFontWeight
            };
          }, "system_queueFont"),
          external_system_queueFont: /* @__PURE__ */ __name(function() {
            return {
              fontFamily: this.external_system_queueFontFamily,
              fontSize: this.external_system_queueFontSize,
              fontWeight: this.external_system_queueFontWeight
            };
          }, "external_system_queueFont"),
          containerFont: /* @__PURE__ */ __name(function() {
            return {
              fontFamily: this.containerFontFamily,
              fontSize: this.containerFontSize,
              fontWeight: this.containerFontWeight
            };
          }, "containerFont"),
          external_containerFont: /* @__PURE__ */ __name(function() {
            return {
              fontFamily: this.external_containerFontFamily,
              fontSize: this.external_containerFontSize,
              fontWeight: this.external_containerFontWeight
            };
          }, "external_containerFont"),
          container_dbFont: /* @__PURE__ */ __name(function() {
            return {
              fontFamily: this.container_dbFontFamily,
              fontSize: this.container_dbFontSize,
              fontWeight: this.container_dbFontWeight
            };
          }, "container_dbFont"),
          external_container_dbFont: /* @__PURE__ */ __name(function() {
            return {
              fontFamily: this.external_container_dbFontFamily,
              fontSize: this.external_container_dbFontSize,
              fontWeight: this.external_container_dbFontWeight
            };
          }, "external_container_dbFont"),
          container_queueFont: /* @__PURE__ */ __name(function() {
            return {
              fontFamily: this.container_queueFontFamily,
              fontSize: this.container_queueFontSize,
              fontWeight: this.container_queueFontWeight
            };
          }, "container_queueFont"),
          external_container_queueFont: /* @__PURE__ */ __name(function() {
            return {
              fontFamily: this.external_container_queueFontFamily,
              fontSize: this.external_container_queueFontSize,
              fontWeight: this.external_container_queueFontWeight
            };
          }, "external_container_queueFont"),
          componentFont: /* @__PURE__ */ __name(function() {
            return {
              fontFamily: this.componentFontFamily,
              fontSize: this.componentFontSize,
              fontWeight: this.componentFontWeight
            };
          }, "componentFont"),
          external_componentFont: /* @__PURE__ */ __name(function() {
            return {
              fontFamily: this.external_componentFontFamily,
              fontSize: this.external_componentFontSize,
              fontWeight: this.external_componentFontWeight
            };
          }, "external_componentFont"),
          component_dbFont: /* @__PURE__ */ __name(function() {
            return {
              fontFamily: this.component_dbFontFamily,
              fontSize: this.component_dbFontSize,
              fontWeight: this.component_dbFontWeight
            };
          }, "component_dbFont"),
          external_component_dbFont: /* @__PURE__ */ __name(function() {
            return {
              fontFamily: this.external_component_dbFontFamily,
              fontSize: this.external_component_dbFontSize,
              fontWeight: this.external_component_dbFontWeight
            };
          }, "external_component_dbFont"),
          component_queueFont: /* @__PURE__ */ __name(function() {
            return {
              fontFamily: this.component_queueFontFamily,
              fontSize: this.component_queueFontSize,
              fontWeight: this.component_queueFontWeight
            };
          }, "component_queueFont"),
          external_component_queueFont: /* @__PURE__ */ __name(function() {
            return {
              fontFamily: this.external_component_queueFontFamily,
              fontSize: this.external_component_queueFontSize,
              fontWeight: this.external_component_queueFontWeight
            };
          }, "external_component_queueFont"),
          boundaryFont: /* @__PURE__ */ __name(function() {
            return {
              fontFamily: this.boundaryFontFamily,
              fontSize: this.boundaryFontSize,
              fontWeight: this.boundaryFontWeight
            };
          }, "boundaryFont"),
          messageFont: /* @__PURE__ */ __name(function() {
            return {
              fontFamily: this.messageFontFamily,
              fontSize: this.messageFontSize,
              fontWeight: this.messageFontWeight
            };
          }, "messageFont")
        },
        pie: {
          ...config_schema_default.pie,
          useWidth: 984
        },
        xyChart: {
          ...config_schema_default.xyChart,
          useWidth: void 0
        },
        requirement: {
          ...config_schema_default.requirement,
          useWidth: void 0
        },
        packet: {
          ...config_schema_default.packet
        }
      };
      keyify = /* @__PURE__ */ __name((obj, prefix = "") => Object.keys(obj).reduce((res, el) => {
        if (Array.isArray(obj[el])) {
          return res;
        } else if (typeof obj[el] === "object" && obj[el] !== null) {
          return [...res, prefix + el, ...keyify(obj[el], "")];
        }
        return [...res, prefix + el];
      }, []), "keyify");
      configKeys = new Set(keyify(config, ""));
      defaultConfig_default = config;
    }
  });

  // src/utils/sanitizeDirective.ts
  var sanitizeDirective, sanitizeCss;
  var init_sanitizeDirective = __esm({
    "src/utils/sanitizeDirective.ts"() {
      "use strict";
      init_defaultConfig();
      init_logger();
      sanitizeDirective = /* @__PURE__ */ __name((args) => {
        log.debug("sanitizeDirective called with", args);
        if (typeof args !== "object" || args == null) {
          return;
        }
        if (Array.isArray(args)) {
          args.forEach((arg) => sanitizeDirective(arg));
          return;
        }
        for (const key of Object.keys(args)) {
          log.debug("Checking key", key);
          if (key.startsWith("__") || key.includes("proto") || key.includes("constr") || !configKeys.has(key) || args[key] == null) {
            log.debug("sanitize deleting key: ", key);
            delete args[key];
            continue;
          }
          if (typeof args[key] === "object") {
            log.debug("sanitizing object", key);
            sanitizeDirective(args[key]);
            continue;
          }
          const cssMatchers = ["themeCSS", "fontFamily", "altFontFamily"];
          for (const cssKey of cssMatchers) {
            if (key.includes(cssKey)) {
              log.debug("sanitizing css option", key);
              args[key] = sanitizeCss(args[key]);
            }
          }
        }
        if (args.themeVariables) {
          for (const k2 of Object.keys(args.themeVariables)) {
            const val = args.themeVariables[k2];
            if (val?.match && !val.match(/^[\d "#%(),.;A-Za-z]+$/)) {
              args.themeVariables[k2] = "";
            }
          }
        }
        log.debug("After sanitization", args);
      }, "sanitizeDirective");
      sanitizeCss = /* @__PURE__ */ __name((str2) => {
        let startCnt = 0;
        let endCnt = 0;
        for (const element3 of str2) {
          if (startCnt < endCnt) {
            return "{ /* ERROR: Unbalanced CSS */ }";
          }
          if (element3 === "{") {
            startCnt++;
          } else if (element3 === "}") {
            endCnt++;
          }
        }
        if (startCnt !== endCnt) {
          return "{ /* ERROR: Unbalanced CSS */ }";
        }
        return str2;
      }, "sanitizeCss");
    }
  });

  // src/config.ts
  var defaultConfig, siteConfig, configFromInitialize, directives, currentConfig, updateCurrentConfig, setSiteConfig, saveConfigFromInitialize, updateSiteConfig, getSiteConfig, setConfig, getConfig, sanitize, addDirective, reset, ConfigWarning, issuedWarnings, issueWarning, checkConfig;
  var init_config = __esm({
    "src/config.ts"() {
      "use strict";
      init_assignWithDepth();
      init_logger();
      init_themes();
      init_defaultConfig();
      init_sanitizeDirective();
      defaultConfig = Object.freeze(defaultConfig_default);
      siteConfig = assignWithDepth_default({}, defaultConfig);
      directives = [];
      currentConfig = assignWithDepth_default({}, defaultConfig);
      updateCurrentConfig = /* @__PURE__ */ __name((siteCfg, _directives) => {
        let cfg = assignWithDepth_default({}, siteCfg);
        let sumOfDirectives = {};
        for (const d2 of _directives) {
          sanitize(d2);
          sumOfDirectives = assignWithDepth_default(sumOfDirectives, d2);
        }
        cfg = assignWithDepth_default(cfg, sumOfDirectives);
        if (sumOfDirectives.theme && sumOfDirectives.theme in themes_default) {
          const tmpConfigFromInitialize = assignWithDepth_default({}, configFromInitialize);
          const themeVariables = assignWithDepth_default(
            tmpConfigFromInitialize.themeVariables || {},
            sumOfDirectives.themeVariables
          );
          if (cfg.theme && cfg.theme in themes_default) {
            cfg.themeVariables = themes_default[cfg.theme].getThemeVariables(themeVariables);
          }
        }
        currentConfig = cfg;
        checkConfig(currentConfig);
        return currentConfig;
      }, "updateCurrentConfig");
      setSiteConfig = /* @__PURE__ */ __name((conf7) => {
        siteConfig = assignWithDepth_default({}, defaultConfig);
        siteConfig = assignWithDepth_default(siteConfig, conf7);
        if (conf7.theme && themes_default[conf7.theme]) {
          siteConfig.themeVariables = themes_default[conf7.theme].getThemeVariables(conf7.themeVariables);
        }
        updateCurrentConfig(siteConfig, directives);
        return siteConfig;
      }, "setSiteConfig");
      saveConfigFromInitialize = /* @__PURE__ */ __name((conf7) => {
        configFromInitialize = assignWithDepth_default({}, conf7);
      }, "saveConfigFromInitialize");
      updateSiteConfig = /* @__PURE__ */ __name((conf7) => {
        siteConfig = assignWithDepth_default(siteConfig, conf7);
        updateCurrentConfig(siteConfig, directives);
        return siteConfig;
      }, "updateSiteConfig");
      getSiteConfig = /* @__PURE__ */ __name(() => {
        return assignWithDepth_default({}, siteConfig);
      }, "getSiteConfig");
      setConfig = /* @__PURE__ */ __name((conf7) => {
        checkConfig(conf7);
        assignWithDepth_default(currentConfig, conf7);
        return getConfig();
      }, "setConfig");
      getConfig = /* @__PURE__ */ __name(() => {
        return assignWithDepth_default({}, currentConfig);
      }, "getConfig");
      sanitize = /* @__PURE__ */ __name((options3) => {
        if (!options3) {
          return;
        }
        ["secure", ...siteConfig.secure ?? []].forEach((key) => {
          if (Object.hasOwn(options3, key)) {
            log.debug(`Denied attempt to modify a secure key ${key}`, options3[key]);
            delete options3[key];
          }
        });
        Object.keys(options3).forEach((key) => {
          if (key.startsWith("__")) {
            delete options3[key];
          }
        });
        Object.keys(options3).forEach((key) => {
          if (typeof options3[key] === "string" && (options3[key].includes("<") || options3[key].includes(">") || options3[key].includes("url(data:"))) {
            delete options3[key];
          }
          if (typeof options3[key] === "object") {
            sanitize(options3[key]);
          }
        });
      }, "sanitize");
      addDirective = /* @__PURE__ */ __name((directive) => {
        sanitizeDirective(directive);
        if (directive.fontFamily && !directive.themeVariables?.fontFamily) {
          directive.themeVariables = {
            ...directive.themeVariables,
            fontFamily: directive.fontFamily
          };
        }
        directives.push(directive);
        updateCurrentConfig(siteConfig, directives);
      }, "addDirective");
      reset = /* @__PURE__ */ __name((config6 = siteConfig) => {
        directives = [];
        updateCurrentConfig(config6, directives);
      }, "reset");
      ConfigWarning = {
        LAZY_LOAD_DEPRECATED: "The configuration options lazyLoadedDiagrams and loadExternalDiagramsAtStartup are deprecated. Please use registerExternalDiagrams instead."
      };
      issuedWarnings = {};
      issueWarning = /* @__PURE__ */ __name((warning) => {
        if (issuedWarnings[warning]) {
          return;
        }
        log.warn(ConfigWarning[warning]);
        issuedWarnings[warning] = true;
      }, "issueWarning");
      checkConfig = /* @__PURE__ */ __name((config6) => {
        if (!config6) {
          return;
        }
        if (config6.lazyLoadedDiagrams || config6.loadExternalDiagramsAtStartup) {
          issueWarning("LAZY_LOAD_DEPRECATED");
        }
      }, "checkConfig");
    }
  });

  // ../../node_modules/.pnpm/dompurify@3.2.1/node_modules/dompurify/dist/purify.es.mjs
  function unapply(func) {
    return function(thisArg) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return apply(func, thisArg, args);
    };
  }
  function unconstruct(func) {
    return function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return construct(func, args);
    };
  }
  function addToSet(set6, array4) {
    let transformCaseFunc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
    if (setPrototypeOf) {
      setPrototypeOf(set6, null);
    }
    let l2 = array4.length;
    while (l2--) {
      let element3 = array4[l2];
      if (typeof element3 === "string") {
        const lcElement = transformCaseFunc(element3);
        if (lcElement !== element3) {
          if (!isFrozen(array4)) {
            array4[l2] = lcElement;
          }
          element3 = lcElement;
        }
      }
      set6[element3] = true;
    }
    return set6;
  }
  function cleanArray(array4) {
    for (let index = 0; index < array4.length; index++) {
      const isPropertyExist = objectHasOwnProperty(array4, index);
      if (!isPropertyExist) {
        array4[index] = null;
      }
    }
    return array4;
  }
  function clone(object3) {
    const newObject = create(null);
    for (const [property2, value2] of entries(object3)) {
      const isPropertyExist = objectHasOwnProperty(object3, property2);
      if (isPropertyExist) {
        if (Array.isArray(value2)) {
          newObject[property2] = cleanArray(value2);
        } else if (value2 && typeof value2 === "object" && value2.constructor === Object) {
          newObject[property2] = clone(value2);
        } else {
          newObject[property2] = value2;
        }
      }
    }
    return newObject;
  }
  function lookupGetter(object3, prop) {
    while (object3 !== null) {
      const desc = getOwnPropertyDescriptor(object3, prop);
      if (desc) {
        if (desc.get) {
          return unapply(desc.get);
        }
        if (typeof desc.value === "function") {
          return unapply(desc.value);
        }
      }
      object3 = getPrototypeOf(object3);
    }
    function fallbackValue() {
      return null;
    }
    __name(fallbackValue, "fallbackValue");
    return fallbackValue;
  }
  function createDOMPurify() {
    let window3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
    const DOMPurify = /* @__PURE__ */ __name((root4) => createDOMPurify(root4), "DOMPurify");
    DOMPurify.version = "3.2.1";
    DOMPurify.removed = [];
    if (!window3 || !window3.document || window3.document.nodeType !== NODE_TYPE.document) {
      DOMPurify.isSupported = false;
      return DOMPurify;
    }
    let {
      document: document2
    } = window3;
    const originalDocument = document2;
    const currentScript = originalDocument.currentScript;
    const {
      DocumentFragment: DocumentFragment2,
      HTMLTemplateElement,
      Node,
      Element: Element4,
      NodeFilter,
      NamedNodeMap = window3.NamedNodeMap || window3.MozNamedAttrMap,
      HTMLFormElement,
      DOMParser,
      trustedTypes
    } = window3;
    const ElementPrototype = Element4.prototype;
    const cloneNode = lookupGetter(ElementPrototype, "cloneNode");
    const remove3 = lookupGetter(ElementPrototype, "remove");
    const getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
    const getChildNodes = lookupGetter(ElementPrototype, "childNodes");
    const getParentNode = lookupGetter(ElementPrototype, "parentNode");
    if (typeof HTMLTemplateElement === "function") {
      const template = document2.createElement("template");
      if (template.content && template.content.ownerDocument) {
        document2 = template.content.ownerDocument;
      }
    }
    let trustedTypesPolicy;
    let emptyHTML = "";
    const {
      implementation,
      createNodeIterator,
      createDocumentFragment,
      getElementsByTagName
    } = document2;
    const {
      importNode
    } = originalDocument;
    let hooks = {};
    DOMPurify.isSupported = typeof entries === "function" && typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== void 0;
    const {
      MUSTACHE_EXPR: MUSTACHE_EXPR2,
      ERB_EXPR: ERB_EXPR2,
      TMPLIT_EXPR: TMPLIT_EXPR2,
      DATA_ATTR: DATA_ATTR2,
      ARIA_ATTR: ARIA_ATTR2,
      IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA2,
      ATTR_WHITESPACE: ATTR_WHITESPACE2,
      CUSTOM_ELEMENT: CUSTOM_ELEMENT2
    } = EXPRESSIONS;
    let {
      IS_ALLOWED_URI: IS_ALLOWED_URI$1
    } = EXPRESSIONS;
    let ALLOWED_TAGS = null;
    const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
    let ALLOWED_ATTR = null;
    const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
    let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
      tagNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      attributeNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: false
      }
    }));
    let FORBID_TAGS = null;
    let FORBID_ATTR = null;
    let ALLOW_ARIA_ATTR = true;
    let ALLOW_DATA_ATTR = true;
    let ALLOW_UNKNOWN_PROTOCOLS = false;
    let ALLOW_SELF_CLOSE_IN_ATTR = true;
    let SAFE_FOR_TEMPLATES = false;
    let SAFE_FOR_XML = true;
    let WHOLE_DOCUMENT = false;
    let SET_CONFIG = false;
    let FORCE_BODY = false;
    let RETURN_DOM = false;
    let RETURN_DOM_FRAGMENT = false;
    let RETURN_TRUSTED_TYPE = false;
    let SANITIZE_DOM = true;
    let SANITIZE_NAMED_PROPS = false;
    const SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
    let KEEP_CONTENT = true;
    let IN_PLACE = false;
    let USE_PROFILES = {};
    let FORBID_CONTENTS = null;
    const DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
    let DATA_URI_TAGS = null;
    const DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
    let URI_SAFE_ATTRIBUTES = null;
    const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
    const MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
    const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
    const HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
    let NAMESPACE = HTML_NAMESPACE;
    let IS_EMPTY_INPUT = false;
    let ALLOWED_NAMESPACES = null;
    const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
    let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
    let HTML_INTEGRATION_POINTS = addToSet({}, ["annotation-xml"]);
    const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
    let PARSER_MEDIA_TYPE = null;
    const SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
    const DEFAULT_PARSER_MEDIA_TYPE = "text/html";
    let transformCaseFunc = null;
    let CONFIG = null;
    const formElement = document2.createElement("form");
    const isRegexOrFunction = /* @__PURE__ */ __name(function isRegexOrFunction2(testValue) {
      return testValue instanceof RegExp || testValue instanceof Function;
    }, "isRegexOrFunction");
    const _parseConfig = /* @__PURE__ */ __name(function _parseConfig2() {
      let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (CONFIG && CONFIG === cfg) {
        return;
      }
      if (!cfg || typeof cfg !== "object") {
        cfg = {};
      }
      cfg = clone(cfg);
      PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
      transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
      ALLOWED_TAGS = objectHasOwnProperty(cfg, "ALLOWED_TAGS") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR = objectHasOwnProperty(cfg, "ALLOWED_ATTR") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
      ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, "ALLOWED_NAMESPACES") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
      URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, "ADD_URI_SAFE_ATTR") ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = objectHasOwnProperty(cfg, "ADD_DATA_URI_TAGS") ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
      FORBID_CONTENTS = objectHasOwnProperty(cfg, "FORBID_CONTENTS") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
      FORBID_TAGS = objectHasOwnProperty(cfg, "FORBID_TAGS") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
      FORBID_ATTR = objectHasOwnProperty(cfg, "FORBID_ATTR") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
      USE_PROFILES = objectHasOwnProperty(cfg, "USE_PROFILES") ? cfg.USE_PROFILES : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
      ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
      SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false;
      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
      RETURN_DOM = cfg.RETURN_DOM || false;
      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
      FORCE_BODY = cfg.FORCE_BODY || false;
      SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
      SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
      KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
      IN_PLACE = cfg.IN_PLACE || false;
      IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
      MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
      HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
      CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
      }
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
      }
      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
      }
      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }
      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }
      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, text);
        ALLOWED_ATTR = [];
        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html$1);
          addToSet(ALLOWED_ATTR, html);
        }
        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg$1);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl$1);
          addToSet(ALLOWED_ATTR, mathMl);
          addToSet(ALLOWED_ATTR, xml);
        }
      }
      if (cfg.ADD_TAGS) {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone(ALLOWED_TAGS);
        }
        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
      }
      if (cfg.ADD_ATTR) {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone(ALLOWED_ATTR);
        }
        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
      }
      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
      }
      if (cfg.FORBID_CONTENTS) {
        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
          FORBID_CONTENTS = clone(FORBID_CONTENTS);
        }
        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
      }
      if (KEEP_CONTENT) {
        ALLOWED_TAGS["#text"] = true;
      }
      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
      }
      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ["tbody"]);
        delete FORBID_TAGS.tbody;
      }
      if (cfg.TRUSTED_TYPES_POLICY) {
        if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== "function") {
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        }
        if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== "function") {
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        }
        trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
        emptyHTML = trustedTypesPolicy.createHTML("");
      } else {
        if (trustedTypesPolicy === void 0) {
          trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
        }
        if (trustedTypesPolicy !== null && typeof emptyHTML === "string") {
          emptyHTML = trustedTypesPolicy.createHTML("");
        }
      }
      if (freeze) {
        freeze(cfg);
      }
      CONFIG = cfg;
    }, "_parseConfig");
    const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
    const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
    const _checkValidNamespace = /* @__PURE__ */ __name(function _checkValidNamespace2(element3) {
      let parent4 = getParentNode(element3);
      if (!parent4 || !parent4.tagName) {
        parent4 = {
          namespaceURI: NAMESPACE,
          tagName: "template"
        };
      }
      const tagName = stringToLowerCase(element3.tagName);
      const parentTagName = stringToLowerCase(parent4.tagName);
      if (!ALLOWED_NAMESPACES[element3.namespaceURI]) {
        return false;
      }
      if (element3.namespaceURI === SVG_NAMESPACE) {
        if (parent4.namespaceURI === HTML_NAMESPACE) {
          return tagName === "svg";
        }
        if (parent4.namespaceURI === MATHML_NAMESPACE) {
          return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
        }
        return Boolean(ALL_SVG_TAGS[tagName]);
      }
      if (element3.namespaceURI === MATHML_NAMESPACE) {
        if (parent4.namespaceURI === HTML_NAMESPACE) {
          return tagName === "math";
        }
        if (parent4.namespaceURI === SVG_NAMESPACE) {
          return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
        }
        return Boolean(ALL_MATHML_TAGS[tagName]);
      }
      if (element3.namespaceURI === HTML_NAMESPACE) {
        if (parent4.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        if (parent4.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
      }
      if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element3.namespaceURI]) {
        return true;
      }
      return false;
    }, "_checkValidNamespace");
    const _forceRemove = /* @__PURE__ */ __name(function _forceRemove2(node2) {
      arrayPush(DOMPurify.removed, {
        element: node2
      });
      try {
        getParentNode(node2).removeChild(node2);
      } catch (_2) {
        remove3(node2);
      }
    }, "_forceRemove");
    const _removeAttribute = /* @__PURE__ */ __name(function _removeAttribute2(name, element3) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: element3.getAttributeNode(name),
          from: element3
        });
      } catch (_2) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: element3
        });
      }
      element3.removeAttribute(name);
      if (name === "is" && !ALLOWED_ATTR[name]) {
        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
          try {
            _forceRemove(element3);
          } catch (_2) {
          }
        } else {
          try {
            element3.setAttribute(name, "");
          } catch (_2) {
          }
        }
      }
    }, "_removeAttribute");
    const _initDocument = /* @__PURE__ */ __name(function _initDocument2(dirty) {
      let doc = null;
      let leadingWhitespace = null;
      if (FORCE_BODY) {
        dirty = "<remove></remove>" + dirty;
      } else {
        const matches33 = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches33 && matches33[0];
      }
      if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
        dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
      }
      const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      if (NAMESPACE === HTML_NAMESPACE) {
        try {
          doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
        } catch (_2) {
        }
      }
      if (!doc || !doc.documentElement) {
        doc = implementation.createDocument(NAMESPACE, "template", null);
        try {
          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
        } catch (_2) {
        }
      }
      const body = doc.body || doc.documentElement;
      if (dirty && leadingWhitespace) {
        body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
      }
      if (NAMESPACE === HTML_NAMESPACE) {
        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
      }
      return WHOLE_DOCUMENT ? doc.documentElement : body;
    }, "_initDocument");
    const _createNodeIterator = /* @__PURE__ */ __name(function _createNodeIterator2(root4) {
      return createNodeIterator.call(
        root4.ownerDocument || root4,
        root4,
        // eslint-disable-next-line no-bitwise
        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION,
        null
      );
    }, "_createNodeIterator");
    const _isClobbered = /* @__PURE__ */ __name(function _isClobbered2(element3) {
      return element3 instanceof HTMLFormElement && (typeof element3.nodeName !== "string" || typeof element3.textContent !== "string" || typeof element3.removeChild !== "function" || !(element3.attributes instanceof NamedNodeMap) || typeof element3.removeAttribute !== "function" || typeof element3.setAttribute !== "function" || typeof element3.namespaceURI !== "string" || typeof element3.insertBefore !== "function" || typeof element3.hasChildNodes !== "function");
    }, "_isClobbered");
    const _isNode = /* @__PURE__ */ __name(function _isNode2(value2) {
      return typeof Node === "function" && value2 instanceof Node;
    }, "_isNode");
    function _executeHook(entryPoint, currentNode, data5) {
      if (!hooks[entryPoint]) {
        return;
      }
      arrayForEach(hooks[entryPoint], (hook2) => {
        hook2.call(DOMPurify, currentNode, data5, CONFIG);
      });
    }
    __name(_executeHook, "_executeHook");
    const _sanitizeElements = /* @__PURE__ */ __name(function _sanitizeElements2(currentNode) {
      let content = null;
      _executeHook("beforeSanitizeElements", currentNode, null);
      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      const tagName = transformCaseFunc(currentNode.nodeName);
      _executeHook("uponSanitizeElement", currentNode, {
        tagName,
        allowedTags: ALLOWED_TAGS
      });
      if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
        _forceRemove(currentNode);
        return true;
      }
      if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
        _forceRemove(currentNode);
        return true;
      }
      if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
        _forceRemove(currentNode);
        return true;
      }
      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
        if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
            return false;
          }
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
            return false;
          }
        }
        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          const parentNode = getParentNode(currentNode) || currentNode.parentNode;
          const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
          if (childNodes && parentNode) {
            const childCount = childNodes.length;
            for (let i2 = childCount - 1; i2 >= 0; --i2) {
              const childClone = cloneNode(childNodes[i2], true);
              childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
              parentNode.insertBefore(childClone, getNextSibling(currentNode));
            }
          }
        }
        _forceRemove(currentNode);
        return true;
      }
      if (currentNode instanceof Element4 && !_checkValidNamespace(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }
      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
        content = currentNode.textContent;
        arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          content = stringReplace(content, expr, " ");
        });
        if (currentNode.textContent !== content) {
          arrayPush(DOMPurify.removed, {
            element: currentNode.cloneNode()
          });
          currentNode.textContent = content;
        }
      }
      _executeHook("afterSanitizeElements", currentNode, null);
      return false;
    }, "_sanitizeElements");
    const _isValidAttribute = /* @__PURE__ */ __name(function _isValidAttribute2(lcTag, lcName, value2) {
      if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value2 in document2 || value2 in formElement)) {
        return false;
      }
      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR2, lcName)) ;
      else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR2, lcName)) ;
      else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        if (
          // First condition does a very basic check if a) it's basically a valid custom element tagname AND
          // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
          _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
          // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value2) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value2))
        ) ;
        else {
          return false;
        }
      } else if (URI_SAFE_ATTRIBUTES[lcName]) ;
      else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value2, ATTR_WHITESPACE2, ""))) ;
      else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value2, "data:") === 0 && DATA_URI_TAGS[lcTag]) ;
      else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA2, stringReplace(value2, ATTR_WHITESPACE2, ""))) ;
      else if (value2) {
        return false;
      } else ;
      return true;
    }, "_isValidAttribute");
    const _isBasicCustomElement = /* @__PURE__ */ __name(function _isBasicCustomElement2(tagName) {
      return tagName !== "annotation-xml" && stringMatch(tagName, CUSTOM_ELEMENT2);
    }, "_isBasicCustomElement");
    const _sanitizeAttributes = /* @__PURE__ */ __name(function _sanitizeAttributes2(currentNode) {
      _executeHook("beforeSanitizeAttributes", currentNode, null);
      const {
        attributes
      } = currentNode;
      if (!attributes) {
        return;
      }
      const hookEvent = {
        attrName: "",
        attrValue: "",
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR,
        forceKeepAttr: void 0
      };
      let l2 = attributes.length;
      while (l2--) {
        const attr = attributes[l2];
        const {
          name,
          namespaceURI,
          value: attrValue
        } = attr;
        const lcName = transformCaseFunc(name);
        let value2 = name === "value" ? attrValue : stringTrim(attrValue);
        hookEvent.attrName = lcName;
        hookEvent.attrValue = value2;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = void 0;
        _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
        value2 = hookEvent.attrValue;
        if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
          _removeAttribute(name, currentNode);
          value2 = SANITIZE_NAMED_PROPS_PREFIX + value2;
        }
        if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value2)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (hookEvent.forceKeepAttr) {
          continue;
        }
        _removeAttribute(name, currentNode);
        if (!hookEvent.keepAttr) {
          continue;
        }
        if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value2)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (SAFE_FOR_TEMPLATES) {
          arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
            value2 = stringReplace(value2, expr, " ");
          });
        }
        const lcTag = transformCaseFunc(currentNode.nodeName);
        if (!_isValidAttribute(lcTag, lcName, value2)) {
          continue;
        }
        if (trustedTypesPolicy && typeof trustedTypes === "object" && typeof trustedTypes.getAttributeType === "function") {
          if (namespaceURI) ;
          else {
            switch (trustedTypes.getAttributeType(lcTag, lcName)) {
              case "TrustedHTML": {
                value2 = trustedTypesPolicy.createHTML(value2);
                break;
              }
              case "TrustedScriptURL": {
                value2 = trustedTypesPolicy.createScriptURL(value2);
                break;
              }
            }
          }
        }
        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name, value2);
          } else {
            currentNode.setAttribute(name, value2);
          }
          if (_isClobbered(currentNode)) {
            _forceRemove(currentNode);
          } else {
            arrayPop(DOMPurify.removed);
          }
        } catch (_2) {
        }
      }
      _executeHook("afterSanitizeAttributes", currentNode, null);
    }, "_sanitizeAttributes");
    const _sanitizeShadowDOM = /* @__PURE__ */ __name(function _sanitizeShadowDOM2(fragment) {
      let shadowNode = null;
      const shadowIterator = _createNodeIterator(fragment);
      _executeHook("beforeSanitizeShadowDOM", fragment, null);
      while (shadowNode = shadowIterator.nextNode()) {
        _executeHook("uponSanitizeShadowNode", shadowNode, null);
        if (_sanitizeElements(shadowNode)) {
          continue;
        }
        if (shadowNode.content instanceof DocumentFragment2) {
          _sanitizeShadowDOM2(shadowNode.content);
        }
        _sanitizeAttributes(shadowNode);
      }
      _executeHook("afterSanitizeShadowDOM", fragment, null);
    }, "_sanitizeShadowDOM");
    DOMPurify.sanitize = function(dirty) {
      let cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let body = null;
      let importedNode = null;
      let currentNode = null;
      let returnNode = null;
      IS_EMPTY_INPUT = !dirty;
      if (IS_EMPTY_INPUT) {
        dirty = "<!-->";
      }
      if (typeof dirty !== "string" && !_isNode(dirty)) {
        if (typeof dirty.toString === "function") {
          dirty = dirty.toString();
          if (typeof dirty !== "string") {
            throw typeErrorCreate("dirty is not a string, aborting");
          }
        } else {
          throw typeErrorCreate("toString is not a function");
        }
      }
      if (!DOMPurify.isSupported) {
        return dirty;
      }
      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }
      DOMPurify.removed = [];
      if (typeof dirty === "string") {
        IN_PLACE = false;
      }
      if (IN_PLACE) {
        if (dirty.nodeName) {
          const tagName = transformCaseFunc(dirty.nodeName);
          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
          }
        }
      } else if (dirty instanceof Node) {
        body = _initDocument("<!---->");
        importedNode = body.ownerDocument.importNode(dirty, true);
        if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === "BODY") {
          body = importedNode;
        } else if (importedNode.nodeName === "HTML") {
          body = importedNode;
        } else {
          body.appendChild(importedNode);
        }
      } else {
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
        dirty.indexOf("<") === -1) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }
        body = _initDocument(dirty);
        if (!body) {
          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
        }
      }
      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild);
      }
      const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
      while (currentNode = nodeIterator.nextNode()) {
        if (_sanitizeElements(currentNode)) {
          continue;
        }
        if (currentNode.content instanceof DocumentFragment2) {
          _sanitizeShadowDOM(currentNode.content);
        }
        _sanitizeAttributes(currentNode);
      }
      if (IN_PLACE) {
        return dirty;
      }
      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument);
          while (body.firstChild) {
            returnNode.appendChild(body.firstChild);
          }
        } else {
          returnNode = body;
        }
        if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
          returnNode = importNode.call(originalDocument, returnNode, true);
        }
        return returnNode;
      }
      let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
      if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
        serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
      }
      if (SAFE_FOR_TEMPLATES) {
        arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          serializedHTML = stringReplace(serializedHTML, expr, " ");
        });
      }
      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };
    DOMPurify.setConfig = function() {
      let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _parseConfig(cfg);
      SET_CONFIG = true;
    };
    DOMPurify.clearConfig = function() {
      CONFIG = null;
      SET_CONFIG = false;
    };
    DOMPurify.isValidAttribute = function(tag2, attr, value2) {
      if (!CONFIG) {
        _parseConfig({});
      }
      const lcTag = transformCaseFunc(tag2);
      const lcName = transformCaseFunc(attr);
      return _isValidAttribute(lcTag, lcName, value2);
    };
    DOMPurify.addHook = function(entryPoint, hookFunction) {
      if (typeof hookFunction !== "function") {
        return;
      }
      hooks[entryPoint] = hooks[entryPoint] || [];
      arrayPush(hooks[entryPoint], hookFunction);
    };
    DOMPurify.removeHook = function(entryPoint) {
      if (hooks[entryPoint]) {
        return arrayPop(hooks[entryPoint]);
      }
    };
    DOMPurify.removeHooks = function(entryPoint) {
      if (hooks[entryPoint]) {
        hooks[entryPoint] = [];
      }
    };
    DOMPurify.removeAllHooks = function() {
      hooks = {};
    };
    return DOMPurify;
  }
  var entries, setPrototypeOf, isFrozen, getPrototypeOf, getOwnPropertyDescriptor, freeze, seal, create, apply, construct, arrayForEach, arrayPop, arrayPush, stringToLowerCase, stringToString, stringMatch, stringReplace, stringIndexOf, stringTrim, objectHasOwnProperty, regExpTest, typeErrorCreate, html$1, svg$1, svgFilters, svgDisallowed, mathMl$1, mathMlDisallowed, text, html, svg, mathMl, xml, MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR, DATA_ATTR, ARIA_ATTR, IS_ALLOWED_URI, IS_SCRIPT_OR_DATA, ATTR_WHITESPACE, DOCTYPE_NAME, CUSTOM_ELEMENT, EXPRESSIONS, NODE_TYPE, getGlobal, _createTrustedTypesPolicy, purify;
  var init_purify_es = __esm({
    "../../node_modules/.pnpm/dompurify@3.2.1/node_modules/dompurify/dist/purify.es.mjs"() {
      "use strict";
      ({
        entries,
        setPrototypeOf,
        isFrozen,
        getPrototypeOf,
        getOwnPropertyDescriptor
      } = Object);
      ({
        freeze,
        seal,
        create
      } = Object);
      ({
        apply,
        construct
      } = typeof Reflect !== "undefined" && Reflect);
      if (!freeze) {
        freeze = /* @__PURE__ */ __name(function freeze2(x5) {
          return x5;
        }, "freeze");
      }
      if (!seal) {
        seal = /* @__PURE__ */ __name(function seal2(x5) {
          return x5;
        }, "seal");
      }
      if (!apply) {
        apply = /* @__PURE__ */ __name(function apply5(fun, thisValue, args) {
          return fun.apply(thisValue, args);
        }, "apply");
      }
      if (!construct) {
        construct = /* @__PURE__ */ __name(function construct2(Func, args) {
          return new Func(...args);
        }, "construct");
      }
      arrayForEach = unapply(Array.prototype.forEach);
      arrayPop = unapply(Array.prototype.pop);
      arrayPush = unapply(Array.prototype.push);
      stringToLowerCase = unapply(String.prototype.toLowerCase);
      stringToString = unapply(String.prototype.toString);
      stringMatch = unapply(String.prototype.match);
      stringReplace = unapply(String.prototype.replace);
      stringIndexOf = unapply(String.prototype.indexOf);
      stringTrim = unapply(String.prototype.trim);
      objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
      regExpTest = unapply(RegExp.prototype.test);
      typeErrorCreate = unconstruct(TypeError);
      __name(unapply, "unapply");
      __name(unconstruct, "unconstruct");
      __name(addToSet, "addToSet");
      __name(cleanArray, "cleanArray");
      __name(clone, "clone");
      __name(lookupGetter, "lookupGetter");
      html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
      svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
      svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
      svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
      mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
      mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
      text = freeze(["#text"]);
      html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
      svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
      mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
      xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
      MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
      ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
      TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
      DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
      ARIA_ATTR = seal(/^aria-[\-\w]+$/);
      IS_ALLOWED_URI = seal(
        /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
        // eslint-disable-line no-useless-escape
      );
      IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
      ATTR_WHITESPACE = seal(
        /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
        // eslint-disable-line no-control-regex
      );
      DOCTYPE_NAME = seal(/^html$/i);
      CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
      EXPRESSIONS = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        ARIA_ATTR,
        ATTR_WHITESPACE,
        CUSTOM_ELEMENT,
        DATA_ATTR,
        DOCTYPE_NAME,
        ERB_EXPR,
        IS_ALLOWED_URI,
        IS_SCRIPT_OR_DATA,
        MUSTACHE_EXPR,
        TMPLIT_EXPR
      });
      NODE_TYPE = {
        element: 1,
        attribute: 2,
        text: 3,
        cdataSection: 4,
        entityReference: 5,
        // Deprecated
        entityNode: 6,
        // Deprecated
        progressingInstruction: 7,
        comment: 8,
        document: 9,
        documentType: 10,
        documentFragment: 11,
        notation: 12
        // Deprecated
      };
      getGlobal = /* @__PURE__ */ __name(function getGlobal2() {
        return typeof window === "undefined" ? null : window;
      }, "getGlobal");
      _createTrustedTypesPolicy = /* @__PURE__ */ __name(function _createTrustedTypesPolicy2(trustedTypes, purifyHostElement) {
        if (typeof trustedTypes !== "object" || typeof trustedTypes.createPolicy !== "function") {
          return null;
        }
        let suffix = null;
        const ATTR_NAME = "data-tt-policy-suffix";
        if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
          suffix = purifyHostElement.getAttribute(ATTR_NAME);
        }
        const policyName = "dompurify" + (suffix ? "#" + suffix : "");
        try {
          return trustedTypes.createPolicy(policyName, {
            createHTML(html3) {
              return html3;
            },
            createScriptURL(scriptUrl) {
              return scriptUrl;
            }
          });
        } catch (_2) {
          console.warn("TrustedTypes policy " + policyName + " could not be created.");
          return null;
        }
      }, "_createTrustedTypesPolicy");
      __name(createDOMPurify, "createDOMPurify");
      purify = createDOMPurify();
    }
  });

  // ../../node_modules/.pnpm/katex@0.16.11/node_modules/katex/dist/katex.mjs
  var katex_exports = {};
  __export(katex_exports, {
    default: () => katex
  });
  function escape2(text4) {
    return String(text4).replace(ESCAPE_REGEX, (match2) => ESCAPE_LOOKUP[match2]);
  }
  function getDefaultValue(schema2) {
    if (schema2.default) {
      return schema2.default;
    }
    var type3 = schema2.type;
    var defaultType = Array.isArray(type3) ? type3[0] : type3;
    if (typeof defaultType !== "string") {
      return defaultType.enum[0];
    }
    switch (defaultType) {
      case "boolean":
        return false;
      case "string":
        return "";
      case "number":
        return 0;
      case "object":
        return {};
    }
  }
  function scriptFromCodepoint(codepoint) {
    for (var i2 = 0; i2 < scriptData.length; i2++) {
      var script = scriptData[i2];
      for (var _i = 0; _i < script.blocks.length; _i++) {
        var block3 = script.blocks[_i];
        if (codepoint >= block3[0] && codepoint <= block3[1]) {
          return script.name;
        }
      }
    }
    return null;
  }
  function supportedCodepoint(codepoint) {
    for (var i2 = 0; i2 < allBlocks.length; i2 += 2) {
      if (codepoint >= allBlocks[i2] && codepoint <= allBlocks[i2 + 1]) {
        return true;
      }
    }
    return false;
  }
  function setFontMetrics(fontName, metrics) {
    fontMetricsData[fontName] = metrics;
  }
  function getCharacterMetrics(character2, font, mode) {
    if (!fontMetricsData[font]) {
      throw new Error("Font metrics not found for font: " + font + ".");
    }
    var ch = character2.charCodeAt(0);
    var metrics = fontMetricsData[font][ch];
    if (!metrics && character2[0] in extraCharacterMap) {
      ch = extraCharacterMap[character2[0]].charCodeAt(0);
      metrics = fontMetricsData[font][ch];
    }
    if (!metrics && mode === "text") {
      if (supportedCodepoint(ch)) {
        metrics = fontMetricsData[font][77];
      }
    }
    if (metrics) {
      return {
        depth: metrics[0],
        height: metrics[1],
        italic: metrics[2],
        skew: metrics[3],
        width: metrics[4]
      };
    }
  }
  function getGlobalMetrics(size5) {
    var sizeIndex;
    if (size5 >= 5) {
      sizeIndex = 0;
    } else if (size5 >= 3) {
      sizeIndex = 1;
    } else {
      sizeIndex = 2;
    }
    if (!fontMetricsBySizeIndex[sizeIndex]) {
      var metrics = fontMetricsBySizeIndex[sizeIndex] = {
        cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
      };
      for (var key in sigmasAndXis) {
        if (sigmasAndXis.hasOwnProperty(key)) {
          metrics[key] = sigmasAndXis[key][sizeIndex];
        }
      }
    }
    return fontMetricsBySizeIndex[sizeIndex];
  }
  function assertSymbolDomNode(group2) {
    if (group2 instanceof SymbolNode) {
      return group2;
    } else {
      throw new Error("Expected symbolNode but got " + String(group2) + ".");
    }
  }
  function assertSpan(group2) {
    if (group2 instanceof Span) {
      return group2;
    } else {
      throw new Error("Expected span<HtmlDomNode> but got " + String(group2) + ".");
    }
  }
  function defineSymbol(mode, font, group2, replace2, name, acceptUnicodeChar) {
    symbols[mode][name] = {
      font,
      group: group2,
      replace: replace2
    };
    if (acceptUnicodeChar && replace2) {
      symbols[mode][replace2] = symbols[mode][name];
    }
  }
  function defineFunction(_ref) {
    var {
      type: type3,
      names,
      props,
      handler,
      htmlBuilder: htmlBuilder3,
      mathmlBuilder: mathmlBuilder3
    } = _ref;
    var data5 = {
      type: type3,
      numArgs: props.numArgs,
      argTypes: props.argTypes,
      allowedInArgument: !!props.allowedInArgument,
      allowedInText: !!props.allowedInText,
      allowedInMath: props.allowedInMath === void 0 ? true : props.allowedInMath,
      numOptionalArgs: props.numOptionalArgs || 0,
      infix: !!props.infix,
      primitive: !!props.primitive,
      handler
    };
    for (var i2 = 0; i2 < names.length; ++i2) {
      _functions[names[i2]] = data5;
    }
    if (type3) {
      if (htmlBuilder3) {
        _htmlGroupBuilders[type3] = htmlBuilder3;
      }
      if (mathmlBuilder3) {
        _mathmlGroupBuilders[type3] = mathmlBuilder3;
      }
    }
  }
  function defineFunctionBuilders(_ref2) {
    var {
      type: type3,
      htmlBuilder: htmlBuilder3,
      mathmlBuilder: mathmlBuilder3
    } = _ref2;
    defineFunction({
      type: type3,
      names: [],
      props: {
        numArgs: 0
      },
      handler() {
        throw new Error("Should never be called.");
      },
      htmlBuilder: htmlBuilder3,
      mathmlBuilder: mathmlBuilder3
    });
  }
  function buildHTMLUnbreakable(children2, options3) {
    var body = makeSpan$1(["base"], children2, options3);
    var strut = makeSpan$1(["strut"]);
    strut.style.height = makeEm(body.height + body.depth);
    if (body.depth) {
      strut.style.verticalAlign = makeEm(-body.depth);
    }
    body.children.unshift(strut);
    return body;
  }
  function buildHTML(tree, options3) {
    var tag2 = null;
    if (tree.length === 1 && tree[0].type === "tag") {
      tag2 = tree[0].tag;
      tree = tree[0].body;
    }
    var expression = buildExpression$1(tree, options3, "root");
    var eqnNum;
    if (expression.length === 2 && expression[1].hasClass("tag")) {
      eqnNum = expression.pop();
    }
    var children2 = [];
    var parts = [];
    for (var i2 = 0; i2 < expression.length; i2++) {
      parts.push(expression[i2]);
      if (expression[i2].hasClass("mbin") || expression[i2].hasClass("mrel") || expression[i2].hasClass("allowbreak")) {
        var nobreak = false;
        while (i2 < expression.length - 1 && expression[i2 + 1].hasClass("mspace") && !expression[i2 + 1].hasClass("newline")) {
          i2++;
          parts.push(expression[i2]);
          if (expression[i2].hasClass("nobreak")) {
            nobreak = true;
          }
        }
        if (!nobreak) {
          children2.push(buildHTMLUnbreakable(parts, options3));
          parts = [];
        }
      } else if (expression[i2].hasClass("newline")) {
        parts.pop();
        if (parts.length > 0) {
          children2.push(buildHTMLUnbreakable(parts, options3));
          parts = [];
        }
        children2.push(expression[i2]);
      }
    }
    if (parts.length > 0) {
      children2.push(buildHTMLUnbreakable(parts, options3));
    }
    var tagChild;
    if (tag2) {
      tagChild = buildHTMLUnbreakable(buildExpression$1(tag2, options3, true));
      tagChild.classes = ["tag"];
      children2.push(tagChild);
    } else if (eqnNum) {
      children2.push(eqnNum);
    }
    var htmlNode = makeSpan$1(["katex-html"], children2);
    htmlNode.setAttribute("aria-hidden", "true");
    if (tagChild) {
      var strut = tagChild.children[0];
      strut.style.height = makeEm(htmlNode.height + htmlNode.depth);
      if (htmlNode.depth) {
        strut.style.verticalAlign = makeEm(-htmlNode.depth);
      }
    }
    return htmlNode;
  }
  function newDocumentFragment(children2) {
    return new DocumentFragment(children2);
  }
  function buildMathML(tree, texExpression, options3, isDisplayMode, forMathmlOnly) {
    var expression = buildExpression2(tree, options3);
    var wrapper;
    if (expression.length === 1 && expression[0] instanceof MathNode && utils.contains(["mrow", "mtable"], expression[0].type)) {
      wrapper = expression[0];
    } else {
      wrapper = new mathMLTree.MathNode("mrow", expression);
    }
    var annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
    annotation.setAttribute("encoding", "application/x-tex");
    var semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
    var math2 = new mathMLTree.MathNode("math", [semantics]);
    math2.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
    if (isDisplayMode) {
      math2.setAttribute("display", "block");
    }
    var wrapperClass = forMathmlOnly ? "katex" : "katex-mathml";
    return buildCommon.makeSpan([wrapperClass], [math2]);
  }
  function assertNodeType(node2, type3) {
    if (!node2 || node2.type !== type3) {
      throw new Error("Expected node of type " + type3 + ", but got " + (node2 ? "node of type " + node2.type : String(node2)));
    }
    return node2;
  }
  function assertSymbolNodeType(node2) {
    var typedNode = checkSymbolNodeType(node2);
    if (!typedNode) {
      throw new Error("Expected node of symbol group type, but got " + (node2 ? "node of type " + node2.type : String(node2)));
    }
    return typedNode;
  }
  function checkSymbolNodeType(node2) {
    if (node2 && (node2.type === "atom" || NON_ATOMS.hasOwnProperty(node2.type))) {
      return node2;
    }
    return null;
  }
  function htmlBuilder$9(group2, options3) {
    var elements4 = buildExpression$1(group2.body, options3, true);
    return makeSpan2([group2.mclass], elements4, options3);
  }
  function mathmlBuilder$8(group2, options3) {
    var node2;
    var inner2 = buildExpression2(group2.body, options3);
    if (group2.mclass === "minner") {
      node2 = new mathMLTree.MathNode("mpadded", inner2);
    } else if (group2.mclass === "mord") {
      if (group2.isCharacterBox) {
        node2 = inner2[0];
        node2.type = "mi";
      } else {
        node2 = new mathMLTree.MathNode("mi", inner2);
      }
    } else {
      if (group2.isCharacterBox) {
        node2 = inner2[0];
        node2.type = "mo";
      } else {
        node2 = new mathMLTree.MathNode("mo", inner2);
      }
      if (group2.mclass === "mbin") {
        node2.attributes.lspace = "0.22em";
        node2.attributes.rspace = "0.22em";
      } else if (group2.mclass === "mpunct") {
        node2.attributes.lspace = "0em";
        node2.attributes.rspace = "0.17em";
      } else if (group2.mclass === "mopen" || group2.mclass === "mclose") {
        node2.attributes.lspace = "0em";
        node2.attributes.rspace = "0em";
      } else if (group2.mclass === "minner") {
        node2.attributes.lspace = "0.0556em";
        node2.attributes.width = "+0.1111em";
      }
    }
    return node2;
  }
  function cdArrow(arrowChar, labels, parser23) {
    var funcName = cdArrowFunctionName[arrowChar];
    switch (funcName) {
      case "\\\\cdrightarrow":
      case "\\\\cdleftarrow":
        return parser23.callFunction(funcName, [labels[0]], [labels[1]]);
      case "\\uparrow":
      case "\\downarrow": {
        var leftLabel = parser23.callFunction("\\\\cdleft", [labels[0]], []);
        var bareArrow = {
          type: "atom",
          text: funcName,
          mode: "math",
          family: "rel"
        };
        var sizedArrow = parser23.callFunction("\\Big", [bareArrow], []);
        var rightLabel = parser23.callFunction("\\\\cdright", [labels[1]], []);
        var arrowGroup = {
          type: "ordgroup",
          mode: "math",
          body: [leftLabel, sizedArrow, rightLabel]
        };
        return parser23.callFunction("\\\\cdparent", [arrowGroup], []);
      }
      case "\\\\cdlongequal":
        return parser23.callFunction("\\\\cdlongequal", [], []);
      case "\\Vert": {
        var arrow = {
          type: "textord",
          text: "\\Vert",
          mode: "math"
        };
        return parser23.callFunction("\\Big", [arrow], []);
      }
      default:
        return {
          type: "textord",
          text: " ",
          mode: "math"
        };
    }
  }
  function parseCD(parser23) {
    var parsedRows = [];
    parser23.gullet.beginGroup();
    parser23.gullet.macros.set("\\cr", "\\\\\\relax");
    parser23.gullet.beginGroup();
    while (true) {
      parsedRows.push(parser23.parseExpression(false, "\\\\"));
      parser23.gullet.endGroup();
      parser23.gullet.beginGroup();
      var next3 = parser23.fetch().text;
      if (next3 === "&" || next3 === "\\\\") {
        parser23.consume();
      } else if (next3 === "\\end") {
        if (parsedRows[parsedRows.length - 1].length === 0) {
          parsedRows.pop();
        }
        break;
      } else {
        throw new ParseError("Expected \\\\ or \\cr or \\end", parser23.nextToken);
      }
    }
    var row = [];
    var body = [row];
    for (var i2 = 0; i2 < parsedRows.length; i2++) {
      var rowNodes = parsedRows[i2];
      var cell = newCell();
      for (var j2 = 0; j2 < rowNodes.length; j2++) {
        if (!isStartOfArrow(rowNodes[j2])) {
          cell.body.push(rowNodes[j2]);
        } else {
          row.push(cell);
          j2 += 1;
          var arrowChar = assertSymbolNodeType(rowNodes[j2]).text;
          var labels = new Array(2);
          labels[0] = {
            type: "ordgroup",
            mode: "math",
            body: []
          };
          labels[1] = {
            type: "ordgroup",
            mode: "math",
            body: []
          };
          if ("=|.".indexOf(arrowChar) > -1) ;
          else if ("<>AV".indexOf(arrowChar) > -1) {
            for (var labelNum = 0; labelNum < 2; labelNum++) {
              var inLabel = true;
              for (var k2 = j2 + 1; k2 < rowNodes.length; k2++) {
                if (isLabelEnd(rowNodes[k2], arrowChar)) {
                  inLabel = false;
                  j2 = k2;
                  break;
                }
                if (isStartOfArrow(rowNodes[k2])) {
                  throw new ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[k2]);
                }
                labels[labelNum].body.push(rowNodes[k2]);
              }
              if (inLabel) {
                throw new ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[j2]);
              }
            }
          } else {
            throw new ParseError('Expected one of "<>AV=|." after @', rowNodes[j2]);
          }
          var arrow = cdArrow(arrowChar, labels, parser23);
          var wrappedArrow = {
            type: "styling",
            body: [arrow],
            mode: "math",
            style: "display"
            // CD is always displaystyle.
          };
          row.push(wrappedArrow);
          cell = newCell();
        }
      }
      if (i2 % 2 === 0) {
        row.push(cell);
      } else {
        row.shift();
      }
      row = [];
      body.push(row);
    }
    parser23.gullet.endGroup();
    parser23.gullet.endGroup();
    var cols = new Array(body[0].length).fill({
      type: "align",
      align: "c",
      pregap: 0.25,
      // CD package sets \enskip between columns.
      postgap: 0.25
      // So pre and post each get half an \enskip, i.e. 0.25em.
    });
    return {
      type: "array",
      mode: "math",
      body,
      arraystretch: 1,
      addJot: true,
      rowGaps: [null],
      cols,
      colSeparationType: "CD",
      hLinesBeforeRow: new Array(body.length + 1).fill([])
    };
  }
  function checkDelimiter(delim, context) {
    var symDelim = checkSymbolNodeType(delim);
    if (symDelim && utils.contains(delimiters, symDelim.text)) {
      return symDelim;
    } else if (symDelim) {
      throw new ParseError("Invalid delimiter '" + symDelim.text + "' after '" + context.funcName + "'", delim);
    } else {
      throw new ParseError("Invalid delimiter type '" + delim.type + "'", delim);
    }
  }
  function assertParsed(group2) {
    if (!group2.body) {
      throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
    }
  }
  function defineEnvironment(_ref) {
    var {
      type: type3,
      names,
      props,
      handler,
      htmlBuilder: htmlBuilder3,
      mathmlBuilder: mathmlBuilder3
    } = _ref;
    var data5 = {
      type: type3,
      numArgs: props.numArgs || 0,
      allowedInText: false,
      numOptionalArgs: 0,
      handler
    };
    for (var i2 = 0; i2 < names.length; ++i2) {
      _environments[names[i2]] = data5;
    }
    if (htmlBuilder3) {
      _htmlGroupBuilders[type3] = htmlBuilder3;
    }
    if (mathmlBuilder3) {
      _mathmlGroupBuilders[type3] = mathmlBuilder3;
    }
  }
  function defineMacro(name, body) {
    _macros[name] = body;
  }
  function getHLines(parser23) {
    var hlineInfo = [];
    parser23.consumeSpaces();
    var nxt = parser23.fetch().text;
    if (nxt === "\\relax") {
      parser23.consume();
      parser23.consumeSpaces();
      nxt = parser23.fetch().text;
    }
    while (nxt === "\\hline" || nxt === "\\hdashline") {
      parser23.consume();
      hlineInfo.push(nxt === "\\hdashline");
      parser23.consumeSpaces();
      nxt = parser23.fetch().text;
    }
    return hlineInfo;
  }
  function getAutoTag(name) {
    if (name.indexOf("ed") === -1) {
      return name.indexOf("*") === -1;
    }
  }
  function parseArray(parser23, _ref, style3) {
    var {
      hskipBeforeAndAfter,
      addJot,
      cols,
      arraystretch,
      colSeparationType,
      autoTag,
      singleRow,
      emptySingleRow,
      maxNumCols,
      leqno
    } = _ref;
    parser23.gullet.beginGroup();
    if (!singleRow) {
      parser23.gullet.macros.set("\\cr", "\\\\\\relax");
    }
    if (!arraystretch) {
      var stretch = parser23.gullet.expandMacroAsText("\\arraystretch");
      if (stretch == null) {
        arraystretch = 1;
      } else {
        arraystretch = parseFloat(stretch);
        if (!arraystretch || arraystretch < 0) {
          throw new ParseError("Invalid \\arraystretch: " + stretch);
        }
      }
    }
    parser23.gullet.beginGroup();
    var row = [];
    var body = [row];
    var rowGaps = [];
    var hLinesBeforeRow = [];
    var tags2 = autoTag != null ? [] : void 0;
    function beginRow() {
      if (autoTag) {
        parser23.gullet.macros.set("\\@eqnsw", "1", true);
      }
    }
    __name(beginRow, "beginRow");
    function endRow() {
      if (tags2) {
        if (parser23.gullet.macros.get("\\df@tag")) {
          tags2.push(parser23.subparse([new Token("\\df@tag")]));
          parser23.gullet.macros.set("\\df@tag", void 0, true);
        } else {
          tags2.push(Boolean(autoTag) && parser23.gullet.macros.get("\\@eqnsw") === "1");
        }
      }
    }
    __name(endRow, "endRow");
    beginRow();
    hLinesBeforeRow.push(getHLines(parser23));
    while (true) {
      var cell = parser23.parseExpression(false, singleRow ? "\\end" : "\\\\");
      parser23.gullet.endGroup();
      parser23.gullet.beginGroup();
      cell = {
        type: "ordgroup",
        mode: parser23.mode,
        body: cell
      };
      if (style3) {
        cell = {
          type: "styling",
          mode: parser23.mode,
          style: style3,
          body: [cell]
        };
      }
      row.push(cell);
      var next3 = parser23.fetch().text;
      if (next3 === "&") {
        if (maxNumCols && row.length === maxNumCols) {
          if (singleRow || colSeparationType) {
            throw new ParseError("Too many tab characters: &", parser23.nextToken);
          } else {
            parser23.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
          }
        }
        parser23.consume();
      } else if (next3 === "\\end") {
        endRow();
        if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {
          body.pop();
        }
        if (hLinesBeforeRow.length < body.length + 1) {
          hLinesBeforeRow.push([]);
        }
        break;
      } else if (next3 === "\\\\") {
        parser23.consume();
        var size5 = void 0;
        if (parser23.gullet.future().text !== " ") {
          size5 = parser23.parseSizeGroup(true);
        }
        rowGaps.push(size5 ? size5.value : null);
        endRow();
        hLinesBeforeRow.push(getHLines(parser23));
        row = [];
        body.push(row);
        beginRow();
      } else {
        throw new ParseError("Expected & or \\\\ or \\cr or \\end", parser23.nextToken);
      }
    }
    parser23.gullet.endGroup();
    parser23.gullet.endGroup();
    return {
      type: "array",
      mode: parser23.mode,
      addJot,
      arraystretch,
      body,
      cols,
      rowGaps,
      hskipBeforeAndAfter,
      hLinesBeforeRow,
      colSeparationType,
      tags: tags2,
      leqno
    };
  }
  function dCellStyle(envName) {
    if (envName.slice(0, 1) === "d") {
      return "display";
    } else {
      return "text";
    }
  }
  function sizingGroup(value2, options3, baseOptions) {
    var inner2 = buildExpression$1(value2, options3, false);
    var multiplier = options3.sizeMultiplier / baseOptions.sizeMultiplier;
    for (var i2 = 0; i2 < inner2.length; i2++) {
      var pos = inner2[i2].classes.indexOf("sizing");
      if (pos < 0) {
        Array.prototype.push.apply(inner2[i2].classes, options3.sizingClasses(baseOptions));
      } else if (inner2[i2].classes[pos + 1] === "reset-size" + options3.size) {
        inner2[i2].classes[pos + 1] = "reset-size" + baseOptions.size;
      }
      inner2[i2].height *= multiplier;
      inner2[i2].depth *= multiplier;
    }
    return buildCommon.makeFragment(inner2);
  }
  var SourceLocation, Token, ParseError, contains, deflt, uppercase, hyphenate, ESCAPE_LOOKUP, ESCAPE_REGEX, getBaseElem, isCharacterBox, assert, protocolFromUrl, utils, SETTINGS_SCHEMA, Settings, Style, D, Dc, T, Tc, S, Sc, SS, SSc, styles, sup, sub, fracNum, fracDen, cramp, text$1, Style$1, scriptData, allBlocks, hLinePad, sqrtMain, sqrtSize1, sqrtSize2, sqrtSize3, sqrtSize4, phasePath, sqrtTall, sqrtPath, innerPath, path, tallDelim, DocumentFragment, fontMetricsData, sigmasAndXis, extraCharacterMap, fontMetricsBySizeIndex, sizeStyleMap, sizeMultipliers, sizeAtStyle, Options, ptPerUnit, relativeUnit, validUnit, calculateSize2, makeEm, createClass, initNode, toNode, toMarkup, Span, Anchor, Img, iCombinations, SymbolNode, SvgNode, PathNode, LineNode, ATOMS, NON_ATOMS, symbols, math, text2, main, ams, accent, bin, close, inner, mathord, op, open, punct, rel, spacing, textord, ligatures, mathTextSymbols, ch, i2, textSymbols, _ch, _i, letters, _ch2, _i2, wideChar, _ch3, _i3, _ch4, _i4, extraLatin, _ch5, _i5, wideLatinLetterData, wideNumeralData, wideCharacterFont, lookupSymbol, makeSymbol, mathsym, boldsymbol, makeOrd, canCombine, tryCombineChars, sizeElementFromChildren, makeSpan$2, makeSvgSpan, makeLineSpan, makeAnchor, makeFragment, wrapFragment, getVListChildrenAndDepth, makeVList, makeGlue, retrieveTextFontName, fontMap, svgData, staticSvg, buildCommon, thinspace, mediumspace, thickspace, spacings, tightSpacings, _functions, _htmlGroupBuilders, _mathmlGroupBuilders, normalizeArgument, ordargument, makeSpan$1, binLeftCanceller, binRightCanceller, styleMap$1, DomEnum, buildExpression$1, traverseNonSpaceNodes, checkPartialGroup, getOutermostNode, getTypeOfDomTree, makeNullDelimiter, buildGroup$1, MathNode, TextNode, SpaceNode, mathMLTree, makeText, makeRow, getVariant, buildExpression2, buildExpressionRow, buildGroup2, optionsFromSettings, displayWrap, buildTree, buildHTMLTree, stretchyCodePoint, mathMLnode, katexImagesData, groupLength, svgSpan, encloseSpan, stretchy, htmlBuilder$a, mathmlBuilder$9, NON_STRETCHY_ACCENT_REGEX, paddedNode, makeSpan2, binrelClass, cdArrowFunctionName, newCell, isStartOfArrow, isLabelEnd, htmlBuilder$8, mathmlBuilder$7, globalMap, checkControlSequence, getRHS, letCommand, getMetrics, styleWrap, centerSpan, makeSmallDelim, mathrmSize, makeLargeDelim, makeGlyphSpan, makeInner, lapInEms, lap, verts, doubleVerts, makeStackedDelim, vbPad, emPad, sqrtSvg, makeSqrtImage, stackLargeDelimiters, stackAlwaysDelimiters, stackNeverDelimiters, sizeToMaxHeight, makeSizedDelim, stackNeverDelimiterSequence, stackAlwaysDelimiterSequence, stackLargeDelimiterSequence, delimTypeToFont, traverseSequence, makeCustomSizedDelim, makeLeftRightDelim, delimiter, delimiterSizes, delimiters, htmlBuilder$7, mathmlBuilder$6, _environments, _macros, validateAmsEnvironmentContext, htmlBuilder$6, alignMap, mathmlBuilder$5, alignedHandler, environments, htmlBuilder$5, mathmlBuilder$4, fontAliases, adjustStyle, htmlBuilder$4, mathmlBuilder$3, stylArray, delimFromValue, htmlBuilder$3, mathmlBuilder$2, sizeData, chooseMathStyle, assembleSupSub, noSuccessor, htmlBuilder$2, mathmlBuilder$1, singleCharBigOps, singleCharIntegrals, htmlBuilder$1, mathmlBuilder2, sizeFuncs, htmlBuilder2, styleMap, htmlBuilderDelegate, defaultVariant, cssSpace, regularSpace, pad, textFontFamilies, textFontWeights, textFontShapes, optionsWithFont, makeVerb, functions, spaceRegexString, controlWordRegexString, controlSymbolRegexString, controlWordWhitespaceRegexString, controlSpaceRegexString, combiningDiacriticalMarkString, combiningDiacriticalMarksEndRegex, tokenRegexString, Lexer, Namespace, macros, digitToNumber, newcommand, dotsByToken, spaceAfterDots, latexRaiseA, braketHelper, implicitCommands, MacroExpander, unicodeSubRegEx, uSubsAndSups, unicodeAccents, unicodeSymbols, Parser, parseTree, render, renderToString, generateParseTree, renderError, renderToDomTree, renderToHTMLTree, katex;
  var init_katex = __esm({
    "../../node_modules/.pnpm/katex@0.16.11/node_modules/katex/dist/katex.mjs"() {
      "use strict";
      SourceLocation = class _SourceLocation {
        static {
          __name(this, "SourceLocation");
        }
        // The + prefix indicates that these fields aren't writeable
        // Lexer holding the input string.
        // Start offset, zero-based inclusive.
        // End offset, zero-based exclusive.
        constructor(lexer2, start3, end2) {
          this.lexer = void 0;
          this.start = void 0;
          this.end = void 0;
          this.lexer = lexer2;
          this.start = start3;
          this.end = end2;
        }
        /**
         * Merges two `SourceLocation`s from location providers, given they are
         * provided in order of appearance.
         * - Returns the first one's location if only the first is provided.
         * - Returns a merged range of the first and the last if both are provided
         *   and their lexers match.
         * - Otherwise, returns null.
         */
        static range(first3, second2) {
          if (!second2) {
            return first3 && first3.loc;
          } else if (!first3 || !first3.loc || !second2.loc || first3.loc.lexer !== second2.loc.lexer) {
            return null;
          } else {
            return new _SourceLocation(first3.loc.lexer, first3.loc.start, second2.loc.end);
          }
        }
      };
      Token = class _Token {
        static {
          __name(this, "Token");
        }
        // don't expand the token
        // used in \noexpand
        constructor(text4, loc) {
          this.text = void 0;
          this.loc = void 0;
          this.noexpand = void 0;
          this.treatAsRelax = void 0;
          this.text = text4;
          this.loc = loc;
        }
        /**
         * Given a pair of tokens (this and endToken), compute a `Token` encompassing
         * the whole input range enclosed by these two.
         */
        range(endToken, text4) {
          return new _Token(text4, SourceLocation.range(this, endToken));
        }
      };
      ParseError = class _ParseError {
        static {
          __name(this, "ParseError");
        }
        // Error start position based on passed-in Token or ParseNode.
        // Length of affected text based on passed-in Token or ParseNode.
        // The underlying error message without any context added.
        constructor(message, token2) {
          this.name = void 0;
          this.position = void 0;
          this.length = void 0;
          this.rawMessage = void 0;
          var error3 = "KaTeX parse error: " + message;
          var start3;
          var end2;
          var loc = token2 && token2.loc;
          if (loc && loc.start <= loc.end) {
            var input = loc.lexer.input;
            start3 = loc.start;
            end2 = loc.end;
            if (start3 === input.length) {
              error3 += " at end of input: ";
            } else {
              error3 += " at position " + (start3 + 1) + ": ";
            }
            var underlined = input.slice(start3, end2).replace(/[^]/g, "$&\u0332");
            var left3;
            if (start3 > 15) {
              left3 = "\u2026" + input.slice(start3 - 15, start3);
            } else {
              left3 = input.slice(0, start3);
            }
            var right3;
            if (end2 + 15 < input.length) {
              right3 = input.slice(end2, end2 + 15) + "\u2026";
            } else {
              right3 = input.slice(end2);
            }
            error3 += left3 + underlined + right3;
          }
          var self2 = new Error(error3);
          self2.name = "ParseError";
          self2.__proto__ = _ParseError.prototype;
          self2.position = start3;
          if (start3 != null && end2 != null) {
            self2.length = end2 - start3;
          }
          self2.rawMessage = message;
          return self2;
        }
      };
      ParseError.prototype.__proto__ = Error.prototype;
      contains = /* @__PURE__ */ __name(function contains2(list2, elem) {
        return list2.indexOf(elem) !== -1;
      }, "contains");
      deflt = /* @__PURE__ */ __name(function deflt2(setting, defaultIfUndefined) {
        return setting === void 0 ? defaultIfUndefined : setting;
      }, "deflt");
      uppercase = /([A-Z])/g;
      hyphenate = /* @__PURE__ */ __name(function hyphenate2(str2) {
        return str2.replace(uppercase, "-$1").toLowerCase();
      }, "hyphenate");
      ESCAPE_LOOKUP = {
        "&": "&amp;",
        ">": "&gt;",
        "<": "&lt;",
        '"': "&quot;",
        "'": "&#x27;"
      };
      ESCAPE_REGEX = /[&><"']/g;
      __name(escape2, "escape");
      getBaseElem = /* @__PURE__ */ __name(function getBaseElem2(group2) {
        if (group2.type === "ordgroup") {
          if (group2.body.length === 1) {
            return getBaseElem2(group2.body[0]);
          } else {
            return group2;
          }
        } else if (group2.type === "color") {
          if (group2.body.length === 1) {
            return getBaseElem2(group2.body[0]);
          } else {
            return group2;
          }
        } else if (group2.type === "font") {
          return getBaseElem2(group2.body);
        } else {
          return group2;
        }
      }, "getBaseElem");
      isCharacterBox = /* @__PURE__ */ __name(function isCharacterBox2(group2) {
        var baseElem = getBaseElem(group2);
        return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
      }, "isCharacterBox");
      assert = /* @__PURE__ */ __name(function assert2(value2) {
        if (!value2) {
          throw new Error("Expected non-null, but got " + String(value2));
        }
        return value2;
      }, "assert");
      protocolFromUrl = /* @__PURE__ */ __name(function protocolFromUrl2(url) {
        var protocol = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(url);
        if (!protocol) {
          return "_relative";
        }
        if (protocol[2] !== ":") {
          return null;
        }
        if (!/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(protocol[1])) {
          return null;
        }
        return protocol[1].toLowerCase();
      }, "protocolFromUrl");
      utils = {
        contains,
        deflt,
        escape: escape2,
        hyphenate,
        getBaseElem,
        isCharacterBox,
        protocolFromUrl
      };
      SETTINGS_SCHEMA = {
        displayMode: {
          type: "boolean",
          description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
          cli: "-d, --display-mode"
        },
        output: {
          type: {
            enum: ["htmlAndMathml", "html", "mathml"]
          },
          description: "Determines the markup language of the output.",
          cli: "-F, --format <type>"
        },
        leqno: {
          type: "boolean",
          description: "Render display math in leqno style (left-justified tags)."
        },
        fleqn: {
          type: "boolean",
          description: "Render display math flush left."
        },
        throwOnError: {
          type: "boolean",
          default: true,
          cli: "-t, --no-throw-on-error",
          cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
        },
        errorColor: {
          type: "string",
          default: "#cc0000",
          cli: "-c, --error-color <color>",
          cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
          cliProcessor: /* @__PURE__ */ __name((color2) => "#" + color2, "cliProcessor")
        },
        macros: {
          type: "object",
          cli: "-m, --macro <def>",
          cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
          cliDefault: [],
          cliProcessor: /* @__PURE__ */ __name((def2, defs2) => {
            defs2.push(def2);
            return defs2;
          }, "cliProcessor")
        },
        minRuleThickness: {
          type: "number",
          description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
          processor: /* @__PURE__ */ __name((t4) => Math.max(0, t4), "processor"),
          cli: "--min-rule-thickness <size>",
          cliProcessor: parseFloat
        },
        colorIsTextColor: {
          type: "boolean",
          description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
          cli: "-b, --color-is-text-color"
        },
        strict: {
          type: [{
            enum: ["warn", "ignore", "error"]
          }, "boolean", "function"],
          description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
          cli: "-S, --strict",
          cliDefault: false
        },
        trust: {
          type: ["boolean", "function"],
          description: "Trust the input, enabling all HTML features such as \\url.",
          cli: "-T, --trust"
        },
        maxSize: {
          type: "number",
          default: Infinity,
          description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
          processor: /* @__PURE__ */ __name((s2) => Math.max(0, s2), "processor"),
          cli: "-s, --max-size <n>",
          cliProcessor: parseInt
        },
        maxExpand: {
          type: "number",
          default: 1e3,
          description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
          processor: /* @__PURE__ */ __name((n2) => Math.max(0, n2), "processor"),
          cli: "-e, --max-expand <n>",
          cliProcessor: /* @__PURE__ */ __name((n2) => n2 === "Infinity" ? Infinity : parseInt(n2), "cliProcessor")
        },
        globalGroup: {
          type: "boolean",
          cli: false
        }
      };
      __name(getDefaultValue, "getDefaultValue");
      Settings = class {
        static {
          __name(this, "Settings");
        }
        constructor(options3) {
          this.displayMode = void 0;
          this.output = void 0;
          this.leqno = void 0;
          this.fleqn = void 0;
          this.throwOnError = void 0;
          this.errorColor = void 0;
          this.macros = void 0;
          this.minRuleThickness = void 0;
          this.colorIsTextColor = void 0;
          this.strict = void 0;
          this.trust = void 0;
          this.maxSize = void 0;
          this.maxExpand = void 0;
          this.globalGroup = void 0;
          options3 = options3 || {};
          for (var prop in SETTINGS_SCHEMA) {
            if (SETTINGS_SCHEMA.hasOwnProperty(prop)) {
              var schema2 = SETTINGS_SCHEMA[prop];
              this[prop] = options3[prop] !== void 0 ? schema2.processor ? schema2.processor(options3[prop]) : options3[prop] : getDefaultValue(schema2);
            }
          }
        }
        /**
         * Report nonstrict (non-LaTeX-compatible) input.
         * Can safely not be called if `this.strict` is false in JavaScript.
         */
        reportNonstrict(errorCode, errorMsg, token2) {
          var strict = this.strict;
          if (typeof strict === "function") {
            strict = strict(errorCode, errorMsg, token2);
          }
          if (!strict || strict === "ignore") {
            return;
          } else if (strict === true || strict === "error") {
            throw new ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token2);
          } else if (strict === "warn") {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
          } else {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
          }
        }
        /**
         * Check whether to apply strict (LaTeX-adhering) behavior for unusual
         * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
         * instead, "error" translates to a return value of `true`, while "ignore"
         * translates to a return value of `false`.  May still print a warning:
         * "warn" prints a warning and returns `false`.
         * This is for the second category of `errorCode`s listed in the README.
         */
        useStrictBehavior(errorCode, errorMsg, token2) {
          var strict = this.strict;
          if (typeof strict === "function") {
            try {
              strict = strict(errorCode, errorMsg, token2);
            } catch (error3) {
              strict = "error";
            }
          }
          if (!strict || strict === "ignore") {
            return false;
          } else if (strict === true || strict === "error") {
            return true;
          } else if (strict === "warn") {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
            return false;
          } else {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
            return false;
          }
        }
        /**
         * Check whether to test potentially dangerous input, and return
         * `true` (trusted) or `false` (untrusted).  The sole argument `context`
         * should be an object with `command` field specifying the relevant LaTeX
         * command (as a string starting with `\`), and any other arguments, etc.
         * If `context` has a `url` field, a `protocol` field will automatically
         * get added by this function (changing the specified object).
         */
        isTrusted(context) {
          if (context.url && !context.protocol) {
            var protocol = utils.protocolFromUrl(context.url);
            if (protocol == null) {
              return false;
            }
            context.protocol = protocol;
          }
          var trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
          return Boolean(trust);
        }
      };
      Style = class {
        static {
          __name(this, "Style");
        }
        constructor(id28, size5, cramped) {
          this.id = void 0;
          this.size = void 0;
          this.cramped = void 0;
          this.id = id28;
          this.size = size5;
          this.cramped = cramped;
        }
        /**
         * Get the style of a superscript given a base in the current style.
         */
        sup() {
          return styles[sup[this.id]];
        }
        /**
         * Get the style of a subscript given a base in the current style.
         */
        sub() {
          return styles[sub[this.id]];
        }
        /**
         * Get the style of a fraction numerator given the fraction in the current
         * style.
         */
        fracNum() {
          return styles[fracNum[this.id]];
        }
        /**
         * Get the style of a fraction denominator given the fraction in the current
         * style.
         */
        fracDen() {
          return styles[fracDen[this.id]];
        }
        /**
         * Get the cramped version of a style (in particular, cramping a cramped style
         * doesn't change the style).
         */
        cramp() {
          return styles[cramp[this.id]];
        }
        /**
         * Get a text or display version of this style.
         */
        text() {
          return styles[text$1[this.id]];
        }
        /**
         * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
         */
        isTight() {
          return this.size >= 2;
        }
      };
      D = 0;
      Dc = 1;
      T = 2;
      Tc = 3;
      S = 4;
      Sc = 5;
      SS = 6;
      SSc = 7;
      styles = [new Style(D, 0, false), new Style(Dc, 0, true), new Style(T, 1, false), new Style(Tc, 1, true), new Style(S, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)];
      sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
      sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
      fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];
      fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
      cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
      text$1 = [D, Dc, T, Tc, T, Tc, T, Tc];
      Style$1 = {
        DISPLAY: styles[D],
        TEXT: styles[T],
        SCRIPT: styles[S],
        SCRIPTSCRIPT: styles[SS]
      };
      scriptData = [{
        // Latin characters beyond the Latin-1 characters we have metrics for.
        // Needed for Czech, Hungarian and Turkish text, for example.
        name: "latin",
        blocks: [
          [256, 591],
          // Latin Extended-A and Latin Extended-B
          [768, 879]
          // Combining Diacritical marks
        ]
      }, {
        // The Cyrillic script used by Russian and related languages.
        // A Cyrillic subset used to be supported as explicitly defined
        // symbols in symbols.js
        name: "cyrillic",
        blocks: [[1024, 1279]]
      }, {
        // Armenian
        name: "armenian",
        blocks: [[1328, 1423]]
      }, {
        // The Brahmic scripts of South and Southeast Asia
        // Devanagari (0900–097F)
        // Bengali (0980–09FF)
        // Gurmukhi (0A00–0A7F)
        // Gujarati (0A80–0AFF)
        // Oriya (0B00–0B7F)
        // Tamil (0B80–0BFF)
        // Telugu (0C00–0C7F)
        // Kannada (0C80–0CFF)
        // Malayalam (0D00–0D7F)
        // Sinhala (0D80–0DFF)
        // Thai (0E00–0E7F)
        // Lao (0E80–0EFF)
        // Tibetan (0F00–0FFF)
        // Myanmar (1000–109F)
        name: "brahmic",
        blocks: [[2304, 4255]]
      }, {
        name: "georgian",
        blocks: [[4256, 4351]]
      }, {
        // Chinese and Japanese.
        // The "k" in cjk is for Korean, but we've separated Korean out
        name: "cjk",
        blocks: [
          [12288, 12543],
          // CJK symbols and punctuation, Hiragana, Katakana
          [19968, 40879],
          // CJK ideograms
          [65280, 65376]
          // Fullwidth punctuation
          // TODO: add halfwidth Katakana and Romanji glyphs
        ]
      }, {
        // Korean
        name: "hangul",
        blocks: [[44032, 55215]]
      }];
      __name(scriptFromCodepoint, "scriptFromCodepoint");
      allBlocks = [];
      scriptData.forEach((s2) => s2.blocks.forEach((b2) => allBlocks.push(...b2)));
      __name(supportedCodepoint, "supportedCodepoint");
      hLinePad = 80;
      sqrtMain = /* @__PURE__ */ __name(function sqrtMain2(extraVinculum, hLinePad2) {
        return "M95," + (622 + extraVinculum + hLinePad2) + "\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl" + extraVinculum / 2.075 + " -" + extraVinculum + "\nc5.3,-9.3,12,-14,20,-14\nH400000v" + (40 + extraVinculum) + "H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM" + (834 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
      }, "sqrtMain");
      sqrtSize1 = /* @__PURE__ */ __name(function sqrtSize12(extraVinculum, hLinePad2) {
        return "M263," + (601 + extraVinculum + hLinePad2) + "c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl" + extraVinculum / 2.084 + " -" + extraVinculum + "\nc4.7,-7.3,11,-11,19,-11\nH40000v" + (40 + extraVinculum) + "H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
      }, "sqrtSize1");
      sqrtSize2 = /* @__PURE__ */ __name(function sqrtSize22(extraVinculum, hLinePad2) {
        return "M983 " + (10 + extraVinculum + hLinePad2) + "\nl" + extraVinculum / 3.13 + " -" + extraVinculum + "\nc4,-6.7,10,-10,18,-10 H400000v" + (40 + extraVinculum) + "\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
      }, "sqrtSize2");
      sqrtSize3 = /* @__PURE__ */ __name(function sqrtSize32(extraVinculum, hLinePad2) {
        return "M424," + (2398 + extraVinculum + hLinePad2) + "\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl" + extraVinculum / 4.223 + " -" + extraVinculum + "c4,-6.7,10,-10,18,-10 H400000\nv" + (40 + extraVinculum) + "H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M" + (1001 + extraVinculum) + " " + hLinePad2 + "\nh400000v" + (40 + extraVinculum) + "h-400000z";
      }, "sqrtSize3");
      sqrtSize4 = /* @__PURE__ */ __name(function sqrtSize42(extraVinculum, hLinePad2) {
        return "M473," + (2713 + extraVinculum + hLinePad2) + "\nc339.3,-1799.3,509.3,-2700,510,-2702 l" + extraVinculum / 5.298 + " -" + extraVinculum + "\nc3.3,-7.3,9.3,-11,18,-11 H400000v" + (40 + extraVinculum) + "H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "H1017.7z";
      }, "sqrtSize4");
      phasePath = /* @__PURE__ */ __name(function phasePath2(y5) {
        var x5 = y5 / 2;
        return "M400000 " + y5 + " H0 L" + x5 + " 0 l65 45 L145 " + (y5 - 80) + " H400000z";
      }, "phasePath");
      sqrtTall = /* @__PURE__ */ __name(function sqrtTall2(extraVinculum, hLinePad2, viewBoxHeight) {
        var vertSegment = viewBoxHeight - 54 - hLinePad2 - extraVinculum;
        return "M702 " + (extraVinculum + hLinePad2) + "H400000" + (40 + extraVinculum) + "\nH742v" + vertSegment + "l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 " + hLinePad2 + "H400000v" + (40 + extraVinculum) + "H742z";
      }, "sqrtTall");
      sqrtPath = /* @__PURE__ */ __name(function sqrtPath2(size5, extraVinculum, viewBoxHeight) {
        extraVinculum = 1e3 * extraVinculum;
        var path4 = "";
        switch (size5) {
          case "sqrtMain":
            path4 = sqrtMain(extraVinculum, hLinePad);
            break;
          case "sqrtSize1":
            path4 = sqrtSize1(extraVinculum, hLinePad);
            break;
          case "sqrtSize2":
            path4 = sqrtSize2(extraVinculum, hLinePad);
            break;
          case "sqrtSize3":
            path4 = sqrtSize3(extraVinculum, hLinePad);
            break;
          case "sqrtSize4":
            path4 = sqrtSize4(extraVinculum, hLinePad);
            break;
          case "sqrtTall":
            path4 = sqrtTall(extraVinculum, hLinePad, viewBoxHeight);
        }
        return path4;
      }, "sqrtPath");
      innerPath = /* @__PURE__ */ __name(function innerPath2(name, height2) {
        switch (name) {
          case "\u239C":
            return "M291 0 H417 V" + height2 + " H291z M291 0 H417 V" + height2 + " H291z";
          case "\u2223":
            return "M145 0 H188 V" + height2 + " H145z M145 0 H188 V" + height2 + " H145z";
          case "\u2225":
            return "M145 0 H188 V" + height2 + " H145z M145 0 H188 V" + height2 + " H145z" + ("M367 0 H410 V" + height2 + " H367z M367 0 H410 V" + height2 + " H367z");
          case "\u239F":
            return "M457 0 H583 V" + height2 + " H457z M457 0 H583 V" + height2 + " H457z";
          case "\u23A2":
            return "M319 0 H403 V" + height2 + " H319z M319 0 H403 V" + height2 + " H319z";
          case "\u23A5":
            return "M263 0 H347 V" + height2 + " H263z M263 0 H347 V" + height2 + " H263z";
          case "\u23AA":
            return "M384 0 H504 V" + height2 + " H384z M384 0 H504 V" + height2 + " H384z";
          case "\u23D0":
            return "M312 0 H355 V" + height2 + " H312z M312 0 H355 V" + height2 + " H312z";
          case "\u2016":
            return "M257 0 H300 V" + height2 + " H257z M257 0 H300 V" + height2 + " H257z" + ("M478 0 H521 V" + height2 + " H478z M478 0 H521 V" + height2 + " H478z");
          default:
            return "";
        }
      }, "innerPath");
      path = {
        // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
        doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
        // doublerightarrow is from glyph U+21D2 in font KaTeX Main
        doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
        // leftarrow is from glyph U+2190 in font KaTeX Main
        leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
        // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
        leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
        leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
        // overgroup is from the MnSymbol package (public domain)
        leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
        leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
        // Harpoons are from glyph U+21BD in font KaTeX Main
        leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
        leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
        leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
        leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
        // hook is from glyph U+21A9 in font KaTeX Main
        lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
        leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
        leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
        // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
        leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
        longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
        midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
        midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
        oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
        oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
        oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
        oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
        rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
        rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
        rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
        rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
        rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
        rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
        rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
        rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
        rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
        righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
        rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
        rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
        // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
        twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
        twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
        // tilde1 is a modified version of a glyph from the MnSymbol package
        tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
        // ditto tilde2, tilde3, & tilde4
        tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
        tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
        tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
        // vec is from glyph U+20D7 in font KaTeX Main
        vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
        // widehat1 is a modified version of a glyph from the MnSymbol package
        widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
        // ditto widehat2, widehat3, & widehat4
        widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
        widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
        widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
        // widecheck paths are all inverted versions of widehat
        widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
        widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
        widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
        widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
        // The next ten paths support reaction arrows from the mhchem package.
        // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
        // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
        baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
        // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
        rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
        // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
        // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
        baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
        rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
        shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
        shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
      };
      tallDelim = /* @__PURE__ */ __name(function tallDelim2(label, midHeight) {
        switch (label) {
          case "lbrack":
            return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v1759 h347 v-84\nH403z M403 1759 V0 H319 V1759 v" + midHeight + " v1759 h84z";
          case "rbrack":
            return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v1759 H0 v84 H347z\nM347 1759 V0 H263 V1759 v" + midHeight + " v1759 h84z";
          case "vert":
            return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z";
          case "doublevert":
            return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z\nM367 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M410 15 H367 v585 v" + midHeight + " v585 h43z";
          case "lfloor":
            return "M319 602 V0 H403 V602 v" + midHeight + " v1715 h263 v84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
          case "rfloor":
            return "M319 602 V0 H403 V602 v" + midHeight + " v1799 H0 v-84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
          case "lceil":
            return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v602 h84z\nM403 1759 V0 H319 V1759 v" + midHeight + " v602 h84z";
          case "rceil":
            return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v602 h84z\nM347 1759 V0 h-84 V1759 v" + midHeight + " v602 h84z";
          case "lparen":
            return "M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1\nc-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,\n-36,557 l0," + (midHeight + 84) + "c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,\n949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9\nc0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,\n-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189\nl0,-" + (midHeight + 92) + "c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,\n-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z";
          case "rparen":
            return "M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,\n63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5\nc11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0," + (midHeight + 9) + "\nc-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664\nc-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11\nc0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17\nc242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558\nl0,-" + (midHeight + 144) + "c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,\n-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z";
          default:
            throw new Error("Unknown stretchy delimiter.");
        }
      }, "tallDelim");
      DocumentFragment = class {
        static {
          __name(this, "DocumentFragment");
        }
        // HtmlDomNode
        // Never used; needed for satisfying interface.
        constructor(children2) {
          this.children = void 0;
          this.classes = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.maxFontSize = void 0;
          this.style = void 0;
          this.children = children2;
          this.classes = [];
          this.height = 0;
          this.depth = 0;
          this.maxFontSize = 0;
          this.style = {};
        }
        hasClass(className) {
          return utils.contains(this.classes, className);
        }
        /** Convert the fragment into a node. */
        toNode() {
          var frag = document.createDocumentFragment();
          for (var i2 = 0; i2 < this.children.length; i2++) {
            frag.appendChild(this.children[i2].toNode());
          }
          return frag;
        }
        /** Convert the fragment into HTML markup. */
        toMarkup() {
          var markup = "";
          for (var i2 = 0; i2 < this.children.length; i2++) {
            markup += this.children[i2].toMarkup();
          }
          return markup;
        }
        /**
         * Converts the math node into a string, similar to innerText. Applies to
         * MathDomNode's only.
         */
        toText() {
          var toText = /* @__PURE__ */ __name((child) => child.toText(), "toText");
          return this.children.map(toText).join("");
        }
      };
      fontMetricsData = {
        "AMS-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "65": [0, 0.68889, 0, 0, 0.72222],
          "66": [0, 0.68889, 0, 0, 0.66667],
          "67": [0, 0.68889, 0, 0, 0.72222],
          "68": [0, 0.68889, 0, 0, 0.72222],
          "69": [0, 0.68889, 0, 0, 0.66667],
          "70": [0, 0.68889, 0, 0, 0.61111],
          "71": [0, 0.68889, 0, 0, 0.77778],
          "72": [0, 0.68889, 0, 0, 0.77778],
          "73": [0, 0.68889, 0, 0, 0.38889],
          "74": [0.16667, 0.68889, 0, 0, 0.5],
          "75": [0, 0.68889, 0, 0, 0.77778],
          "76": [0, 0.68889, 0, 0, 0.66667],
          "77": [0, 0.68889, 0, 0, 0.94445],
          "78": [0, 0.68889, 0, 0, 0.72222],
          "79": [0.16667, 0.68889, 0, 0, 0.77778],
          "80": [0, 0.68889, 0, 0, 0.61111],
          "81": [0.16667, 0.68889, 0, 0, 0.77778],
          "82": [0, 0.68889, 0, 0, 0.72222],
          "83": [0, 0.68889, 0, 0, 0.55556],
          "84": [0, 0.68889, 0, 0, 0.66667],
          "85": [0, 0.68889, 0, 0, 0.72222],
          "86": [0, 0.68889, 0, 0, 0.72222],
          "87": [0, 0.68889, 0, 0, 1],
          "88": [0, 0.68889, 0, 0, 0.72222],
          "89": [0, 0.68889, 0, 0, 0.72222],
          "90": [0, 0.68889, 0, 0, 0.66667],
          "107": [0, 0.68889, 0, 0, 0.55556],
          "160": [0, 0, 0, 0, 0.25],
          "165": [0, 0.675, 0.025, 0, 0.75],
          "174": [0.15559, 0.69224, 0, 0, 0.94666],
          "240": [0, 0.68889, 0, 0, 0.55556],
          "295": [0, 0.68889, 0, 0, 0.54028],
          "710": [0, 0.825, 0, 0, 2.33334],
          "732": [0, 0.9, 0, 0, 2.33334],
          "770": [0, 0.825, 0, 0, 2.33334],
          "771": [0, 0.9, 0, 0, 2.33334],
          "989": [0.08167, 0.58167, 0, 0, 0.77778],
          "1008": [0, 0.43056, 0.04028, 0, 0.66667],
          "8245": [0, 0.54986, 0, 0, 0.275],
          "8463": [0, 0.68889, 0, 0, 0.54028],
          "8487": [0, 0.68889, 0, 0, 0.72222],
          "8498": [0, 0.68889, 0, 0, 0.55556],
          "8502": [0, 0.68889, 0, 0, 0.66667],
          "8503": [0, 0.68889, 0, 0, 0.44445],
          "8504": [0, 0.68889, 0, 0, 0.66667],
          "8513": [0, 0.68889, 0, 0, 0.63889],
          "8592": [-0.03598, 0.46402, 0, 0, 0.5],
          "8594": [-0.03598, 0.46402, 0, 0, 0.5],
          "8602": [-0.13313, 0.36687, 0, 0, 1],
          "8603": [-0.13313, 0.36687, 0, 0, 1],
          "8606": [0.01354, 0.52239, 0, 0, 1],
          "8608": [0.01354, 0.52239, 0, 0, 1],
          "8610": [0.01354, 0.52239, 0, 0, 1.11111],
          "8611": [0.01354, 0.52239, 0, 0, 1.11111],
          "8619": [0, 0.54986, 0, 0, 1],
          "8620": [0, 0.54986, 0, 0, 1],
          "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
          "8622": [-0.13313, 0.36687, 0, 0, 1],
          "8624": [0, 0.69224, 0, 0, 0.5],
          "8625": [0, 0.69224, 0, 0, 0.5],
          "8630": [0, 0.43056, 0, 0, 1],
          "8631": [0, 0.43056, 0, 0, 1],
          "8634": [0.08198, 0.58198, 0, 0, 0.77778],
          "8635": [0.08198, 0.58198, 0, 0, 0.77778],
          "8638": [0.19444, 0.69224, 0, 0, 0.41667],
          "8639": [0.19444, 0.69224, 0, 0, 0.41667],
          "8642": [0.19444, 0.69224, 0, 0, 0.41667],
          "8643": [0.19444, 0.69224, 0, 0, 0.41667],
          "8644": [0.1808, 0.675, 0, 0, 1],
          "8646": [0.1808, 0.675, 0, 0, 1],
          "8647": [0.1808, 0.675, 0, 0, 1],
          "8648": [0.19444, 0.69224, 0, 0, 0.83334],
          "8649": [0.1808, 0.675, 0, 0, 1],
          "8650": [0.19444, 0.69224, 0, 0, 0.83334],
          "8651": [0.01354, 0.52239, 0, 0, 1],
          "8652": [0.01354, 0.52239, 0, 0, 1],
          "8653": [-0.13313, 0.36687, 0, 0, 1],
          "8654": [-0.13313, 0.36687, 0, 0, 1],
          "8655": [-0.13313, 0.36687, 0, 0, 1],
          "8666": [0.13667, 0.63667, 0, 0, 1],
          "8667": [0.13667, 0.63667, 0, 0, 1],
          "8669": [-0.13313, 0.37788, 0, 0, 1],
          "8672": [-0.064, 0.437, 0, 0, 1.334],
          "8674": [-0.064, 0.437, 0, 0, 1.334],
          "8705": [0, 0.825, 0, 0, 0.5],
          "8708": [0, 0.68889, 0, 0, 0.55556],
          "8709": [0.08167, 0.58167, 0, 0, 0.77778],
          "8717": [0, 0.43056, 0, 0, 0.42917],
          "8722": [-0.03598, 0.46402, 0, 0, 0.5],
          "8724": [0.08198, 0.69224, 0, 0, 0.77778],
          "8726": [0.08167, 0.58167, 0, 0, 0.77778],
          "8733": [0, 0.69224, 0, 0, 0.77778],
          "8736": [0, 0.69224, 0, 0, 0.72222],
          "8737": [0, 0.69224, 0, 0, 0.72222],
          "8738": [0.03517, 0.52239, 0, 0, 0.72222],
          "8739": [0.08167, 0.58167, 0, 0, 0.22222],
          "8740": [0.25142, 0.74111, 0, 0, 0.27778],
          "8741": [0.08167, 0.58167, 0, 0, 0.38889],
          "8742": [0.25142, 0.74111, 0, 0, 0.5],
          "8756": [0, 0.69224, 0, 0, 0.66667],
          "8757": [0, 0.69224, 0, 0, 0.66667],
          "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
          "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
          "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
          "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8774": [0.30274, 0.79383, 0, 0, 0.77778],
          "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
          "8778": [0.08167, 0.58167, 0, 0, 0.77778],
          "8782": [0.06062, 0.54986, 0, 0, 0.77778],
          "8783": [0.06062, 0.54986, 0, 0, 0.77778],
          "8785": [0.08198, 0.58198, 0, 0, 0.77778],
          "8786": [0.08198, 0.58198, 0, 0, 0.77778],
          "8787": [0.08198, 0.58198, 0, 0, 0.77778],
          "8790": [0, 0.69224, 0, 0, 0.77778],
          "8791": [0.22958, 0.72958, 0, 0, 0.77778],
          "8796": [0.08198, 0.91667, 0, 0, 0.77778],
          "8806": [0.25583, 0.75583, 0, 0, 0.77778],
          "8807": [0.25583, 0.75583, 0, 0, 0.77778],
          "8808": [0.25142, 0.75726, 0, 0, 0.77778],
          "8809": [0.25142, 0.75726, 0, 0, 0.77778],
          "8812": [0.25583, 0.75583, 0, 0, 0.5],
          "8814": [0.20576, 0.70576, 0, 0, 0.77778],
          "8815": [0.20576, 0.70576, 0, 0, 0.77778],
          "8816": [0.30274, 0.79383, 0, 0, 0.77778],
          "8817": [0.30274, 0.79383, 0, 0, 0.77778],
          "8818": [0.22958, 0.72958, 0, 0, 0.77778],
          "8819": [0.22958, 0.72958, 0, 0, 0.77778],
          "8822": [0.1808, 0.675, 0, 0, 0.77778],
          "8823": [0.1808, 0.675, 0, 0, 0.77778],
          "8828": [0.13667, 0.63667, 0, 0, 0.77778],
          "8829": [0.13667, 0.63667, 0, 0, 0.77778],
          "8830": [0.22958, 0.72958, 0, 0, 0.77778],
          "8831": [0.22958, 0.72958, 0, 0, 0.77778],
          "8832": [0.20576, 0.70576, 0, 0, 0.77778],
          "8833": [0.20576, 0.70576, 0, 0, 0.77778],
          "8840": [0.30274, 0.79383, 0, 0, 0.77778],
          "8841": [0.30274, 0.79383, 0, 0, 0.77778],
          "8842": [0.13597, 0.63597, 0, 0, 0.77778],
          "8843": [0.13597, 0.63597, 0, 0, 0.77778],
          "8847": [0.03517, 0.54986, 0, 0, 0.77778],
          "8848": [0.03517, 0.54986, 0, 0, 0.77778],
          "8858": [0.08198, 0.58198, 0, 0, 0.77778],
          "8859": [0.08198, 0.58198, 0, 0, 0.77778],
          "8861": [0.08198, 0.58198, 0, 0, 0.77778],
          "8862": [0, 0.675, 0, 0, 0.77778],
          "8863": [0, 0.675, 0, 0, 0.77778],
          "8864": [0, 0.675, 0, 0, 0.77778],
          "8865": [0, 0.675, 0, 0, 0.77778],
          "8872": [0, 0.69224, 0, 0, 0.61111],
          "8873": [0, 0.69224, 0, 0, 0.72222],
          "8874": [0, 0.69224, 0, 0, 0.88889],
          "8876": [0, 0.68889, 0, 0, 0.61111],
          "8877": [0, 0.68889, 0, 0, 0.61111],
          "8878": [0, 0.68889, 0, 0, 0.72222],
          "8879": [0, 0.68889, 0, 0, 0.72222],
          "8882": [0.03517, 0.54986, 0, 0, 0.77778],
          "8883": [0.03517, 0.54986, 0, 0, 0.77778],
          "8884": [0.13667, 0.63667, 0, 0, 0.77778],
          "8885": [0.13667, 0.63667, 0, 0, 0.77778],
          "8888": [0, 0.54986, 0, 0, 1.11111],
          "8890": [0.19444, 0.43056, 0, 0, 0.55556],
          "8891": [0.19444, 0.69224, 0, 0, 0.61111],
          "8892": [0.19444, 0.69224, 0, 0, 0.61111],
          "8901": [0, 0.54986, 0, 0, 0.27778],
          "8903": [0.08167, 0.58167, 0, 0, 0.77778],
          "8905": [0.08167, 0.58167, 0, 0, 0.77778],
          "8906": [0.08167, 0.58167, 0, 0, 0.77778],
          "8907": [0, 0.69224, 0, 0, 0.77778],
          "8908": [0, 0.69224, 0, 0, 0.77778],
          "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
          "8910": [0, 0.54986, 0, 0, 0.76042],
          "8911": [0, 0.54986, 0, 0, 0.76042],
          "8912": [0.03517, 0.54986, 0, 0, 0.77778],
          "8913": [0.03517, 0.54986, 0, 0, 0.77778],
          "8914": [0, 0.54986, 0, 0, 0.66667],
          "8915": [0, 0.54986, 0, 0, 0.66667],
          "8916": [0, 0.69224, 0, 0, 0.66667],
          "8918": [0.0391, 0.5391, 0, 0, 0.77778],
          "8919": [0.0391, 0.5391, 0, 0, 0.77778],
          "8920": [0.03517, 0.54986, 0, 0, 1.33334],
          "8921": [0.03517, 0.54986, 0, 0, 1.33334],
          "8922": [0.38569, 0.88569, 0, 0, 0.77778],
          "8923": [0.38569, 0.88569, 0, 0, 0.77778],
          "8926": [0.13667, 0.63667, 0, 0, 0.77778],
          "8927": [0.13667, 0.63667, 0, 0, 0.77778],
          "8928": [0.30274, 0.79383, 0, 0, 0.77778],
          "8929": [0.30274, 0.79383, 0, 0, 0.77778],
          "8934": [0.23222, 0.74111, 0, 0, 0.77778],
          "8935": [0.23222, 0.74111, 0, 0, 0.77778],
          "8936": [0.23222, 0.74111, 0, 0, 0.77778],
          "8937": [0.23222, 0.74111, 0, 0, 0.77778],
          "8938": [0.20576, 0.70576, 0, 0, 0.77778],
          "8939": [0.20576, 0.70576, 0, 0, 0.77778],
          "8940": [0.30274, 0.79383, 0, 0, 0.77778],
          "8941": [0.30274, 0.79383, 0, 0, 0.77778],
          "8994": [0.19444, 0.69224, 0, 0, 0.77778],
          "8995": [0.19444, 0.69224, 0, 0, 0.77778],
          "9416": [0.15559, 0.69224, 0, 0, 0.90222],
          "9484": [0, 0.69224, 0, 0, 0.5],
          "9488": [0, 0.69224, 0, 0, 0.5],
          "9492": [0, 0.37788, 0, 0, 0.5],
          "9496": [0, 0.37788, 0, 0, 0.5],
          "9585": [0.19444, 0.68889, 0, 0, 0.88889],
          "9586": [0.19444, 0.74111, 0, 0, 0.88889],
          "9632": [0, 0.675, 0, 0, 0.77778],
          "9633": [0, 0.675, 0, 0, 0.77778],
          "9650": [0, 0.54986, 0, 0, 0.72222],
          "9651": [0, 0.54986, 0, 0, 0.72222],
          "9654": [0.03517, 0.54986, 0, 0, 0.77778],
          "9660": [0, 0.54986, 0, 0, 0.72222],
          "9661": [0, 0.54986, 0, 0, 0.72222],
          "9664": [0.03517, 0.54986, 0, 0, 0.77778],
          "9674": [0.11111, 0.69224, 0, 0, 0.66667],
          "9733": [0.19444, 0.69224, 0, 0, 0.94445],
          "10003": [0, 0.69224, 0, 0, 0.83334],
          "10016": [0, 0.69224, 0, 0, 0.83334],
          "10731": [0.11111, 0.69224, 0, 0, 0.66667],
          "10846": [0.19444, 0.75583, 0, 0, 0.61111],
          "10877": [0.13667, 0.63667, 0, 0, 0.77778],
          "10878": [0.13667, 0.63667, 0, 0, 0.77778],
          "10885": [0.25583, 0.75583, 0, 0, 0.77778],
          "10886": [0.25583, 0.75583, 0, 0, 0.77778],
          "10887": [0.13597, 0.63597, 0, 0, 0.77778],
          "10888": [0.13597, 0.63597, 0, 0, 0.77778],
          "10889": [0.26167, 0.75726, 0, 0, 0.77778],
          "10890": [0.26167, 0.75726, 0, 0, 0.77778],
          "10891": [0.48256, 0.98256, 0, 0, 0.77778],
          "10892": [0.48256, 0.98256, 0, 0, 0.77778],
          "10901": [0.13667, 0.63667, 0, 0, 0.77778],
          "10902": [0.13667, 0.63667, 0, 0, 0.77778],
          "10933": [0.25142, 0.75726, 0, 0, 0.77778],
          "10934": [0.25142, 0.75726, 0, 0, 0.77778],
          "10935": [0.26167, 0.75726, 0, 0, 0.77778],
          "10936": [0.26167, 0.75726, 0, 0, 0.77778],
          "10937": [0.26167, 0.75726, 0, 0, 0.77778],
          "10938": [0.26167, 0.75726, 0, 0, 0.77778],
          "10949": [0.25583, 0.75583, 0, 0, 0.77778],
          "10950": [0.25583, 0.75583, 0, 0, 0.77778],
          "10955": [0.28481, 0.79383, 0, 0, 0.77778],
          "10956": [0.28481, 0.79383, 0, 0, 0.77778],
          "57350": [0.08167, 0.58167, 0, 0, 0.22222],
          "57351": [0.08167, 0.58167, 0, 0, 0.38889],
          "57352": [0.08167, 0.58167, 0, 0, 0.77778],
          "57353": [0, 0.43056, 0.04028, 0, 0.66667],
          "57356": [0.25142, 0.75726, 0, 0, 0.77778],
          "57357": [0.25142, 0.75726, 0, 0, 0.77778],
          "57358": [0.41951, 0.91951, 0, 0, 0.77778],
          "57359": [0.30274, 0.79383, 0, 0, 0.77778],
          "57360": [0.30274, 0.79383, 0, 0, 0.77778],
          "57361": [0.41951, 0.91951, 0, 0, 0.77778],
          "57366": [0.25142, 0.75726, 0, 0, 0.77778],
          "57367": [0.25142, 0.75726, 0, 0, 0.77778],
          "57368": [0.25142, 0.75726, 0, 0, 0.77778],
          "57369": [0.25142, 0.75726, 0, 0, 0.77778],
          "57370": [0.13597, 0.63597, 0, 0, 0.77778],
          "57371": [0.13597, 0.63597, 0, 0, 0.77778]
        },
        "Caligraphic-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "65": [0, 0.68333, 0, 0.19445, 0.79847],
          "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
          "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
          "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
          "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
          "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
          "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
          "72": [0, 0.68333, 965e-5, 0.11111, 0.84452],
          "73": [0, 0.68333, 0.07382, 0, 0.54452],
          "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
          "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
          "76": [0, 0.68333, 0, 0.13889, 0.68972],
          "77": [0, 0.68333, 0, 0.13889, 1.2009],
          "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
          "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
          "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
          "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
          "82": [0, 0.68333, 0, 0.08334, 0.8475],
          "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
          "84": [0, 0.68333, 0.25417, 0, 0.54464],
          "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
          "86": [0, 0.68333, 0.08222, 0, 0.61278],
          "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
          "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
          "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
          "90": [0, 0.68333, 0.07944, 0.13889, 0.72473],
          "160": [0, 0, 0, 0, 0.25]
        },
        "Fraktur-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69141, 0, 0, 0.29574],
          "34": [0, 0.69141, 0, 0, 0.21471],
          "38": [0, 0.69141, 0, 0, 0.73786],
          "39": [0, 0.69141, 0, 0, 0.21201],
          "40": [0.24982, 0.74947, 0, 0, 0.38865],
          "41": [0.24982, 0.74947, 0, 0, 0.38865],
          "42": [0, 0.62119, 0, 0, 0.27764],
          "43": [0.08319, 0.58283, 0, 0, 0.75623],
          "44": [0, 0.10803, 0, 0, 0.27764],
          "45": [0.08319, 0.58283, 0, 0, 0.75623],
          "46": [0, 0.10803, 0, 0, 0.27764],
          "47": [0.24982, 0.74947, 0, 0, 0.50181],
          "48": [0, 0.47534, 0, 0, 0.50181],
          "49": [0, 0.47534, 0, 0, 0.50181],
          "50": [0, 0.47534, 0, 0, 0.50181],
          "51": [0.18906, 0.47534, 0, 0, 0.50181],
          "52": [0.18906, 0.47534, 0, 0, 0.50181],
          "53": [0.18906, 0.47534, 0, 0, 0.50181],
          "54": [0, 0.69141, 0, 0, 0.50181],
          "55": [0.18906, 0.47534, 0, 0, 0.50181],
          "56": [0, 0.69141, 0, 0, 0.50181],
          "57": [0.18906, 0.47534, 0, 0, 0.50181],
          "58": [0, 0.47534, 0, 0, 0.21606],
          "59": [0.12604, 0.47534, 0, 0, 0.21606],
          "61": [-0.13099, 0.36866, 0, 0, 0.75623],
          "63": [0, 0.69141, 0, 0, 0.36245],
          "65": [0, 0.69141, 0, 0, 0.7176],
          "66": [0, 0.69141, 0, 0, 0.88397],
          "67": [0, 0.69141, 0, 0, 0.61254],
          "68": [0, 0.69141, 0, 0, 0.83158],
          "69": [0, 0.69141, 0, 0, 0.66278],
          "70": [0.12604, 0.69141, 0, 0, 0.61119],
          "71": [0, 0.69141, 0, 0, 0.78539],
          "72": [0.06302, 0.69141, 0, 0, 0.7203],
          "73": [0, 0.69141, 0, 0, 0.55448],
          "74": [0.12604, 0.69141, 0, 0, 0.55231],
          "75": [0, 0.69141, 0, 0, 0.66845],
          "76": [0, 0.69141, 0, 0, 0.66602],
          "77": [0, 0.69141, 0, 0, 1.04953],
          "78": [0, 0.69141, 0, 0, 0.83212],
          "79": [0, 0.69141, 0, 0, 0.82699],
          "80": [0.18906, 0.69141, 0, 0, 0.82753],
          "81": [0.03781, 0.69141, 0, 0, 0.82699],
          "82": [0, 0.69141, 0, 0, 0.82807],
          "83": [0, 0.69141, 0, 0, 0.82861],
          "84": [0, 0.69141, 0, 0, 0.66899],
          "85": [0, 0.69141, 0, 0, 0.64576],
          "86": [0, 0.69141, 0, 0, 0.83131],
          "87": [0, 0.69141, 0, 0, 1.04602],
          "88": [0, 0.69141, 0, 0, 0.71922],
          "89": [0.18906, 0.69141, 0, 0, 0.83293],
          "90": [0.12604, 0.69141, 0, 0, 0.60201],
          "91": [0.24982, 0.74947, 0, 0, 0.27764],
          "93": [0.24982, 0.74947, 0, 0, 0.27764],
          "94": [0, 0.69141, 0, 0, 0.49965],
          "97": [0, 0.47534, 0, 0, 0.50046],
          "98": [0, 0.69141, 0, 0, 0.51315],
          "99": [0, 0.47534, 0, 0, 0.38946],
          "100": [0, 0.62119, 0, 0, 0.49857],
          "101": [0, 0.47534, 0, 0, 0.40053],
          "102": [0.18906, 0.69141, 0, 0, 0.32626],
          "103": [0.18906, 0.47534, 0, 0, 0.5037],
          "104": [0.18906, 0.69141, 0, 0, 0.52126],
          "105": [0, 0.69141, 0, 0, 0.27899],
          "106": [0, 0.69141, 0, 0, 0.28088],
          "107": [0, 0.69141, 0, 0, 0.38946],
          "108": [0, 0.69141, 0, 0, 0.27953],
          "109": [0, 0.47534, 0, 0, 0.76676],
          "110": [0, 0.47534, 0, 0, 0.52666],
          "111": [0, 0.47534, 0, 0, 0.48885],
          "112": [0.18906, 0.52396, 0, 0, 0.50046],
          "113": [0.18906, 0.47534, 0, 0, 0.48912],
          "114": [0, 0.47534, 0, 0, 0.38919],
          "115": [0, 0.47534, 0, 0, 0.44266],
          "116": [0, 0.62119, 0, 0, 0.33301],
          "117": [0, 0.47534, 0, 0, 0.5172],
          "118": [0, 0.52396, 0, 0, 0.5118],
          "119": [0, 0.52396, 0, 0, 0.77351],
          "120": [0.18906, 0.47534, 0, 0, 0.38865],
          "121": [0.18906, 0.47534, 0, 0, 0.49884],
          "122": [0.18906, 0.47534, 0, 0, 0.39054],
          "160": [0, 0, 0, 0, 0.25],
          "8216": [0, 0.69141, 0, 0, 0.21471],
          "8217": [0, 0.69141, 0, 0, 0.21471],
          "58112": [0, 0.62119, 0, 0, 0.49749],
          "58113": [0, 0.62119, 0, 0, 0.4983],
          "58114": [0.18906, 0.69141, 0, 0, 0.33328],
          "58115": [0.18906, 0.69141, 0, 0, 0.32923],
          "58116": [0.18906, 0.47534, 0, 0, 0.50343],
          "58117": [0, 0.69141, 0, 0, 0.33301],
          "58118": [0, 0.62119, 0, 0, 0.33409],
          "58119": [0, 0.47534, 0, 0, 0.50073]
        },
        "Main-Bold": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.35],
          "34": [0, 0.69444, 0, 0, 0.60278],
          "35": [0.19444, 0.69444, 0, 0, 0.95833],
          "36": [0.05556, 0.75, 0, 0, 0.575],
          "37": [0.05556, 0.75, 0, 0, 0.95833],
          "38": [0, 0.69444, 0, 0, 0.89444],
          "39": [0, 0.69444, 0, 0, 0.31944],
          "40": [0.25, 0.75, 0, 0, 0.44722],
          "41": [0.25, 0.75, 0, 0, 0.44722],
          "42": [0, 0.75, 0, 0, 0.575],
          "43": [0.13333, 0.63333, 0, 0, 0.89444],
          "44": [0.19444, 0.15556, 0, 0, 0.31944],
          "45": [0, 0.44444, 0, 0, 0.38333],
          "46": [0, 0.15556, 0, 0, 0.31944],
          "47": [0.25, 0.75, 0, 0, 0.575],
          "48": [0, 0.64444, 0, 0, 0.575],
          "49": [0, 0.64444, 0, 0, 0.575],
          "50": [0, 0.64444, 0, 0, 0.575],
          "51": [0, 0.64444, 0, 0, 0.575],
          "52": [0, 0.64444, 0, 0, 0.575],
          "53": [0, 0.64444, 0, 0, 0.575],
          "54": [0, 0.64444, 0, 0, 0.575],
          "55": [0, 0.64444, 0, 0, 0.575],
          "56": [0, 0.64444, 0, 0, 0.575],
          "57": [0, 0.64444, 0, 0, 0.575],
          "58": [0, 0.44444, 0, 0, 0.31944],
          "59": [0.19444, 0.44444, 0, 0, 0.31944],
          "60": [0.08556, 0.58556, 0, 0, 0.89444],
          "61": [-0.10889, 0.39111, 0, 0, 0.89444],
          "62": [0.08556, 0.58556, 0, 0, 0.89444],
          "63": [0, 0.69444, 0, 0, 0.54305],
          "64": [0, 0.69444, 0, 0, 0.89444],
          "65": [0, 0.68611, 0, 0, 0.86944],
          "66": [0, 0.68611, 0, 0, 0.81805],
          "67": [0, 0.68611, 0, 0, 0.83055],
          "68": [0, 0.68611, 0, 0, 0.88194],
          "69": [0, 0.68611, 0, 0, 0.75555],
          "70": [0, 0.68611, 0, 0, 0.72361],
          "71": [0, 0.68611, 0, 0, 0.90416],
          "72": [0, 0.68611, 0, 0, 0.9],
          "73": [0, 0.68611, 0, 0, 0.43611],
          "74": [0, 0.68611, 0, 0, 0.59444],
          "75": [0, 0.68611, 0, 0, 0.90138],
          "76": [0, 0.68611, 0, 0, 0.69166],
          "77": [0, 0.68611, 0, 0, 1.09166],
          "78": [0, 0.68611, 0, 0, 0.9],
          "79": [0, 0.68611, 0, 0, 0.86388],
          "80": [0, 0.68611, 0, 0, 0.78611],
          "81": [0.19444, 0.68611, 0, 0, 0.86388],
          "82": [0, 0.68611, 0, 0, 0.8625],
          "83": [0, 0.68611, 0, 0, 0.63889],
          "84": [0, 0.68611, 0, 0, 0.8],
          "85": [0, 0.68611, 0, 0, 0.88472],
          "86": [0, 0.68611, 0.01597, 0, 0.86944],
          "87": [0, 0.68611, 0.01597, 0, 1.18888],
          "88": [0, 0.68611, 0, 0, 0.86944],
          "89": [0, 0.68611, 0.02875, 0, 0.86944],
          "90": [0, 0.68611, 0, 0, 0.70277],
          "91": [0.25, 0.75, 0, 0, 0.31944],
          "92": [0.25, 0.75, 0, 0, 0.575],
          "93": [0.25, 0.75, 0, 0, 0.31944],
          "94": [0, 0.69444, 0, 0, 0.575],
          "95": [0.31, 0.13444, 0.03194, 0, 0.575],
          "97": [0, 0.44444, 0, 0, 0.55902],
          "98": [0, 0.69444, 0, 0, 0.63889],
          "99": [0, 0.44444, 0, 0, 0.51111],
          "100": [0, 0.69444, 0, 0, 0.63889],
          "101": [0, 0.44444, 0, 0, 0.52708],
          "102": [0, 0.69444, 0.10903, 0, 0.35139],
          "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
          "104": [0, 0.69444, 0, 0, 0.63889],
          "105": [0, 0.69444, 0, 0, 0.31944],
          "106": [0.19444, 0.69444, 0, 0, 0.35139],
          "107": [0, 0.69444, 0, 0, 0.60694],
          "108": [0, 0.69444, 0, 0, 0.31944],
          "109": [0, 0.44444, 0, 0, 0.95833],
          "110": [0, 0.44444, 0, 0, 0.63889],
          "111": [0, 0.44444, 0, 0, 0.575],
          "112": [0.19444, 0.44444, 0, 0, 0.63889],
          "113": [0.19444, 0.44444, 0, 0, 0.60694],
          "114": [0, 0.44444, 0, 0, 0.47361],
          "115": [0, 0.44444, 0, 0, 0.45361],
          "116": [0, 0.63492, 0, 0, 0.44722],
          "117": [0, 0.44444, 0, 0, 0.63889],
          "118": [0, 0.44444, 0.01597, 0, 0.60694],
          "119": [0, 0.44444, 0.01597, 0, 0.83055],
          "120": [0, 0.44444, 0, 0, 0.60694],
          "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
          "122": [0, 0.44444, 0, 0, 0.51111],
          "123": [0.25, 0.75, 0, 0, 0.575],
          "124": [0.25, 0.75, 0, 0, 0.31944],
          "125": [0.25, 0.75, 0, 0, 0.575],
          "126": [0.35, 0.34444, 0, 0, 0.575],
          "160": [0, 0, 0, 0, 0.25],
          "163": [0, 0.69444, 0, 0, 0.86853],
          "168": [0, 0.69444, 0, 0, 0.575],
          "172": [0, 0.44444, 0, 0, 0.76666],
          "176": [0, 0.69444, 0, 0, 0.86944],
          "177": [0.13333, 0.63333, 0, 0, 0.89444],
          "184": [0.17014, 0, 0, 0, 0.51111],
          "198": [0, 0.68611, 0, 0, 1.04166],
          "215": [0.13333, 0.63333, 0, 0, 0.89444],
          "216": [0.04861, 0.73472, 0, 0, 0.89444],
          "223": [0, 0.69444, 0, 0, 0.59722],
          "230": [0, 0.44444, 0, 0, 0.83055],
          "247": [0.13333, 0.63333, 0, 0, 0.89444],
          "248": [0.09722, 0.54167, 0, 0, 0.575],
          "305": [0, 0.44444, 0, 0, 0.31944],
          "338": [0, 0.68611, 0, 0, 1.16944],
          "339": [0, 0.44444, 0, 0, 0.89444],
          "567": [0.19444, 0.44444, 0, 0, 0.35139],
          "710": [0, 0.69444, 0, 0, 0.575],
          "711": [0, 0.63194, 0, 0, 0.575],
          "713": [0, 0.59611, 0, 0, 0.575],
          "714": [0, 0.69444, 0, 0, 0.575],
          "715": [0, 0.69444, 0, 0, 0.575],
          "728": [0, 0.69444, 0, 0, 0.575],
          "729": [0, 0.69444, 0, 0, 0.31944],
          "730": [0, 0.69444, 0, 0, 0.86944],
          "732": [0, 0.69444, 0, 0, 0.575],
          "733": [0, 0.69444, 0, 0, 0.575],
          "915": [0, 0.68611, 0, 0, 0.69166],
          "916": [0, 0.68611, 0, 0, 0.95833],
          "920": [0, 0.68611, 0, 0, 0.89444],
          "923": [0, 0.68611, 0, 0, 0.80555],
          "926": [0, 0.68611, 0, 0, 0.76666],
          "928": [0, 0.68611, 0, 0, 0.9],
          "931": [0, 0.68611, 0, 0, 0.83055],
          "933": [0, 0.68611, 0, 0, 0.89444],
          "934": [0, 0.68611, 0, 0, 0.83055],
          "936": [0, 0.68611, 0, 0, 0.89444],
          "937": [0, 0.68611, 0, 0, 0.83055],
          "8211": [0, 0.44444, 0.03194, 0, 0.575],
          "8212": [0, 0.44444, 0.03194, 0, 1.14999],
          "8216": [0, 0.69444, 0, 0, 0.31944],
          "8217": [0, 0.69444, 0, 0, 0.31944],
          "8220": [0, 0.69444, 0, 0, 0.60278],
          "8221": [0, 0.69444, 0, 0, 0.60278],
          "8224": [0.19444, 0.69444, 0, 0, 0.51111],
          "8225": [0.19444, 0.69444, 0, 0, 0.51111],
          "8242": [0, 0.55556, 0, 0, 0.34444],
          "8407": [0, 0.72444, 0.15486, 0, 0.575],
          "8463": [0, 0.69444, 0, 0, 0.66759],
          "8465": [0, 0.69444, 0, 0, 0.83055],
          "8467": [0, 0.69444, 0, 0, 0.47361],
          "8472": [0.19444, 0.44444, 0, 0, 0.74027],
          "8476": [0, 0.69444, 0, 0, 0.83055],
          "8501": [0, 0.69444, 0, 0, 0.70277],
          "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8593": [0.19444, 0.69444, 0, 0, 0.575],
          "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8595": [0.19444, 0.69444, 0, 0, 0.575],
          "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8597": [0.25, 0.75, 0, 0, 0.575],
          "8598": [0.19444, 0.69444, 0, 0, 1.14999],
          "8599": [0.19444, 0.69444, 0, 0, 1.14999],
          "8600": [0.19444, 0.69444, 0, 0, 1.14999],
          "8601": [0.19444, 0.69444, 0, 0, 1.14999],
          "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8657": [0.19444, 0.69444, 0, 0, 0.70277],
          "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8659": [0.19444, 0.69444, 0, 0, 0.70277],
          "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8661": [0.25, 0.75, 0, 0, 0.70277],
          "8704": [0, 0.69444, 0, 0, 0.63889],
          "8706": [0, 0.69444, 0.06389, 0, 0.62847],
          "8707": [0, 0.69444, 0, 0, 0.63889],
          "8709": [0.05556, 0.75, 0, 0, 0.575],
          "8711": [0, 0.68611, 0, 0, 0.95833],
          "8712": [0.08556, 0.58556, 0, 0, 0.76666],
          "8715": [0.08556, 0.58556, 0, 0, 0.76666],
          "8722": [0.13333, 0.63333, 0, 0, 0.89444],
          "8723": [0.13333, 0.63333, 0, 0, 0.89444],
          "8725": [0.25, 0.75, 0, 0, 0.575],
          "8726": [0.25, 0.75, 0, 0, 0.575],
          "8727": [-0.02778, 0.47222, 0, 0, 0.575],
          "8728": [-0.02639, 0.47361, 0, 0, 0.575],
          "8729": [-0.02639, 0.47361, 0, 0, 0.575],
          "8730": [0.18, 0.82, 0, 0, 0.95833],
          "8733": [0, 0.44444, 0, 0, 0.89444],
          "8734": [0, 0.44444, 0, 0, 1.14999],
          "8736": [0, 0.69224, 0, 0, 0.72222],
          "8739": [0.25, 0.75, 0, 0, 0.31944],
          "8741": [0.25, 0.75, 0, 0, 0.575],
          "8743": [0, 0.55556, 0, 0, 0.76666],
          "8744": [0, 0.55556, 0, 0, 0.76666],
          "8745": [0, 0.55556, 0, 0, 0.76666],
          "8746": [0, 0.55556, 0, 0, 0.76666],
          "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
          "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
          "8768": [0.19444, 0.69444, 0, 0, 0.31944],
          "8771": [222e-5, 0.50222, 0, 0, 0.89444],
          "8773": [0.027, 0.638, 0, 0, 0.894],
          "8776": [0.02444, 0.52444, 0, 0, 0.89444],
          "8781": [222e-5, 0.50222, 0, 0, 0.89444],
          "8801": [222e-5, 0.50222, 0, 0, 0.89444],
          "8804": [0.19667, 0.69667, 0, 0, 0.89444],
          "8805": [0.19667, 0.69667, 0, 0, 0.89444],
          "8810": [0.08556, 0.58556, 0, 0, 1.14999],
          "8811": [0.08556, 0.58556, 0, 0, 1.14999],
          "8826": [0.08556, 0.58556, 0, 0, 0.89444],
          "8827": [0.08556, 0.58556, 0, 0, 0.89444],
          "8834": [0.08556, 0.58556, 0, 0, 0.89444],
          "8835": [0.08556, 0.58556, 0, 0, 0.89444],
          "8838": [0.19667, 0.69667, 0, 0, 0.89444],
          "8839": [0.19667, 0.69667, 0, 0, 0.89444],
          "8846": [0, 0.55556, 0, 0, 0.76666],
          "8849": [0.19667, 0.69667, 0, 0, 0.89444],
          "8850": [0.19667, 0.69667, 0, 0, 0.89444],
          "8851": [0, 0.55556, 0, 0, 0.76666],
          "8852": [0, 0.55556, 0, 0, 0.76666],
          "8853": [0.13333, 0.63333, 0, 0, 0.89444],
          "8854": [0.13333, 0.63333, 0, 0, 0.89444],
          "8855": [0.13333, 0.63333, 0, 0, 0.89444],
          "8856": [0.13333, 0.63333, 0, 0, 0.89444],
          "8857": [0.13333, 0.63333, 0, 0, 0.89444],
          "8866": [0, 0.69444, 0, 0, 0.70277],
          "8867": [0, 0.69444, 0, 0, 0.70277],
          "8868": [0, 0.69444, 0, 0, 0.89444],
          "8869": [0, 0.69444, 0, 0, 0.89444],
          "8900": [-0.02639, 0.47361, 0, 0, 0.575],
          "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
          "8902": [-0.02778, 0.47222, 0, 0, 0.575],
          "8968": [0.25, 0.75, 0, 0, 0.51111],
          "8969": [0.25, 0.75, 0, 0, 0.51111],
          "8970": [0.25, 0.75, 0, 0, 0.51111],
          "8971": [0.25, 0.75, 0, 0, 0.51111],
          "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
          "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
          "9651": [0.19444, 0.69444, 0, 0, 1.02222],
          "9657": [-0.02778, 0.47222, 0, 0, 0.575],
          "9661": [0.19444, 0.69444, 0, 0, 1.02222],
          "9667": [-0.02778, 0.47222, 0, 0, 0.575],
          "9711": [0.19444, 0.69444, 0, 0, 1.14999],
          "9824": [0.12963, 0.69444, 0, 0, 0.89444],
          "9825": [0.12963, 0.69444, 0, 0, 0.89444],
          "9826": [0.12963, 0.69444, 0, 0, 0.89444],
          "9827": [0.12963, 0.69444, 0, 0, 0.89444],
          "9837": [0, 0.75, 0, 0, 0.44722],
          "9838": [0.19444, 0.69444, 0, 0, 0.44722],
          "9839": [0.19444, 0.69444, 0, 0, 0.44722],
          "10216": [0.25, 0.75, 0, 0, 0.44722],
          "10217": [0.25, 0.75, 0, 0, 0.44722],
          "10815": [0, 0.68611, 0, 0, 0.9],
          "10927": [0.19667, 0.69667, 0, 0, 0.89444],
          "10928": [0.19667, 0.69667, 0, 0, 0.89444],
          "57376": [0.19444, 0.69444, 0, 0, 0]
        },
        "Main-BoldItalic": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0.11417, 0, 0.38611],
          "34": [0, 0.69444, 0.07939, 0, 0.62055],
          "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
          "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
          "38": [0, 0.69444, 0.08528, 0, 0.88555],
          "39": [0, 0.69444, 0.12945, 0, 0.35555],
          "40": [0.25, 0.75, 0.15806, 0, 0.47333],
          "41": [0.25, 0.75, 0.03306, 0, 0.47333],
          "42": [0, 0.75, 0.14333, 0, 0.59111],
          "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
          "44": [0.19444, 0.14722, 0, 0, 0.35555],
          "45": [0, 0.44444, 0.02611, 0, 0.41444],
          "46": [0, 0.14722, 0, 0, 0.35555],
          "47": [0.25, 0.75, 0.15806, 0, 0.59111],
          "48": [0, 0.64444, 0.13167, 0, 0.59111],
          "49": [0, 0.64444, 0.13167, 0, 0.59111],
          "50": [0, 0.64444, 0.13167, 0, 0.59111],
          "51": [0, 0.64444, 0.13167, 0, 0.59111],
          "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
          "53": [0, 0.64444, 0.13167, 0, 0.59111],
          "54": [0, 0.64444, 0.13167, 0, 0.59111],
          "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
          "56": [0, 0.64444, 0.13167, 0, 0.59111],
          "57": [0, 0.64444, 0.13167, 0, 0.59111],
          "58": [0, 0.44444, 0.06695, 0, 0.35555],
          "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
          "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
          "63": [0, 0.69444, 0.11472, 0, 0.59111],
          "64": [0, 0.69444, 0.09208, 0, 0.88555],
          "65": [0, 0.68611, 0, 0, 0.86555],
          "66": [0, 0.68611, 0.0992, 0, 0.81666],
          "67": [0, 0.68611, 0.14208, 0, 0.82666],
          "68": [0, 0.68611, 0.09062, 0, 0.87555],
          "69": [0, 0.68611, 0.11431, 0, 0.75666],
          "70": [0, 0.68611, 0.12903, 0, 0.72722],
          "71": [0, 0.68611, 0.07347, 0, 0.89527],
          "72": [0, 0.68611, 0.17208, 0, 0.8961],
          "73": [0, 0.68611, 0.15681, 0, 0.47166],
          "74": [0, 0.68611, 0.145, 0, 0.61055],
          "75": [0, 0.68611, 0.14208, 0, 0.89499],
          "76": [0, 0.68611, 0, 0, 0.69777],
          "77": [0, 0.68611, 0.17208, 0, 1.07277],
          "78": [0, 0.68611, 0.17208, 0, 0.8961],
          "79": [0, 0.68611, 0.09062, 0, 0.85499],
          "80": [0, 0.68611, 0.0992, 0, 0.78721],
          "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
          "82": [0, 0.68611, 0.02559, 0, 0.85944],
          "83": [0, 0.68611, 0.11264, 0, 0.64999],
          "84": [0, 0.68611, 0.12903, 0, 0.7961],
          "85": [0, 0.68611, 0.17208, 0, 0.88083],
          "86": [0, 0.68611, 0.18625, 0, 0.86555],
          "87": [0, 0.68611, 0.18625, 0, 1.15999],
          "88": [0, 0.68611, 0.15681, 0, 0.86555],
          "89": [0, 0.68611, 0.19803, 0, 0.86555],
          "90": [0, 0.68611, 0.14208, 0, 0.70888],
          "91": [0.25, 0.75, 0.1875, 0, 0.35611],
          "93": [0.25, 0.75, 0.09972, 0, 0.35611],
          "94": [0, 0.69444, 0.06709, 0, 0.59111],
          "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
          "97": [0, 0.44444, 0.09426, 0, 0.59111],
          "98": [0, 0.69444, 0.07861, 0, 0.53222],
          "99": [0, 0.44444, 0.05222, 0, 0.53222],
          "100": [0, 0.69444, 0.10861, 0, 0.59111],
          "101": [0, 0.44444, 0.085, 0, 0.53222],
          "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
          "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
          "104": [0, 0.69444, 0.09426, 0, 0.59111],
          "105": [0, 0.69326, 0.11387, 0, 0.35555],
          "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
          "107": [0, 0.69444, 0.11111, 0, 0.53222],
          "108": [0, 0.69444, 0.10861, 0, 0.29666],
          "109": [0, 0.44444, 0.09426, 0, 0.94444],
          "110": [0, 0.44444, 0.09426, 0, 0.64999],
          "111": [0, 0.44444, 0.07861, 0, 0.59111],
          "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
          "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
          "114": [0, 0.44444, 0.11111, 0, 0.50167],
          "115": [0, 0.44444, 0.08167, 0, 0.48694],
          "116": [0, 0.63492, 0.09639, 0, 0.385],
          "117": [0, 0.44444, 0.09426, 0, 0.62055],
          "118": [0, 0.44444, 0.11111, 0, 0.53222],
          "119": [0, 0.44444, 0.11111, 0, 0.76777],
          "120": [0, 0.44444, 0.12583, 0, 0.56055],
          "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
          "122": [0, 0.44444, 0.13889, 0, 0.49055],
          "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.69444, 0.11473, 0, 0.59111],
          "176": [0, 0.69444, 0, 0, 0.94888],
          "184": [0.17014, 0, 0, 0, 0.53222],
          "198": [0, 0.68611, 0.11431, 0, 1.02277],
          "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
          "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
          "230": [0, 0.44444, 0.085, 0, 0.82666],
          "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
          "305": [0, 0.44444, 0.09426, 0, 0.35555],
          "338": [0, 0.68611, 0.11431, 0, 1.14054],
          "339": [0, 0.44444, 0.085, 0, 0.82666],
          "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
          "710": [0, 0.69444, 0.06709, 0, 0.59111],
          "711": [0, 0.63194, 0.08271, 0, 0.59111],
          "713": [0, 0.59444, 0.10444, 0, 0.59111],
          "714": [0, 0.69444, 0.08528, 0, 0.59111],
          "715": [0, 0.69444, 0, 0, 0.59111],
          "728": [0, 0.69444, 0.10333, 0, 0.59111],
          "729": [0, 0.69444, 0.12945, 0, 0.35555],
          "730": [0, 0.69444, 0, 0, 0.94888],
          "732": [0, 0.69444, 0.11472, 0, 0.59111],
          "733": [0, 0.69444, 0.11472, 0, 0.59111],
          "915": [0, 0.68611, 0.12903, 0, 0.69777],
          "916": [0, 0.68611, 0, 0, 0.94444],
          "920": [0, 0.68611, 0.09062, 0, 0.88555],
          "923": [0, 0.68611, 0, 0, 0.80666],
          "926": [0, 0.68611, 0.15092, 0, 0.76777],
          "928": [0, 0.68611, 0.17208, 0, 0.8961],
          "931": [0, 0.68611, 0.11431, 0, 0.82666],
          "933": [0, 0.68611, 0.10778, 0, 0.88555],
          "934": [0, 0.68611, 0.05632, 0, 0.82666],
          "936": [0, 0.68611, 0.10778, 0, 0.88555],
          "937": [0, 0.68611, 0.0992, 0, 0.82666],
          "8211": [0, 0.44444, 0.09811, 0, 0.59111],
          "8212": [0, 0.44444, 0.09811, 0, 1.18221],
          "8216": [0, 0.69444, 0.12945, 0, 0.35555],
          "8217": [0, 0.69444, 0.12945, 0, 0.35555],
          "8220": [0, 0.69444, 0.16772, 0, 0.62055],
          "8221": [0, 0.69444, 0.07939, 0, 0.62055]
        },
        "Main-Italic": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0.12417, 0, 0.30667],
          "34": [0, 0.69444, 0.06961, 0, 0.51444],
          "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
          "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
          "38": [0, 0.69444, 0.09694, 0, 0.76666],
          "39": [0, 0.69444, 0.12417, 0, 0.30667],
          "40": [0.25, 0.75, 0.16194, 0, 0.40889],
          "41": [0.25, 0.75, 0.03694, 0, 0.40889],
          "42": [0, 0.75, 0.14917, 0, 0.51111],
          "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
          "44": [0.19444, 0.10556, 0, 0, 0.30667],
          "45": [0, 0.43056, 0.02826, 0, 0.35778],
          "46": [0, 0.10556, 0, 0, 0.30667],
          "47": [0.25, 0.75, 0.16194, 0, 0.51111],
          "48": [0, 0.64444, 0.13556, 0, 0.51111],
          "49": [0, 0.64444, 0.13556, 0, 0.51111],
          "50": [0, 0.64444, 0.13556, 0, 0.51111],
          "51": [0, 0.64444, 0.13556, 0, 0.51111],
          "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
          "53": [0, 0.64444, 0.13556, 0, 0.51111],
          "54": [0, 0.64444, 0.13556, 0, 0.51111],
          "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
          "56": [0, 0.64444, 0.13556, 0, 0.51111],
          "57": [0, 0.64444, 0.13556, 0, 0.51111],
          "58": [0, 0.43056, 0.0582, 0, 0.30667],
          "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
          "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
          "63": [0, 0.69444, 0.1225, 0, 0.51111],
          "64": [0, 0.69444, 0.09597, 0, 0.76666],
          "65": [0, 0.68333, 0, 0, 0.74333],
          "66": [0, 0.68333, 0.10257, 0, 0.70389],
          "67": [0, 0.68333, 0.14528, 0, 0.71555],
          "68": [0, 0.68333, 0.09403, 0, 0.755],
          "69": [0, 0.68333, 0.12028, 0, 0.67833],
          "70": [0, 0.68333, 0.13305, 0, 0.65277],
          "71": [0, 0.68333, 0.08722, 0, 0.77361],
          "72": [0, 0.68333, 0.16389, 0, 0.74333],
          "73": [0, 0.68333, 0.15806, 0, 0.38555],
          "74": [0, 0.68333, 0.14028, 0, 0.525],
          "75": [0, 0.68333, 0.14528, 0, 0.76888],
          "76": [0, 0.68333, 0, 0, 0.62722],
          "77": [0, 0.68333, 0.16389, 0, 0.89666],
          "78": [0, 0.68333, 0.16389, 0, 0.74333],
          "79": [0, 0.68333, 0.09403, 0, 0.76666],
          "80": [0, 0.68333, 0.10257, 0, 0.67833],
          "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
          "82": [0, 0.68333, 0.03868, 0, 0.72944],
          "83": [0, 0.68333, 0.11972, 0, 0.56222],
          "84": [0, 0.68333, 0.13305, 0, 0.71555],
          "85": [0, 0.68333, 0.16389, 0, 0.74333],
          "86": [0, 0.68333, 0.18361, 0, 0.74333],
          "87": [0, 0.68333, 0.18361, 0, 0.99888],
          "88": [0, 0.68333, 0.15806, 0, 0.74333],
          "89": [0, 0.68333, 0.19383, 0, 0.74333],
          "90": [0, 0.68333, 0.14528, 0, 0.61333],
          "91": [0.25, 0.75, 0.1875, 0, 0.30667],
          "93": [0.25, 0.75, 0.10528, 0, 0.30667],
          "94": [0, 0.69444, 0.06646, 0, 0.51111],
          "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
          "97": [0, 0.43056, 0.07671, 0, 0.51111],
          "98": [0, 0.69444, 0.06312, 0, 0.46],
          "99": [0, 0.43056, 0.05653, 0, 0.46],
          "100": [0, 0.69444, 0.10333, 0, 0.51111],
          "101": [0, 0.43056, 0.07514, 0, 0.46],
          "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
          "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
          "104": [0, 0.69444, 0.07671, 0, 0.51111],
          "105": [0, 0.65536, 0.1019, 0, 0.30667],
          "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
          "107": [0, 0.69444, 0.10764, 0, 0.46],
          "108": [0, 0.69444, 0.10333, 0, 0.25555],
          "109": [0, 0.43056, 0.07671, 0, 0.81777],
          "110": [0, 0.43056, 0.07671, 0, 0.56222],
          "111": [0, 0.43056, 0.06312, 0, 0.51111],
          "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
          "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
          "114": [0, 0.43056, 0.10764, 0, 0.42166],
          "115": [0, 0.43056, 0.08208, 0, 0.40889],
          "116": [0, 0.61508, 0.09486, 0, 0.33222],
          "117": [0, 0.43056, 0.07671, 0, 0.53666],
          "118": [0, 0.43056, 0.10764, 0, 0.46],
          "119": [0, 0.43056, 0.10764, 0, 0.66444],
          "120": [0, 0.43056, 0.12042, 0, 0.46389],
          "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
          "122": [0, 0.43056, 0.12292, 0, 0.40889],
          "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.66786, 0.10474, 0, 0.51111],
          "176": [0, 0.69444, 0, 0, 0.83129],
          "184": [0.17014, 0, 0, 0, 0.46],
          "198": [0, 0.68333, 0.12028, 0, 0.88277],
          "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
          "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
          "230": [0, 0.43056, 0.07514, 0, 0.71555],
          "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
          "338": [0, 0.68333, 0.12028, 0, 0.98499],
          "339": [0, 0.43056, 0.07514, 0, 0.71555],
          "710": [0, 0.69444, 0.06646, 0, 0.51111],
          "711": [0, 0.62847, 0.08295, 0, 0.51111],
          "713": [0, 0.56167, 0.10333, 0, 0.51111],
          "714": [0, 0.69444, 0.09694, 0, 0.51111],
          "715": [0, 0.69444, 0, 0, 0.51111],
          "728": [0, 0.69444, 0.10806, 0, 0.51111],
          "729": [0, 0.66786, 0.11752, 0, 0.30667],
          "730": [0, 0.69444, 0, 0, 0.83129],
          "732": [0, 0.66786, 0.11585, 0, 0.51111],
          "733": [0, 0.69444, 0.1225, 0, 0.51111],
          "915": [0, 0.68333, 0.13305, 0, 0.62722],
          "916": [0, 0.68333, 0, 0, 0.81777],
          "920": [0, 0.68333, 0.09403, 0, 0.76666],
          "923": [0, 0.68333, 0, 0, 0.69222],
          "926": [0, 0.68333, 0.15294, 0, 0.66444],
          "928": [0, 0.68333, 0.16389, 0, 0.74333],
          "931": [0, 0.68333, 0.12028, 0, 0.71555],
          "933": [0, 0.68333, 0.11111, 0, 0.76666],
          "934": [0, 0.68333, 0.05986, 0, 0.71555],
          "936": [0, 0.68333, 0.11111, 0, 0.76666],
          "937": [0, 0.68333, 0.10257, 0, 0.71555],
          "8211": [0, 0.43056, 0.09208, 0, 0.51111],
          "8212": [0, 0.43056, 0.09208, 0, 1.02222],
          "8216": [0, 0.69444, 0.12417, 0, 0.30667],
          "8217": [0, 0.69444, 0.12417, 0, 0.30667],
          "8220": [0, 0.69444, 0.1685, 0, 0.51444],
          "8221": [0, 0.69444, 0.06961, 0, 0.51444],
          "8463": [0, 0.68889, 0, 0, 0.54028]
        },
        "Main-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.27778],
          "34": [0, 0.69444, 0, 0, 0.5],
          "35": [0.19444, 0.69444, 0, 0, 0.83334],
          "36": [0.05556, 0.75, 0, 0, 0.5],
          "37": [0.05556, 0.75, 0, 0, 0.83334],
          "38": [0, 0.69444, 0, 0, 0.77778],
          "39": [0, 0.69444, 0, 0, 0.27778],
          "40": [0.25, 0.75, 0, 0, 0.38889],
          "41": [0.25, 0.75, 0, 0, 0.38889],
          "42": [0, 0.75, 0, 0, 0.5],
          "43": [0.08333, 0.58333, 0, 0, 0.77778],
          "44": [0.19444, 0.10556, 0, 0, 0.27778],
          "45": [0, 0.43056, 0, 0, 0.33333],
          "46": [0, 0.10556, 0, 0, 0.27778],
          "47": [0.25, 0.75, 0, 0, 0.5],
          "48": [0, 0.64444, 0, 0, 0.5],
          "49": [0, 0.64444, 0, 0, 0.5],
          "50": [0, 0.64444, 0, 0, 0.5],
          "51": [0, 0.64444, 0, 0, 0.5],
          "52": [0, 0.64444, 0, 0, 0.5],
          "53": [0, 0.64444, 0, 0, 0.5],
          "54": [0, 0.64444, 0, 0, 0.5],
          "55": [0, 0.64444, 0, 0, 0.5],
          "56": [0, 0.64444, 0, 0, 0.5],
          "57": [0, 0.64444, 0, 0, 0.5],
          "58": [0, 0.43056, 0, 0, 0.27778],
          "59": [0.19444, 0.43056, 0, 0, 0.27778],
          "60": [0.0391, 0.5391, 0, 0, 0.77778],
          "61": [-0.13313, 0.36687, 0, 0, 0.77778],
          "62": [0.0391, 0.5391, 0, 0, 0.77778],
          "63": [0, 0.69444, 0, 0, 0.47222],
          "64": [0, 0.69444, 0, 0, 0.77778],
          "65": [0, 0.68333, 0, 0, 0.75],
          "66": [0, 0.68333, 0, 0, 0.70834],
          "67": [0, 0.68333, 0, 0, 0.72222],
          "68": [0, 0.68333, 0, 0, 0.76389],
          "69": [0, 0.68333, 0, 0, 0.68056],
          "70": [0, 0.68333, 0, 0, 0.65278],
          "71": [0, 0.68333, 0, 0, 0.78472],
          "72": [0, 0.68333, 0, 0, 0.75],
          "73": [0, 0.68333, 0, 0, 0.36111],
          "74": [0, 0.68333, 0, 0, 0.51389],
          "75": [0, 0.68333, 0, 0, 0.77778],
          "76": [0, 0.68333, 0, 0, 0.625],
          "77": [0, 0.68333, 0, 0, 0.91667],
          "78": [0, 0.68333, 0, 0, 0.75],
          "79": [0, 0.68333, 0, 0, 0.77778],
          "80": [0, 0.68333, 0, 0, 0.68056],
          "81": [0.19444, 0.68333, 0, 0, 0.77778],
          "82": [0, 0.68333, 0, 0, 0.73611],
          "83": [0, 0.68333, 0, 0, 0.55556],
          "84": [0, 0.68333, 0, 0, 0.72222],
          "85": [0, 0.68333, 0, 0, 0.75],
          "86": [0, 0.68333, 0.01389, 0, 0.75],
          "87": [0, 0.68333, 0.01389, 0, 1.02778],
          "88": [0, 0.68333, 0, 0, 0.75],
          "89": [0, 0.68333, 0.025, 0, 0.75],
          "90": [0, 0.68333, 0, 0, 0.61111],
          "91": [0.25, 0.75, 0, 0, 0.27778],
          "92": [0.25, 0.75, 0, 0, 0.5],
          "93": [0.25, 0.75, 0, 0, 0.27778],
          "94": [0, 0.69444, 0, 0, 0.5],
          "95": [0.31, 0.12056, 0.02778, 0, 0.5],
          "97": [0, 0.43056, 0, 0, 0.5],
          "98": [0, 0.69444, 0, 0, 0.55556],
          "99": [0, 0.43056, 0, 0, 0.44445],
          "100": [0, 0.69444, 0, 0, 0.55556],
          "101": [0, 0.43056, 0, 0, 0.44445],
          "102": [0, 0.69444, 0.07778, 0, 0.30556],
          "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
          "104": [0, 0.69444, 0, 0, 0.55556],
          "105": [0, 0.66786, 0, 0, 0.27778],
          "106": [0.19444, 0.66786, 0, 0, 0.30556],
          "107": [0, 0.69444, 0, 0, 0.52778],
          "108": [0, 0.69444, 0, 0, 0.27778],
          "109": [0, 0.43056, 0, 0, 0.83334],
          "110": [0, 0.43056, 0, 0, 0.55556],
          "111": [0, 0.43056, 0, 0, 0.5],
          "112": [0.19444, 0.43056, 0, 0, 0.55556],
          "113": [0.19444, 0.43056, 0, 0, 0.52778],
          "114": [0, 0.43056, 0, 0, 0.39167],
          "115": [0, 0.43056, 0, 0, 0.39445],
          "116": [0, 0.61508, 0, 0, 0.38889],
          "117": [0, 0.43056, 0, 0, 0.55556],
          "118": [0, 0.43056, 0.01389, 0, 0.52778],
          "119": [0, 0.43056, 0.01389, 0, 0.72222],
          "120": [0, 0.43056, 0, 0, 0.52778],
          "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
          "122": [0, 0.43056, 0, 0, 0.44445],
          "123": [0.25, 0.75, 0, 0, 0.5],
          "124": [0.25, 0.75, 0, 0, 0.27778],
          "125": [0.25, 0.75, 0, 0, 0.5],
          "126": [0.35, 0.31786, 0, 0, 0.5],
          "160": [0, 0, 0, 0, 0.25],
          "163": [0, 0.69444, 0, 0, 0.76909],
          "167": [0.19444, 0.69444, 0, 0, 0.44445],
          "168": [0, 0.66786, 0, 0, 0.5],
          "172": [0, 0.43056, 0, 0, 0.66667],
          "176": [0, 0.69444, 0, 0, 0.75],
          "177": [0.08333, 0.58333, 0, 0, 0.77778],
          "182": [0.19444, 0.69444, 0, 0, 0.61111],
          "184": [0.17014, 0, 0, 0, 0.44445],
          "198": [0, 0.68333, 0, 0, 0.90278],
          "215": [0.08333, 0.58333, 0, 0, 0.77778],
          "216": [0.04861, 0.73194, 0, 0, 0.77778],
          "223": [0, 0.69444, 0, 0, 0.5],
          "230": [0, 0.43056, 0, 0, 0.72222],
          "247": [0.08333, 0.58333, 0, 0, 0.77778],
          "248": [0.09722, 0.52778, 0, 0, 0.5],
          "305": [0, 0.43056, 0, 0, 0.27778],
          "338": [0, 0.68333, 0, 0, 1.01389],
          "339": [0, 0.43056, 0, 0, 0.77778],
          "567": [0.19444, 0.43056, 0, 0, 0.30556],
          "710": [0, 0.69444, 0, 0, 0.5],
          "711": [0, 0.62847, 0, 0, 0.5],
          "713": [0, 0.56778, 0, 0, 0.5],
          "714": [0, 0.69444, 0, 0, 0.5],
          "715": [0, 0.69444, 0, 0, 0.5],
          "728": [0, 0.69444, 0, 0, 0.5],
          "729": [0, 0.66786, 0, 0, 0.27778],
          "730": [0, 0.69444, 0, 0, 0.75],
          "732": [0, 0.66786, 0, 0, 0.5],
          "733": [0, 0.69444, 0, 0, 0.5],
          "915": [0, 0.68333, 0, 0, 0.625],
          "916": [0, 0.68333, 0, 0, 0.83334],
          "920": [0, 0.68333, 0, 0, 0.77778],
          "923": [0, 0.68333, 0, 0, 0.69445],
          "926": [0, 0.68333, 0, 0, 0.66667],
          "928": [0, 0.68333, 0, 0, 0.75],
          "931": [0, 0.68333, 0, 0, 0.72222],
          "933": [0, 0.68333, 0, 0, 0.77778],
          "934": [0, 0.68333, 0, 0, 0.72222],
          "936": [0, 0.68333, 0, 0, 0.77778],
          "937": [0, 0.68333, 0, 0, 0.72222],
          "8211": [0, 0.43056, 0.02778, 0, 0.5],
          "8212": [0, 0.43056, 0.02778, 0, 1],
          "8216": [0, 0.69444, 0, 0, 0.27778],
          "8217": [0, 0.69444, 0, 0, 0.27778],
          "8220": [0, 0.69444, 0, 0, 0.5],
          "8221": [0, 0.69444, 0, 0, 0.5],
          "8224": [0.19444, 0.69444, 0, 0, 0.44445],
          "8225": [0.19444, 0.69444, 0, 0, 0.44445],
          "8230": [0, 0.123, 0, 0, 1.172],
          "8242": [0, 0.55556, 0, 0, 0.275],
          "8407": [0, 0.71444, 0.15382, 0, 0.5],
          "8463": [0, 0.68889, 0, 0, 0.54028],
          "8465": [0, 0.69444, 0, 0, 0.72222],
          "8467": [0, 0.69444, 0, 0.11111, 0.41667],
          "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
          "8476": [0, 0.69444, 0, 0, 0.72222],
          "8501": [0, 0.69444, 0, 0, 0.61111],
          "8592": [-0.13313, 0.36687, 0, 0, 1],
          "8593": [0.19444, 0.69444, 0, 0, 0.5],
          "8594": [-0.13313, 0.36687, 0, 0, 1],
          "8595": [0.19444, 0.69444, 0, 0, 0.5],
          "8596": [-0.13313, 0.36687, 0, 0, 1],
          "8597": [0.25, 0.75, 0, 0, 0.5],
          "8598": [0.19444, 0.69444, 0, 0, 1],
          "8599": [0.19444, 0.69444, 0, 0, 1],
          "8600": [0.19444, 0.69444, 0, 0, 1],
          "8601": [0.19444, 0.69444, 0, 0, 1],
          "8614": [0.011, 0.511, 0, 0, 1],
          "8617": [0.011, 0.511, 0, 0, 1.126],
          "8618": [0.011, 0.511, 0, 0, 1.126],
          "8636": [-0.13313, 0.36687, 0, 0, 1],
          "8637": [-0.13313, 0.36687, 0, 0, 1],
          "8640": [-0.13313, 0.36687, 0, 0, 1],
          "8641": [-0.13313, 0.36687, 0, 0, 1],
          "8652": [0.011, 0.671, 0, 0, 1],
          "8656": [-0.13313, 0.36687, 0, 0, 1],
          "8657": [0.19444, 0.69444, 0, 0, 0.61111],
          "8658": [-0.13313, 0.36687, 0, 0, 1],
          "8659": [0.19444, 0.69444, 0, 0, 0.61111],
          "8660": [-0.13313, 0.36687, 0, 0, 1],
          "8661": [0.25, 0.75, 0, 0, 0.61111],
          "8704": [0, 0.69444, 0, 0, 0.55556],
          "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
          "8707": [0, 0.69444, 0, 0, 0.55556],
          "8709": [0.05556, 0.75, 0, 0, 0.5],
          "8711": [0, 0.68333, 0, 0, 0.83334],
          "8712": [0.0391, 0.5391, 0, 0, 0.66667],
          "8715": [0.0391, 0.5391, 0, 0, 0.66667],
          "8722": [0.08333, 0.58333, 0, 0, 0.77778],
          "8723": [0.08333, 0.58333, 0, 0, 0.77778],
          "8725": [0.25, 0.75, 0, 0, 0.5],
          "8726": [0.25, 0.75, 0, 0, 0.5],
          "8727": [-0.03472, 0.46528, 0, 0, 0.5],
          "8728": [-0.05555, 0.44445, 0, 0, 0.5],
          "8729": [-0.05555, 0.44445, 0, 0, 0.5],
          "8730": [0.2, 0.8, 0, 0, 0.83334],
          "8733": [0, 0.43056, 0, 0, 0.77778],
          "8734": [0, 0.43056, 0, 0, 1],
          "8736": [0, 0.69224, 0, 0, 0.72222],
          "8739": [0.25, 0.75, 0, 0, 0.27778],
          "8741": [0.25, 0.75, 0, 0, 0.5],
          "8743": [0, 0.55556, 0, 0, 0.66667],
          "8744": [0, 0.55556, 0, 0, 0.66667],
          "8745": [0, 0.55556, 0, 0, 0.66667],
          "8746": [0, 0.55556, 0, 0, 0.66667],
          "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
          "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
          "8768": [0.19444, 0.69444, 0, 0, 0.27778],
          "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8773": [-0.022, 0.589, 0, 0, 0.778],
          "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
          "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8784": [-0.133, 0.673, 0, 0, 0.778],
          "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8804": [0.13597, 0.63597, 0, 0, 0.77778],
          "8805": [0.13597, 0.63597, 0, 0, 0.77778],
          "8810": [0.0391, 0.5391, 0, 0, 1],
          "8811": [0.0391, 0.5391, 0, 0, 1],
          "8826": [0.0391, 0.5391, 0, 0, 0.77778],
          "8827": [0.0391, 0.5391, 0, 0, 0.77778],
          "8834": [0.0391, 0.5391, 0, 0, 0.77778],
          "8835": [0.0391, 0.5391, 0, 0, 0.77778],
          "8838": [0.13597, 0.63597, 0, 0, 0.77778],
          "8839": [0.13597, 0.63597, 0, 0, 0.77778],
          "8846": [0, 0.55556, 0, 0, 0.66667],
          "8849": [0.13597, 0.63597, 0, 0, 0.77778],
          "8850": [0.13597, 0.63597, 0, 0, 0.77778],
          "8851": [0, 0.55556, 0, 0, 0.66667],
          "8852": [0, 0.55556, 0, 0, 0.66667],
          "8853": [0.08333, 0.58333, 0, 0, 0.77778],
          "8854": [0.08333, 0.58333, 0, 0, 0.77778],
          "8855": [0.08333, 0.58333, 0, 0, 0.77778],
          "8856": [0.08333, 0.58333, 0, 0, 0.77778],
          "8857": [0.08333, 0.58333, 0, 0, 0.77778],
          "8866": [0, 0.69444, 0, 0, 0.61111],
          "8867": [0, 0.69444, 0, 0, 0.61111],
          "8868": [0, 0.69444, 0, 0, 0.77778],
          "8869": [0, 0.69444, 0, 0, 0.77778],
          "8872": [0.249, 0.75, 0, 0, 0.867],
          "8900": [-0.05555, 0.44445, 0, 0, 0.5],
          "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
          "8902": [-0.03472, 0.46528, 0, 0, 0.5],
          "8904": [5e-3, 0.505, 0, 0, 0.9],
          "8942": [0.03, 0.903, 0, 0, 0.278],
          "8943": [-0.19, 0.313, 0, 0, 1.172],
          "8945": [-0.1, 0.823, 0, 0, 1.282],
          "8968": [0.25, 0.75, 0, 0, 0.44445],
          "8969": [0.25, 0.75, 0, 0, 0.44445],
          "8970": [0.25, 0.75, 0, 0, 0.44445],
          "8971": [0.25, 0.75, 0, 0, 0.44445],
          "8994": [-0.14236, 0.35764, 0, 0, 1],
          "8995": [-0.14236, 0.35764, 0, 0, 1],
          "9136": [0.244, 0.744, 0, 0, 0.412],
          "9137": [0.244, 0.745, 0, 0, 0.412],
          "9651": [0.19444, 0.69444, 0, 0, 0.88889],
          "9657": [-0.03472, 0.46528, 0, 0, 0.5],
          "9661": [0.19444, 0.69444, 0, 0, 0.88889],
          "9667": [-0.03472, 0.46528, 0, 0, 0.5],
          "9711": [0.19444, 0.69444, 0, 0, 1],
          "9824": [0.12963, 0.69444, 0, 0, 0.77778],
          "9825": [0.12963, 0.69444, 0, 0, 0.77778],
          "9826": [0.12963, 0.69444, 0, 0, 0.77778],
          "9827": [0.12963, 0.69444, 0, 0, 0.77778],
          "9837": [0, 0.75, 0, 0, 0.38889],
          "9838": [0.19444, 0.69444, 0, 0, 0.38889],
          "9839": [0.19444, 0.69444, 0, 0, 0.38889],
          "10216": [0.25, 0.75, 0, 0, 0.38889],
          "10217": [0.25, 0.75, 0, 0, 0.38889],
          "10222": [0.244, 0.744, 0, 0, 0.412],
          "10223": [0.244, 0.745, 0, 0, 0.412],
          "10229": [0.011, 0.511, 0, 0, 1.609],
          "10230": [0.011, 0.511, 0, 0, 1.638],
          "10231": [0.011, 0.511, 0, 0, 1.859],
          "10232": [0.024, 0.525, 0, 0, 1.609],
          "10233": [0.024, 0.525, 0, 0, 1.638],
          "10234": [0.024, 0.525, 0, 0, 1.858],
          "10236": [0.011, 0.511, 0, 0, 1.638],
          "10815": [0, 0.68333, 0, 0, 0.75],
          "10927": [0.13597, 0.63597, 0, 0, 0.77778],
          "10928": [0.13597, 0.63597, 0, 0, 0.77778],
          "57376": [0.19444, 0.69444, 0, 0, 0]
        },
        "Math-BoldItalic": {
          "32": [0, 0, 0, 0, 0.25],
          "48": [0, 0.44444, 0, 0, 0.575],
          "49": [0, 0.44444, 0, 0, 0.575],
          "50": [0, 0.44444, 0, 0, 0.575],
          "51": [0.19444, 0.44444, 0, 0, 0.575],
          "52": [0.19444, 0.44444, 0, 0, 0.575],
          "53": [0.19444, 0.44444, 0, 0, 0.575],
          "54": [0, 0.64444, 0, 0, 0.575],
          "55": [0.19444, 0.44444, 0, 0, 0.575],
          "56": [0, 0.64444, 0, 0, 0.575],
          "57": [0.19444, 0.44444, 0, 0, 0.575],
          "65": [0, 0.68611, 0, 0, 0.86944],
          "66": [0, 0.68611, 0.04835, 0, 0.8664],
          "67": [0, 0.68611, 0.06979, 0, 0.81694],
          "68": [0, 0.68611, 0.03194, 0, 0.93812],
          "69": [0, 0.68611, 0.05451, 0, 0.81007],
          "70": [0, 0.68611, 0.15972, 0, 0.68889],
          "71": [0, 0.68611, 0, 0, 0.88673],
          "72": [0, 0.68611, 0.08229, 0, 0.98229],
          "73": [0, 0.68611, 0.07778, 0, 0.51111],
          "74": [0, 0.68611, 0.10069, 0, 0.63125],
          "75": [0, 0.68611, 0.06979, 0, 0.97118],
          "76": [0, 0.68611, 0, 0, 0.75555],
          "77": [0, 0.68611, 0.11424, 0, 1.14201],
          "78": [0, 0.68611, 0.11424, 0, 0.95034],
          "79": [0, 0.68611, 0.03194, 0, 0.83666],
          "80": [0, 0.68611, 0.15972, 0, 0.72309],
          "81": [0.19444, 0.68611, 0, 0, 0.86861],
          "82": [0, 0.68611, 421e-5, 0, 0.87235],
          "83": [0, 0.68611, 0.05382, 0, 0.69271],
          "84": [0, 0.68611, 0.15972, 0, 0.63663],
          "85": [0, 0.68611, 0.11424, 0, 0.80027],
          "86": [0, 0.68611, 0.25555, 0, 0.67778],
          "87": [0, 0.68611, 0.15972, 0, 1.09305],
          "88": [0, 0.68611, 0.07778, 0, 0.94722],
          "89": [0, 0.68611, 0.25555, 0, 0.67458],
          "90": [0, 0.68611, 0.06979, 0, 0.77257],
          "97": [0, 0.44444, 0, 0, 0.63287],
          "98": [0, 0.69444, 0, 0, 0.52083],
          "99": [0, 0.44444, 0, 0, 0.51342],
          "100": [0, 0.69444, 0, 0, 0.60972],
          "101": [0, 0.44444, 0, 0, 0.55361],
          "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
          "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
          "104": [0, 0.69444, 0, 0, 0.66759],
          "105": [0, 0.69326, 0, 0, 0.4048],
          "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
          "107": [0, 0.69444, 0.01852, 0, 0.6037],
          "108": [0, 0.69444, 88e-4, 0, 0.34815],
          "109": [0, 0.44444, 0, 0, 1.0324],
          "110": [0, 0.44444, 0, 0, 0.71296],
          "111": [0, 0.44444, 0, 0, 0.58472],
          "112": [0.19444, 0.44444, 0, 0, 0.60092],
          "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
          "114": [0, 0.44444, 0.03194, 0, 0.5287],
          "115": [0, 0.44444, 0, 0, 0.53125],
          "116": [0, 0.63492, 0, 0, 0.41528],
          "117": [0, 0.44444, 0, 0, 0.68102],
          "118": [0, 0.44444, 0.03704, 0, 0.56666],
          "119": [0, 0.44444, 0.02778, 0, 0.83148],
          "120": [0, 0.44444, 0, 0, 0.65903],
          "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
          "122": [0, 0.44444, 0.04213, 0, 0.55509],
          "160": [0, 0, 0, 0, 0.25],
          "915": [0, 0.68611, 0.15972, 0, 0.65694],
          "916": [0, 0.68611, 0, 0, 0.95833],
          "920": [0, 0.68611, 0.03194, 0, 0.86722],
          "923": [0, 0.68611, 0, 0, 0.80555],
          "926": [0, 0.68611, 0.07458, 0, 0.84125],
          "928": [0, 0.68611, 0.08229, 0, 0.98229],
          "931": [0, 0.68611, 0.05451, 0, 0.88507],
          "933": [0, 0.68611, 0.15972, 0, 0.67083],
          "934": [0, 0.68611, 0, 0, 0.76666],
          "936": [0, 0.68611, 0.11653, 0, 0.71402],
          "937": [0, 0.68611, 0.04835, 0, 0.8789],
          "945": [0, 0.44444, 0, 0, 0.76064],
          "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
          "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
          "948": [0, 0.69444, 0.03819, 0, 0.52222],
          "949": [0, 0.44444, 0, 0, 0.52882],
          "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
          "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
          "952": [0, 0.69444, 0.03194, 0, 0.5618],
          "953": [0, 0.44444, 0, 0, 0.41204],
          "954": [0, 0.44444, 0, 0, 0.66759],
          "955": [0, 0.69444, 0, 0, 0.67083],
          "956": [0.19444, 0.44444, 0, 0, 0.70787],
          "957": [0, 0.44444, 0.06898, 0, 0.57685],
          "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
          "959": [0, 0.44444, 0, 0, 0.58472],
          "960": [0, 0.44444, 0.03704, 0, 0.68241],
          "961": [0.19444, 0.44444, 0, 0, 0.6118],
          "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
          "963": [0, 0.44444, 0.03704, 0, 0.68588],
          "964": [0, 0.44444, 0.13472, 0, 0.52083],
          "965": [0, 0.44444, 0.03704, 0, 0.63055],
          "966": [0.19444, 0.44444, 0, 0, 0.74722],
          "967": [0.19444, 0.44444, 0, 0, 0.71805],
          "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
          "969": [0, 0.44444, 0.03704, 0, 0.71782],
          "977": [0, 0.69444, 0, 0, 0.69155],
          "981": [0.19444, 0.69444, 0, 0, 0.7125],
          "982": [0, 0.44444, 0.03194, 0, 0.975],
          "1009": [0.19444, 0.44444, 0, 0, 0.6118],
          "1013": [0, 0.44444, 0, 0, 0.48333],
          "57649": [0, 0.44444, 0, 0, 0.39352],
          "57911": [0.19444, 0.44444, 0, 0, 0.43889]
        },
        "Math-Italic": {
          "32": [0, 0, 0, 0, 0.25],
          "48": [0, 0.43056, 0, 0, 0.5],
          "49": [0, 0.43056, 0, 0, 0.5],
          "50": [0, 0.43056, 0, 0, 0.5],
          "51": [0.19444, 0.43056, 0, 0, 0.5],
          "52": [0.19444, 0.43056, 0, 0, 0.5],
          "53": [0.19444, 0.43056, 0, 0, 0.5],
          "54": [0, 0.64444, 0, 0, 0.5],
          "55": [0.19444, 0.43056, 0, 0, 0.5],
          "56": [0, 0.64444, 0, 0, 0.5],
          "57": [0.19444, 0.43056, 0, 0, 0.5],
          "65": [0, 0.68333, 0, 0.13889, 0.75],
          "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
          "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
          "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
          "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
          "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
          "71": [0, 0.68333, 0, 0.08334, 0.78625],
          "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
          "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
          "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
          "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
          "76": [0, 0.68333, 0, 0.02778, 0.68056],
          "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
          "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
          "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
          "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
          "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
          "82": [0, 0.68333, 773e-5, 0.08334, 0.75929],
          "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
          "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
          "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
          "86": [0, 0.68333, 0.22222, 0, 0.58333],
          "87": [0, 0.68333, 0.13889, 0, 0.94445],
          "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
          "89": [0, 0.68333, 0.22222, 0, 0.58056],
          "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
          "97": [0, 0.43056, 0, 0, 0.52859],
          "98": [0, 0.69444, 0, 0, 0.42917],
          "99": [0, 0.43056, 0, 0.05556, 0.43276],
          "100": [0, 0.69444, 0, 0.16667, 0.52049],
          "101": [0, 0.43056, 0, 0.05556, 0.46563],
          "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
          "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
          "104": [0, 0.69444, 0, 0, 0.57616],
          "105": [0, 0.65952, 0, 0, 0.34451],
          "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
          "107": [0, 0.69444, 0.03148, 0, 0.5206],
          "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
          "109": [0, 0.43056, 0, 0, 0.87801],
          "110": [0, 0.43056, 0, 0, 0.60023],
          "111": [0, 0.43056, 0, 0.05556, 0.48472],
          "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
          "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
          "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
          "115": [0, 0.43056, 0, 0.05556, 0.46875],
          "116": [0, 0.61508, 0, 0.08334, 0.36111],
          "117": [0, 0.43056, 0, 0.02778, 0.57246],
          "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
          "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
          "120": [0, 0.43056, 0, 0.02778, 0.57153],
          "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
          "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
          "160": [0, 0, 0, 0, 0.25],
          "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
          "916": [0, 0.68333, 0, 0.16667, 0.83334],
          "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
          "923": [0, 0.68333, 0, 0.16667, 0.69445],
          "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
          "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
          "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
          "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
          "934": [0, 0.68333, 0, 0.08334, 0.66667],
          "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
          "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
          "945": [0, 0.43056, 37e-4, 0.02778, 0.6397],
          "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
          "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
          "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
          "949": [0, 0.43056, 0, 0.08334, 0.46632],
          "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
          "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
          "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
          "953": [0, 0.43056, 0, 0.05556, 0.35394],
          "954": [0, 0.43056, 0, 0, 0.57616],
          "955": [0, 0.69444, 0, 0, 0.58334],
          "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
          "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
          "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
          "959": [0, 0.43056, 0, 0.05556, 0.48472],
          "960": [0, 0.43056, 0.03588, 0, 0.57003],
          "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
          "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
          "963": [0, 0.43056, 0.03588, 0, 0.57141],
          "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
          "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
          "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
          "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
          "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
          "969": [0, 0.43056, 0.03588, 0, 0.62245],
          "977": [0, 0.69444, 0, 0.08334, 0.59144],
          "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
          "982": [0, 0.43056, 0.02778, 0, 0.82813],
          "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
          "1013": [0, 0.43056, 0, 0.05556, 0.4059],
          "57649": [0, 0.43056, 0, 0.02778, 0.32246],
          "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403]
        },
        "SansSerif-Bold": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.36667],
          "34": [0, 0.69444, 0, 0, 0.55834],
          "35": [0.19444, 0.69444, 0, 0, 0.91667],
          "36": [0.05556, 0.75, 0, 0, 0.55],
          "37": [0.05556, 0.75, 0, 0, 1.02912],
          "38": [0, 0.69444, 0, 0, 0.83056],
          "39": [0, 0.69444, 0, 0, 0.30556],
          "40": [0.25, 0.75, 0, 0, 0.42778],
          "41": [0.25, 0.75, 0, 0, 0.42778],
          "42": [0, 0.75, 0, 0, 0.55],
          "43": [0.11667, 0.61667, 0, 0, 0.85556],
          "44": [0.10556, 0.13056, 0, 0, 0.30556],
          "45": [0, 0.45833, 0, 0, 0.36667],
          "46": [0, 0.13056, 0, 0, 0.30556],
          "47": [0.25, 0.75, 0, 0, 0.55],
          "48": [0, 0.69444, 0, 0, 0.55],
          "49": [0, 0.69444, 0, 0, 0.55],
          "50": [0, 0.69444, 0, 0, 0.55],
          "51": [0, 0.69444, 0, 0, 0.55],
          "52": [0, 0.69444, 0, 0, 0.55],
          "53": [0, 0.69444, 0, 0, 0.55],
          "54": [0, 0.69444, 0, 0, 0.55],
          "55": [0, 0.69444, 0, 0, 0.55],
          "56": [0, 0.69444, 0, 0, 0.55],
          "57": [0, 0.69444, 0, 0, 0.55],
          "58": [0, 0.45833, 0, 0, 0.30556],
          "59": [0.10556, 0.45833, 0, 0, 0.30556],
          "61": [-0.09375, 0.40625, 0, 0, 0.85556],
          "63": [0, 0.69444, 0, 0, 0.51945],
          "64": [0, 0.69444, 0, 0, 0.73334],
          "65": [0, 0.69444, 0, 0, 0.73334],
          "66": [0, 0.69444, 0, 0, 0.73334],
          "67": [0, 0.69444, 0, 0, 0.70278],
          "68": [0, 0.69444, 0, 0, 0.79445],
          "69": [0, 0.69444, 0, 0, 0.64167],
          "70": [0, 0.69444, 0, 0, 0.61111],
          "71": [0, 0.69444, 0, 0, 0.73334],
          "72": [0, 0.69444, 0, 0, 0.79445],
          "73": [0, 0.69444, 0, 0, 0.33056],
          "74": [0, 0.69444, 0, 0, 0.51945],
          "75": [0, 0.69444, 0, 0, 0.76389],
          "76": [0, 0.69444, 0, 0, 0.58056],
          "77": [0, 0.69444, 0, 0, 0.97778],
          "78": [0, 0.69444, 0, 0, 0.79445],
          "79": [0, 0.69444, 0, 0, 0.79445],
          "80": [0, 0.69444, 0, 0, 0.70278],
          "81": [0.10556, 0.69444, 0, 0, 0.79445],
          "82": [0, 0.69444, 0, 0, 0.70278],
          "83": [0, 0.69444, 0, 0, 0.61111],
          "84": [0, 0.69444, 0, 0, 0.73334],
          "85": [0, 0.69444, 0, 0, 0.76389],
          "86": [0, 0.69444, 0.01528, 0, 0.73334],
          "87": [0, 0.69444, 0.01528, 0, 1.03889],
          "88": [0, 0.69444, 0, 0, 0.73334],
          "89": [0, 0.69444, 0.0275, 0, 0.73334],
          "90": [0, 0.69444, 0, 0, 0.67223],
          "91": [0.25, 0.75, 0, 0, 0.34306],
          "93": [0.25, 0.75, 0, 0, 0.34306],
          "94": [0, 0.69444, 0, 0, 0.55],
          "95": [0.35, 0.10833, 0.03056, 0, 0.55],
          "97": [0, 0.45833, 0, 0, 0.525],
          "98": [0, 0.69444, 0, 0, 0.56111],
          "99": [0, 0.45833, 0, 0, 0.48889],
          "100": [0, 0.69444, 0, 0, 0.56111],
          "101": [0, 0.45833, 0, 0, 0.51111],
          "102": [0, 0.69444, 0.07639, 0, 0.33611],
          "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
          "104": [0, 0.69444, 0, 0, 0.56111],
          "105": [0, 0.69444, 0, 0, 0.25556],
          "106": [0.19444, 0.69444, 0, 0, 0.28611],
          "107": [0, 0.69444, 0, 0, 0.53056],
          "108": [0, 0.69444, 0, 0, 0.25556],
          "109": [0, 0.45833, 0, 0, 0.86667],
          "110": [0, 0.45833, 0, 0, 0.56111],
          "111": [0, 0.45833, 0, 0, 0.55],
          "112": [0.19444, 0.45833, 0, 0, 0.56111],
          "113": [0.19444, 0.45833, 0, 0, 0.56111],
          "114": [0, 0.45833, 0.01528, 0, 0.37222],
          "115": [0, 0.45833, 0, 0, 0.42167],
          "116": [0, 0.58929, 0, 0, 0.40417],
          "117": [0, 0.45833, 0, 0, 0.56111],
          "118": [0, 0.45833, 0.01528, 0, 0.5],
          "119": [0, 0.45833, 0.01528, 0, 0.74445],
          "120": [0, 0.45833, 0, 0, 0.5],
          "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
          "122": [0, 0.45833, 0, 0, 0.47639],
          "126": [0.35, 0.34444, 0, 0, 0.55],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.69444, 0, 0, 0.55],
          "176": [0, 0.69444, 0, 0, 0.73334],
          "180": [0, 0.69444, 0, 0, 0.55],
          "184": [0.17014, 0, 0, 0, 0.48889],
          "305": [0, 0.45833, 0, 0, 0.25556],
          "567": [0.19444, 0.45833, 0, 0, 0.28611],
          "710": [0, 0.69444, 0, 0, 0.55],
          "711": [0, 0.63542, 0, 0, 0.55],
          "713": [0, 0.63778, 0, 0, 0.55],
          "728": [0, 0.69444, 0, 0, 0.55],
          "729": [0, 0.69444, 0, 0, 0.30556],
          "730": [0, 0.69444, 0, 0, 0.73334],
          "732": [0, 0.69444, 0, 0, 0.55],
          "733": [0, 0.69444, 0, 0, 0.55],
          "915": [0, 0.69444, 0, 0, 0.58056],
          "916": [0, 0.69444, 0, 0, 0.91667],
          "920": [0, 0.69444, 0, 0, 0.85556],
          "923": [0, 0.69444, 0, 0, 0.67223],
          "926": [0, 0.69444, 0, 0, 0.73334],
          "928": [0, 0.69444, 0, 0, 0.79445],
          "931": [0, 0.69444, 0, 0, 0.79445],
          "933": [0, 0.69444, 0, 0, 0.85556],
          "934": [0, 0.69444, 0, 0, 0.79445],
          "936": [0, 0.69444, 0, 0, 0.85556],
          "937": [0, 0.69444, 0, 0, 0.79445],
          "8211": [0, 0.45833, 0.03056, 0, 0.55],
          "8212": [0, 0.45833, 0.03056, 0, 1.10001],
          "8216": [0, 0.69444, 0, 0, 0.30556],
          "8217": [0, 0.69444, 0, 0, 0.30556],
          "8220": [0, 0.69444, 0, 0, 0.55834],
          "8221": [0, 0.69444, 0, 0, 0.55834]
        },
        "SansSerif-Italic": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0.05733, 0, 0.31945],
          "34": [0, 0.69444, 316e-5, 0, 0.5],
          "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
          "36": [0.05556, 0.75, 0.11156, 0, 0.5],
          "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
          "38": [0, 0.69444, 0.03058, 0, 0.75834],
          "39": [0, 0.69444, 0.07816, 0, 0.27778],
          "40": [0.25, 0.75, 0.13164, 0, 0.38889],
          "41": [0.25, 0.75, 0.02536, 0, 0.38889],
          "42": [0, 0.75, 0.11775, 0, 0.5],
          "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
          "44": [0.125, 0.08333, 0, 0, 0.27778],
          "45": [0, 0.44444, 0.01946, 0, 0.33333],
          "46": [0, 0.08333, 0, 0, 0.27778],
          "47": [0.25, 0.75, 0.13164, 0, 0.5],
          "48": [0, 0.65556, 0.11156, 0, 0.5],
          "49": [0, 0.65556, 0.11156, 0, 0.5],
          "50": [0, 0.65556, 0.11156, 0, 0.5],
          "51": [0, 0.65556, 0.11156, 0, 0.5],
          "52": [0, 0.65556, 0.11156, 0, 0.5],
          "53": [0, 0.65556, 0.11156, 0, 0.5],
          "54": [0, 0.65556, 0.11156, 0, 0.5],
          "55": [0, 0.65556, 0.11156, 0, 0.5],
          "56": [0, 0.65556, 0.11156, 0, 0.5],
          "57": [0, 0.65556, 0.11156, 0, 0.5],
          "58": [0, 0.44444, 0.02502, 0, 0.27778],
          "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
          "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
          "63": [0, 0.69444, 0.11809, 0, 0.47222],
          "64": [0, 0.69444, 0.07555, 0, 0.66667],
          "65": [0, 0.69444, 0, 0, 0.66667],
          "66": [0, 0.69444, 0.08293, 0, 0.66667],
          "67": [0, 0.69444, 0.11983, 0, 0.63889],
          "68": [0, 0.69444, 0.07555, 0, 0.72223],
          "69": [0, 0.69444, 0.11983, 0, 0.59722],
          "70": [0, 0.69444, 0.13372, 0, 0.56945],
          "71": [0, 0.69444, 0.11983, 0, 0.66667],
          "72": [0, 0.69444, 0.08094, 0, 0.70834],
          "73": [0, 0.69444, 0.13372, 0, 0.27778],
          "74": [0, 0.69444, 0.08094, 0, 0.47222],
          "75": [0, 0.69444, 0.11983, 0, 0.69445],
          "76": [0, 0.69444, 0, 0, 0.54167],
          "77": [0, 0.69444, 0.08094, 0, 0.875],
          "78": [0, 0.69444, 0.08094, 0, 0.70834],
          "79": [0, 0.69444, 0.07555, 0, 0.73611],
          "80": [0, 0.69444, 0.08293, 0, 0.63889],
          "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
          "82": [0, 0.69444, 0.08293, 0, 0.64584],
          "83": [0, 0.69444, 0.09205, 0, 0.55556],
          "84": [0, 0.69444, 0.13372, 0, 0.68056],
          "85": [0, 0.69444, 0.08094, 0, 0.6875],
          "86": [0, 0.69444, 0.1615, 0, 0.66667],
          "87": [0, 0.69444, 0.1615, 0, 0.94445],
          "88": [0, 0.69444, 0.13372, 0, 0.66667],
          "89": [0, 0.69444, 0.17261, 0, 0.66667],
          "90": [0, 0.69444, 0.11983, 0, 0.61111],
          "91": [0.25, 0.75, 0.15942, 0, 0.28889],
          "93": [0.25, 0.75, 0.08719, 0, 0.28889],
          "94": [0, 0.69444, 0.0799, 0, 0.5],
          "95": [0.35, 0.09444, 0.08616, 0, 0.5],
          "97": [0, 0.44444, 981e-5, 0, 0.48056],
          "98": [0, 0.69444, 0.03057, 0, 0.51667],
          "99": [0, 0.44444, 0.08336, 0, 0.44445],
          "100": [0, 0.69444, 0.09483, 0, 0.51667],
          "101": [0, 0.44444, 0.06778, 0, 0.44445],
          "102": [0, 0.69444, 0.21705, 0, 0.30556],
          "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
          "104": [0, 0.69444, 0.01778, 0, 0.51667],
          "105": [0, 0.67937, 0.09718, 0, 0.23889],
          "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
          "107": [0, 0.69444, 0.08336, 0, 0.48889],
          "108": [0, 0.69444, 0.09483, 0, 0.23889],
          "109": [0, 0.44444, 0.01778, 0, 0.79445],
          "110": [0, 0.44444, 0.01778, 0, 0.51667],
          "111": [0, 0.44444, 0.06613, 0, 0.5],
          "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
          "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
          "114": [0, 0.44444, 0.10836, 0, 0.34167],
          "115": [0, 0.44444, 0.0778, 0, 0.38333],
          "116": [0, 0.57143, 0.07225, 0, 0.36111],
          "117": [0, 0.44444, 0.04169, 0, 0.51667],
          "118": [0, 0.44444, 0.10836, 0, 0.46111],
          "119": [0, 0.44444, 0.10836, 0, 0.68334],
          "120": [0, 0.44444, 0.09169, 0, 0.46111],
          "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
          "122": [0, 0.44444, 0.08752, 0, 0.43472],
          "126": [0.35, 0.32659, 0.08826, 0, 0.5],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.67937, 0.06385, 0, 0.5],
          "176": [0, 0.69444, 0, 0, 0.73752],
          "184": [0.17014, 0, 0, 0, 0.44445],
          "305": [0, 0.44444, 0.04169, 0, 0.23889],
          "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
          "710": [0, 0.69444, 0.0799, 0, 0.5],
          "711": [0, 0.63194, 0.08432, 0, 0.5],
          "713": [0, 0.60889, 0.08776, 0, 0.5],
          "714": [0, 0.69444, 0.09205, 0, 0.5],
          "715": [0, 0.69444, 0, 0, 0.5],
          "728": [0, 0.69444, 0.09483, 0, 0.5],
          "729": [0, 0.67937, 0.07774, 0, 0.27778],
          "730": [0, 0.69444, 0, 0, 0.73752],
          "732": [0, 0.67659, 0.08826, 0, 0.5],
          "733": [0, 0.69444, 0.09205, 0, 0.5],
          "915": [0, 0.69444, 0.13372, 0, 0.54167],
          "916": [0, 0.69444, 0, 0, 0.83334],
          "920": [0, 0.69444, 0.07555, 0, 0.77778],
          "923": [0, 0.69444, 0, 0, 0.61111],
          "926": [0, 0.69444, 0.12816, 0, 0.66667],
          "928": [0, 0.69444, 0.08094, 0, 0.70834],
          "931": [0, 0.69444, 0.11983, 0, 0.72222],
          "933": [0, 0.69444, 0.09031, 0, 0.77778],
          "934": [0, 0.69444, 0.04603, 0, 0.72222],
          "936": [0, 0.69444, 0.09031, 0, 0.77778],
          "937": [0, 0.69444, 0.08293, 0, 0.72222],
          "8211": [0, 0.44444, 0.08616, 0, 0.5],
          "8212": [0, 0.44444, 0.08616, 0, 1],
          "8216": [0, 0.69444, 0.07816, 0, 0.27778],
          "8217": [0, 0.69444, 0.07816, 0, 0.27778],
          "8220": [0, 0.69444, 0.14205, 0, 0.5],
          "8221": [0, 0.69444, 316e-5, 0, 0.5]
        },
        "SansSerif-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.31945],
          "34": [0, 0.69444, 0, 0, 0.5],
          "35": [0.19444, 0.69444, 0, 0, 0.83334],
          "36": [0.05556, 0.75, 0, 0, 0.5],
          "37": [0.05556, 0.75, 0, 0, 0.83334],
          "38": [0, 0.69444, 0, 0, 0.75834],
          "39": [0, 0.69444, 0, 0, 0.27778],
          "40": [0.25, 0.75, 0, 0, 0.38889],
          "41": [0.25, 0.75, 0, 0, 0.38889],
          "42": [0, 0.75, 0, 0, 0.5],
          "43": [0.08333, 0.58333, 0, 0, 0.77778],
          "44": [0.125, 0.08333, 0, 0, 0.27778],
          "45": [0, 0.44444, 0, 0, 0.33333],
          "46": [0, 0.08333, 0, 0, 0.27778],
          "47": [0.25, 0.75, 0, 0, 0.5],
          "48": [0, 0.65556, 0, 0, 0.5],
          "49": [0, 0.65556, 0, 0, 0.5],
          "50": [0, 0.65556, 0, 0, 0.5],
          "51": [0, 0.65556, 0, 0, 0.5],
          "52": [0, 0.65556, 0, 0, 0.5],
          "53": [0, 0.65556, 0, 0, 0.5],
          "54": [0, 0.65556, 0, 0, 0.5],
          "55": [0, 0.65556, 0, 0, 0.5],
          "56": [0, 0.65556, 0, 0, 0.5],
          "57": [0, 0.65556, 0, 0, 0.5],
          "58": [0, 0.44444, 0, 0, 0.27778],
          "59": [0.125, 0.44444, 0, 0, 0.27778],
          "61": [-0.13, 0.37, 0, 0, 0.77778],
          "63": [0, 0.69444, 0, 0, 0.47222],
          "64": [0, 0.69444, 0, 0, 0.66667],
          "65": [0, 0.69444, 0, 0, 0.66667],
          "66": [0, 0.69444, 0, 0, 0.66667],
          "67": [0, 0.69444, 0, 0, 0.63889],
          "68": [0, 0.69444, 0, 0, 0.72223],
          "69": [0, 0.69444, 0, 0, 0.59722],
          "70": [0, 0.69444, 0, 0, 0.56945],
          "71": [0, 0.69444, 0, 0, 0.66667],
          "72": [0, 0.69444, 0, 0, 0.70834],
          "73": [0, 0.69444, 0, 0, 0.27778],
          "74": [0, 0.69444, 0, 0, 0.47222],
          "75": [0, 0.69444, 0, 0, 0.69445],
          "76": [0, 0.69444, 0, 0, 0.54167],
          "77": [0, 0.69444, 0, 0, 0.875],
          "78": [0, 0.69444, 0, 0, 0.70834],
          "79": [0, 0.69444, 0, 0, 0.73611],
          "80": [0, 0.69444, 0, 0, 0.63889],
          "81": [0.125, 0.69444, 0, 0, 0.73611],
          "82": [0, 0.69444, 0, 0, 0.64584],
          "83": [0, 0.69444, 0, 0, 0.55556],
          "84": [0, 0.69444, 0, 0, 0.68056],
          "85": [0, 0.69444, 0, 0, 0.6875],
          "86": [0, 0.69444, 0.01389, 0, 0.66667],
          "87": [0, 0.69444, 0.01389, 0, 0.94445],
          "88": [0, 0.69444, 0, 0, 0.66667],
          "89": [0, 0.69444, 0.025, 0, 0.66667],
          "90": [0, 0.69444, 0, 0, 0.61111],
          "91": [0.25, 0.75, 0, 0, 0.28889],
          "93": [0.25, 0.75, 0, 0, 0.28889],
          "94": [0, 0.69444, 0, 0, 0.5],
          "95": [0.35, 0.09444, 0.02778, 0, 0.5],
          "97": [0, 0.44444, 0, 0, 0.48056],
          "98": [0, 0.69444, 0, 0, 0.51667],
          "99": [0, 0.44444, 0, 0, 0.44445],
          "100": [0, 0.69444, 0, 0, 0.51667],
          "101": [0, 0.44444, 0, 0, 0.44445],
          "102": [0, 0.69444, 0.06944, 0, 0.30556],
          "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
          "104": [0, 0.69444, 0, 0, 0.51667],
          "105": [0, 0.67937, 0, 0, 0.23889],
          "106": [0.19444, 0.67937, 0, 0, 0.26667],
          "107": [0, 0.69444, 0, 0, 0.48889],
          "108": [0, 0.69444, 0, 0, 0.23889],
          "109": [0, 0.44444, 0, 0, 0.79445],
          "110": [0, 0.44444, 0, 0, 0.51667],
          "111": [0, 0.44444, 0, 0, 0.5],
          "112": [0.19444, 0.44444, 0, 0, 0.51667],
          "113": [0.19444, 0.44444, 0, 0, 0.51667],
          "114": [0, 0.44444, 0.01389, 0, 0.34167],
          "115": [0, 0.44444, 0, 0, 0.38333],
          "116": [0, 0.57143, 0, 0, 0.36111],
          "117": [0, 0.44444, 0, 0, 0.51667],
          "118": [0, 0.44444, 0.01389, 0, 0.46111],
          "119": [0, 0.44444, 0.01389, 0, 0.68334],
          "120": [0, 0.44444, 0, 0, 0.46111],
          "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
          "122": [0, 0.44444, 0, 0, 0.43472],
          "126": [0.35, 0.32659, 0, 0, 0.5],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.67937, 0, 0, 0.5],
          "176": [0, 0.69444, 0, 0, 0.66667],
          "184": [0.17014, 0, 0, 0, 0.44445],
          "305": [0, 0.44444, 0, 0, 0.23889],
          "567": [0.19444, 0.44444, 0, 0, 0.26667],
          "710": [0, 0.69444, 0, 0, 0.5],
          "711": [0, 0.63194, 0, 0, 0.5],
          "713": [0, 0.60889, 0, 0, 0.5],
          "714": [0, 0.69444, 0, 0, 0.5],
          "715": [0, 0.69444, 0, 0, 0.5],
          "728": [0, 0.69444, 0, 0, 0.5],
          "729": [0, 0.67937, 0, 0, 0.27778],
          "730": [0, 0.69444, 0, 0, 0.66667],
          "732": [0, 0.67659, 0, 0, 0.5],
          "733": [0, 0.69444, 0, 0, 0.5],
          "915": [0, 0.69444, 0, 0, 0.54167],
          "916": [0, 0.69444, 0, 0, 0.83334],
          "920": [0, 0.69444, 0, 0, 0.77778],
          "923": [0, 0.69444, 0, 0, 0.61111],
          "926": [0, 0.69444, 0, 0, 0.66667],
          "928": [0, 0.69444, 0, 0, 0.70834],
          "931": [0, 0.69444, 0, 0, 0.72222],
          "933": [0, 0.69444, 0, 0, 0.77778],
          "934": [0, 0.69444, 0, 0, 0.72222],
          "936": [0, 0.69444, 0, 0, 0.77778],
          "937": [0, 0.69444, 0, 0, 0.72222],
          "8211": [0, 0.44444, 0.02778, 0, 0.5],
          "8212": [0, 0.44444, 0.02778, 0, 1],
          "8216": [0, 0.69444, 0, 0, 0.27778],
          "8217": [0, 0.69444, 0, 0, 0.27778],
          "8220": [0, 0.69444, 0, 0, 0.5],
          "8221": [0, 0.69444, 0, 0, 0.5]
        },
        "Script-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "65": [0, 0.7, 0.22925, 0, 0.80253],
          "66": [0, 0.7, 0.04087, 0, 0.90757],
          "67": [0, 0.7, 0.1689, 0, 0.66619],
          "68": [0, 0.7, 0.09371, 0, 0.77443],
          "69": [0, 0.7, 0.18583, 0, 0.56162],
          "70": [0, 0.7, 0.13634, 0, 0.89544],
          "71": [0, 0.7, 0.17322, 0, 0.60961],
          "72": [0, 0.7, 0.29694, 0, 0.96919],
          "73": [0, 0.7, 0.19189, 0, 0.80907],
          "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
          "75": [0, 0.7, 0.31259, 0, 0.91364],
          "76": [0, 0.7, 0.19189, 0, 0.87373],
          "77": [0, 0.7, 0.15981, 0, 1.08031],
          "78": [0, 0.7, 0.3525, 0, 0.9015],
          "79": [0, 0.7, 0.08078, 0, 0.73787],
          "80": [0, 0.7, 0.08078, 0, 1.01262],
          "81": [0, 0.7, 0.03305, 0, 0.88282],
          "82": [0, 0.7, 0.06259, 0, 0.85],
          "83": [0, 0.7, 0.19189, 0, 0.86767],
          "84": [0, 0.7, 0.29087, 0, 0.74697],
          "85": [0, 0.7, 0.25815, 0, 0.79996],
          "86": [0, 0.7, 0.27523, 0, 0.62204],
          "87": [0, 0.7, 0.27523, 0, 0.80532],
          "88": [0, 0.7, 0.26006, 0, 0.94445],
          "89": [0, 0.7, 0.2939, 0, 0.70961],
          "90": [0, 0.7, 0.24037, 0, 0.8212],
          "160": [0, 0, 0, 0, 0.25]
        },
        "Size1-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [0.35001, 0.85, 0, 0, 0.45834],
          "41": [0.35001, 0.85, 0, 0, 0.45834],
          "47": [0.35001, 0.85, 0, 0, 0.57778],
          "91": [0.35001, 0.85, 0, 0, 0.41667],
          "92": [0.35001, 0.85, 0, 0, 0.57778],
          "93": [0.35001, 0.85, 0, 0, 0.41667],
          "123": [0.35001, 0.85, 0, 0, 0.58334],
          "125": [0.35001, 0.85, 0, 0, 0.58334],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.72222, 0, 0, 0.55556],
          "732": [0, 0.72222, 0, 0, 0.55556],
          "770": [0, 0.72222, 0, 0, 0.55556],
          "771": [0, 0.72222, 0, 0, 0.55556],
          "8214": [-99e-5, 0.601, 0, 0, 0.77778],
          "8593": [1e-5, 0.6, 0, 0, 0.66667],
          "8595": [1e-5, 0.6, 0, 0, 0.66667],
          "8657": [1e-5, 0.6, 0, 0, 0.77778],
          "8659": [1e-5, 0.6, 0, 0, 0.77778],
          "8719": [0.25001, 0.75, 0, 0, 0.94445],
          "8720": [0.25001, 0.75, 0, 0, 0.94445],
          "8721": [0.25001, 0.75, 0, 0, 1.05556],
          "8730": [0.35001, 0.85, 0, 0, 1],
          "8739": [-599e-5, 0.606, 0, 0, 0.33333],
          "8741": [-599e-5, 0.606, 0, 0, 0.55556],
          "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
          "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
          "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
          "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
          "8896": [0.25001, 0.75, 0, 0, 0.83334],
          "8897": [0.25001, 0.75, 0, 0, 0.83334],
          "8898": [0.25001, 0.75, 0, 0, 0.83334],
          "8899": [0.25001, 0.75, 0, 0, 0.83334],
          "8968": [0.35001, 0.85, 0, 0, 0.47222],
          "8969": [0.35001, 0.85, 0, 0, 0.47222],
          "8970": [0.35001, 0.85, 0, 0, 0.47222],
          "8971": [0.35001, 0.85, 0, 0, 0.47222],
          "9168": [-99e-5, 0.601, 0, 0, 0.66667],
          "10216": [0.35001, 0.85, 0, 0, 0.47222],
          "10217": [0.35001, 0.85, 0, 0, 0.47222],
          "10752": [0.25001, 0.75, 0, 0, 1.11111],
          "10753": [0.25001, 0.75, 0, 0, 1.11111],
          "10754": [0.25001, 0.75, 0, 0, 1.11111],
          "10756": [0.25001, 0.75, 0, 0, 0.83334],
          "10758": [0.25001, 0.75, 0, 0, 0.83334]
        },
        "Size2-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [0.65002, 1.15, 0, 0, 0.59722],
          "41": [0.65002, 1.15, 0, 0, 0.59722],
          "47": [0.65002, 1.15, 0, 0, 0.81111],
          "91": [0.65002, 1.15, 0, 0, 0.47222],
          "92": [0.65002, 1.15, 0, 0, 0.81111],
          "93": [0.65002, 1.15, 0, 0, 0.47222],
          "123": [0.65002, 1.15, 0, 0, 0.66667],
          "125": [0.65002, 1.15, 0, 0, 0.66667],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.75, 0, 0, 1],
          "732": [0, 0.75, 0, 0, 1],
          "770": [0, 0.75, 0, 0, 1],
          "771": [0, 0.75, 0, 0, 1],
          "8719": [0.55001, 1.05, 0, 0, 1.27778],
          "8720": [0.55001, 1.05, 0, 0, 1.27778],
          "8721": [0.55001, 1.05, 0, 0, 1.44445],
          "8730": [0.65002, 1.15, 0, 0, 1],
          "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
          "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
          "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
          "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
          "8896": [0.55001, 1.05, 0, 0, 1.11111],
          "8897": [0.55001, 1.05, 0, 0, 1.11111],
          "8898": [0.55001, 1.05, 0, 0, 1.11111],
          "8899": [0.55001, 1.05, 0, 0, 1.11111],
          "8968": [0.65002, 1.15, 0, 0, 0.52778],
          "8969": [0.65002, 1.15, 0, 0, 0.52778],
          "8970": [0.65002, 1.15, 0, 0, 0.52778],
          "8971": [0.65002, 1.15, 0, 0, 0.52778],
          "10216": [0.65002, 1.15, 0, 0, 0.61111],
          "10217": [0.65002, 1.15, 0, 0, 0.61111],
          "10752": [0.55001, 1.05, 0, 0, 1.51112],
          "10753": [0.55001, 1.05, 0, 0, 1.51112],
          "10754": [0.55001, 1.05, 0, 0, 1.51112],
          "10756": [0.55001, 1.05, 0, 0, 1.11111],
          "10758": [0.55001, 1.05, 0, 0, 1.11111]
        },
        "Size3-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [0.95003, 1.45, 0, 0, 0.73611],
          "41": [0.95003, 1.45, 0, 0, 0.73611],
          "47": [0.95003, 1.45, 0, 0, 1.04445],
          "91": [0.95003, 1.45, 0, 0, 0.52778],
          "92": [0.95003, 1.45, 0, 0, 1.04445],
          "93": [0.95003, 1.45, 0, 0, 0.52778],
          "123": [0.95003, 1.45, 0, 0, 0.75],
          "125": [0.95003, 1.45, 0, 0, 0.75],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.75, 0, 0, 1.44445],
          "732": [0, 0.75, 0, 0, 1.44445],
          "770": [0, 0.75, 0, 0, 1.44445],
          "771": [0, 0.75, 0, 0, 1.44445],
          "8730": [0.95003, 1.45, 0, 0, 1],
          "8968": [0.95003, 1.45, 0, 0, 0.58334],
          "8969": [0.95003, 1.45, 0, 0, 0.58334],
          "8970": [0.95003, 1.45, 0, 0, 0.58334],
          "8971": [0.95003, 1.45, 0, 0, 0.58334],
          "10216": [0.95003, 1.45, 0, 0, 0.75],
          "10217": [0.95003, 1.45, 0, 0, 0.75]
        },
        "Size4-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [1.25003, 1.75, 0, 0, 0.79167],
          "41": [1.25003, 1.75, 0, 0, 0.79167],
          "47": [1.25003, 1.75, 0, 0, 1.27778],
          "91": [1.25003, 1.75, 0, 0, 0.58334],
          "92": [1.25003, 1.75, 0, 0, 1.27778],
          "93": [1.25003, 1.75, 0, 0, 0.58334],
          "123": [1.25003, 1.75, 0, 0, 0.80556],
          "125": [1.25003, 1.75, 0, 0, 0.80556],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.825, 0, 0, 1.8889],
          "732": [0, 0.825, 0, 0, 1.8889],
          "770": [0, 0.825, 0, 0, 1.8889],
          "771": [0, 0.825, 0, 0, 1.8889],
          "8730": [1.25003, 1.75, 0, 0, 1],
          "8968": [1.25003, 1.75, 0, 0, 0.63889],
          "8969": [1.25003, 1.75, 0, 0, 0.63889],
          "8970": [1.25003, 1.75, 0, 0, 0.63889],
          "8971": [1.25003, 1.75, 0, 0, 0.63889],
          "9115": [0.64502, 1.155, 0, 0, 0.875],
          "9116": [1e-5, 0.6, 0, 0, 0.875],
          "9117": [0.64502, 1.155, 0, 0, 0.875],
          "9118": [0.64502, 1.155, 0, 0, 0.875],
          "9119": [1e-5, 0.6, 0, 0, 0.875],
          "9120": [0.64502, 1.155, 0, 0, 0.875],
          "9121": [0.64502, 1.155, 0, 0, 0.66667],
          "9122": [-99e-5, 0.601, 0, 0, 0.66667],
          "9123": [0.64502, 1.155, 0, 0, 0.66667],
          "9124": [0.64502, 1.155, 0, 0, 0.66667],
          "9125": [-99e-5, 0.601, 0, 0, 0.66667],
          "9126": [0.64502, 1.155, 0, 0, 0.66667],
          "9127": [1e-5, 0.9, 0, 0, 0.88889],
          "9128": [0.65002, 1.15, 0, 0, 0.88889],
          "9129": [0.90001, 0, 0, 0, 0.88889],
          "9130": [0, 0.3, 0, 0, 0.88889],
          "9131": [1e-5, 0.9, 0, 0, 0.88889],
          "9132": [0.65002, 1.15, 0, 0, 0.88889],
          "9133": [0.90001, 0, 0, 0, 0.88889],
          "9143": [0.88502, 0.915, 0, 0, 1.05556],
          "10216": [1.25003, 1.75, 0, 0, 0.80556],
          "10217": [1.25003, 1.75, 0, 0, 0.80556],
          "57344": [-499e-5, 0.605, 0, 0, 1.05556],
          "57345": [-499e-5, 0.605, 0, 0, 1.05556],
          "57680": [0, 0.12, 0, 0, 0.45],
          "57681": [0, 0.12, 0, 0, 0.45],
          "57682": [0, 0.12, 0, 0, 0.45],
          "57683": [0, 0.12, 0, 0, 0.45]
        },
        "Typewriter-Regular": {
          "32": [0, 0, 0, 0, 0.525],
          "33": [0, 0.61111, 0, 0, 0.525],
          "34": [0, 0.61111, 0, 0, 0.525],
          "35": [0, 0.61111, 0, 0, 0.525],
          "36": [0.08333, 0.69444, 0, 0, 0.525],
          "37": [0.08333, 0.69444, 0, 0, 0.525],
          "38": [0, 0.61111, 0, 0, 0.525],
          "39": [0, 0.61111, 0, 0, 0.525],
          "40": [0.08333, 0.69444, 0, 0, 0.525],
          "41": [0.08333, 0.69444, 0, 0, 0.525],
          "42": [0, 0.52083, 0, 0, 0.525],
          "43": [-0.08056, 0.53055, 0, 0, 0.525],
          "44": [0.13889, 0.125, 0, 0, 0.525],
          "45": [-0.08056, 0.53055, 0, 0, 0.525],
          "46": [0, 0.125, 0, 0, 0.525],
          "47": [0.08333, 0.69444, 0, 0, 0.525],
          "48": [0, 0.61111, 0, 0, 0.525],
          "49": [0, 0.61111, 0, 0, 0.525],
          "50": [0, 0.61111, 0, 0, 0.525],
          "51": [0, 0.61111, 0, 0, 0.525],
          "52": [0, 0.61111, 0, 0, 0.525],
          "53": [0, 0.61111, 0, 0, 0.525],
          "54": [0, 0.61111, 0, 0, 0.525],
          "55": [0, 0.61111, 0, 0, 0.525],
          "56": [0, 0.61111, 0, 0, 0.525],
          "57": [0, 0.61111, 0, 0, 0.525],
          "58": [0, 0.43056, 0, 0, 0.525],
          "59": [0.13889, 0.43056, 0, 0, 0.525],
          "60": [-0.05556, 0.55556, 0, 0, 0.525],
          "61": [-0.19549, 0.41562, 0, 0, 0.525],
          "62": [-0.05556, 0.55556, 0, 0, 0.525],
          "63": [0, 0.61111, 0, 0, 0.525],
          "64": [0, 0.61111, 0, 0, 0.525],
          "65": [0, 0.61111, 0, 0, 0.525],
          "66": [0, 0.61111, 0, 0, 0.525],
          "67": [0, 0.61111, 0, 0, 0.525],
          "68": [0, 0.61111, 0, 0, 0.525],
          "69": [0, 0.61111, 0, 0, 0.525],
          "70": [0, 0.61111, 0, 0, 0.525],
          "71": [0, 0.61111, 0, 0, 0.525],
          "72": [0, 0.61111, 0, 0, 0.525],
          "73": [0, 0.61111, 0, 0, 0.525],
          "74": [0, 0.61111, 0, 0, 0.525],
          "75": [0, 0.61111, 0, 0, 0.525],
          "76": [0, 0.61111, 0, 0, 0.525],
          "77": [0, 0.61111, 0, 0, 0.525],
          "78": [0, 0.61111, 0, 0, 0.525],
          "79": [0, 0.61111, 0, 0, 0.525],
          "80": [0, 0.61111, 0, 0, 0.525],
          "81": [0.13889, 0.61111, 0, 0, 0.525],
          "82": [0, 0.61111, 0, 0, 0.525],
          "83": [0, 0.61111, 0, 0, 0.525],
          "84": [0, 0.61111, 0, 0, 0.525],
          "85": [0, 0.61111, 0, 0, 0.525],
          "86": [0, 0.61111, 0, 0, 0.525],
          "87": [0, 0.61111, 0, 0, 0.525],
          "88": [0, 0.61111, 0, 0, 0.525],
          "89": [0, 0.61111, 0, 0, 0.525],
          "90": [0, 0.61111, 0, 0, 0.525],
          "91": [0.08333, 0.69444, 0, 0, 0.525],
          "92": [0.08333, 0.69444, 0, 0, 0.525],
          "93": [0.08333, 0.69444, 0, 0, 0.525],
          "94": [0, 0.61111, 0, 0, 0.525],
          "95": [0.09514, 0, 0, 0, 0.525],
          "96": [0, 0.61111, 0, 0, 0.525],
          "97": [0, 0.43056, 0, 0, 0.525],
          "98": [0, 0.61111, 0, 0, 0.525],
          "99": [0, 0.43056, 0, 0, 0.525],
          "100": [0, 0.61111, 0, 0, 0.525],
          "101": [0, 0.43056, 0, 0, 0.525],
          "102": [0, 0.61111, 0, 0, 0.525],
          "103": [0.22222, 0.43056, 0, 0, 0.525],
          "104": [0, 0.61111, 0, 0, 0.525],
          "105": [0, 0.61111, 0, 0, 0.525],
          "106": [0.22222, 0.61111, 0, 0, 0.525],
          "107": [0, 0.61111, 0, 0, 0.525],
          "108": [0, 0.61111, 0, 0, 0.525],
          "109": [0, 0.43056, 0, 0, 0.525],
          "110": [0, 0.43056, 0, 0, 0.525],
          "111": [0, 0.43056, 0, 0, 0.525],
          "112": [0.22222, 0.43056, 0, 0, 0.525],
          "113": [0.22222, 0.43056, 0, 0, 0.525],
          "114": [0, 0.43056, 0, 0, 0.525],
          "115": [0, 0.43056, 0, 0, 0.525],
          "116": [0, 0.55358, 0, 0, 0.525],
          "117": [0, 0.43056, 0, 0, 0.525],
          "118": [0, 0.43056, 0, 0, 0.525],
          "119": [0, 0.43056, 0, 0, 0.525],
          "120": [0, 0.43056, 0, 0, 0.525],
          "121": [0.22222, 0.43056, 0, 0, 0.525],
          "122": [0, 0.43056, 0, 0, 0.525],
          "123": [0.08333, 0.69444, 0, 0, 0.525],
          "124": [0.08333, 0.69444, 0, 0, 0.525],
          "125": [0.08333, 0.69444, 0, 0, 0.525],
          "126": [0, 0.61111, 0, 0, 0.525],
          "127": [0, 0.61111, 0, 0, 0.525],
          "160": [0, 0, 0, 0, 0.525],
          "176": [0, 0.61111, 0, 0, 0.525],
          "184": [0.19445, 0, 0, 0, 0.525],
          "305": [0, 0.43056, 0, 0, 0.525],
          "567": [0.22222, 0.43056, 0, 0, 0.525],
          "711": [0, 0.56597, 0, 0, 0.525],
          "713": [0, 0.56555, 0, 0, 0.525],
          "714": [0, 0.61111, 0, 0, 0.525],
          "715": [0, 0.61111, 0, 0, 0.525],
          "728": [0, 0.61111, 0, 0, 0.525],
          "730": [0, 0.61111, 0, 0, 0.525],
          "770": [0, 0.61111, 0, 0, 0.525],
          "771": [0, 0.61111, 0, 0, 0.525],
          "776": [0, 0.61111, 0, 0, 0.525],
          "915": [0, 0.61111, 0, 0, 0.525],
          "916": [0, 0.61111, 0, 0, 0.525],
          "920": [0, 0.61111, 0, 0, 0.525],
          "923": [0, 0.61111, 0, 0, 0.525],
          "926": [0, 0.61111, 0, 0, 0.525],
          "928": [0, 0.61111, 0, 0, 0.525],
          "931": [0, 0.61111, 0, 0, 0.525],
          "933": [0, 0.61111, 0, 0, 0.525],
          "934": [0, 0.61111, 0, 0, 0.525],
          "936": [0, 0.61111, 0, 0, 0.525],
          "937": [0, 0.61111, 0, 0, 0.525],
          "8216": [0, 0.61111, 0, 0, 0.525],
          "8217": [0, 0.61111, 0, 0, 0.525],
          "8242": [0, 0.61111, 0, 0, 0.525],
          "9251": [0.11111, 0.21944, 0, 0, 0.525]
        }
      };
      sigmasAndXis = {
        slant: [0.25, 0.25, 0.25],
        // sigma1
        space: [0, 0, 0],
        // sigma2
        stretch: [0, 0, 0],
        // sigma3
        shrink: [0, 0, 0],
        // sigma4
        xHeight: [0.431, 0.431, 0.431],
        // sigma5
        quad: [1, 1.171, 1.472],
        // sigma6
        extraSpace: [0, 0, 0],
        // sigma7
        num1: [0.677, 0.732, 0.925],
        // sigma8
        num2: [0.394, 0.384, 0.387],
        // sigma9
        num3: [0.444, 0.471, 0.504],
        // sigma10
        denom1: [0.686, 0.752, 1.025],
        // sigma11
        denom2: [0.345, 0.344, 0.532],
        // sigma12
        sup1: [0.413, 0.503, 0.504],
        // sigma13
        sup2: [0.363, 0.431, 0.404],
        // sigma14
        sup3: [0.289, 0.286, 0.294],
        // sigma15
        sub1: [0.15, 0.143, 0.2],
        // sigma16
        sub2: [0.247, 0.286, 0.4],
        // sigma17
        supDrop: [0.386, 0.353, 0.494],
        // sigma18
        subDrop: [0.05, 0.071, 0.1],
        // sigma19
        delim1: [2.39, 1.7, 1.98],
        // sigma20
        delim2: [1.01, 1.157, 1.42],
        // sigma21
        axisHeight: [0.25, 0.25, 0.25],
        // sigma22
        // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
        // they correspond to the font parameters of the extension fonts (family 3).
        // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
        // match cmex7, we'd use cmex7.tfm values for script and scriptscript
        // values.
        defaultRuleThickness: [0.04, 0.049, 0.049],
        // xi8; cmex7: 0.049
        bigOpSpacing1: [0.111, 0.111, 0.111],
        // xi9
        bigOpSpacing2: [0.166, 0.166, 0.166],
        // xi10
        bigOpSpacing3: [0.2, 0.2, 0.2],
        // xi11
        bigOpSpacing4: [0.6, 0.611, 0.611],
        // xi12; cmex7: 0.611
        bigOpSpacing5: [0.1, 0.143, 0.143],
        // xi13; cmex7: 0.143
        // The \sqrt rule width is taken from the height of the surd character.
        // Since we use the same font at all sizes, this thickness doesn't scale.
        sqrtRuleThickness: [0.04, 0.04, 0.04],
        // This value determines how large a pt is, for metrics which are defined
        // in terms of pts.
        // This value is also used in katex.scss; if you change it make sure the
        // values match.
        ptPerEm: [10, 10, 10],
        // The space between adjacent `|` columns in an array definition. From
        // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
        doubleRuleSep: [0.2, 0.2, 0.2],
        // The width of separator lines in {array} environments. From
        // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
        arrayRuleWidth: [0.04, 0.04, 0.04],
        // Two values from LaTeX source2e:
        fboxsep: [0.3, 0.3, 0.3],
        //        3 pt / ptPerEm
        fboxrule: [0.04, 0.04, 0.04]
        // 0.4 pt / ptPerEm
      };
      extraCharacterMap = {
        // Latin-1
        "\xC5": "A",
        "\xD0": "D",
        "\xDE": "o",
        "\xE5": "a",
        "\xF0": "d",
        "\xFE": "o",
        // Cyrillic
        "\u0410": "A",
        "\u0411": "B",
        "\u0412": "B",
        "\u0413": "F",
        "\u0414": "A",
        "\u0415": "E",
        "\u0416": "K",
        "\u0417": "3",
        "\u0418": "N",
        "\u0419": "N",
        "\u041A": "K",
        "\u041B": "N",
        "\u041C": "M",
        "\u041D": "H",
        "\u041E": "O",
        "\u041F": "N",
        "\u0420": "P",
        "\u0421": "C",
        "\u0422": "T",
        "\u0423": "y",
        "\u0424": "O",
        "\u0425": "X",
        "\u0426": "U",
        "\u0427": "h",
        "\u0428": "W",
        "\u0429": "W",
        "\u042A": "B",
        "\u042B": "X",
        "\u042C": "B",
        "\u042D": "3",
        "\u042E": "X",
        "\u042F": "R",
        "\u0430": "a",
        "\u0431": "b",
        "\u0432": "a",
        "\u0433": "r",
        "\u0434": "y",
        "\u0435": "e",
        "\u0436": "m",
        "\u0437": "e",
        "\u0438": "n",
        "\u0439": "n",
        "\u043A": "n",
        "\u043B": "n",
        "\u043C": "m",
        "\u043D": "n",
        "\u043E": "o",
        "\u043F": "n",
        "\u0440": "p",
        "\u0441": "c",
        "\u0442": "o",
        "\u0443": "y",
        "\u0444": "b",
        "\u0445": "x",
        "\u0446": "n",
        "\u0447": "n",
        "\u0448": "w",
        "\u0449": "w",
        "\u044A": "a",
        "\u044B": "m",
        "\u044C": "a",
        "\u044D": "e",
        "\u044E": "m",
        "\u044F": "r"
      };
      __name(setFontMetrics, "setFontMetrics");
      __name(getCharacterMetrics, "getCharacterMetrics");
      fontMetricsBySizeIndex = {};
      __name(getGlobalMetrics, "getGlobalMetrics");
      sizeStyleMap = [
        // Each element contains [textsize, scriptsize, scriptscriptsize].
        // The size mappings are taken from TeX with \normalsize=10pt.
        [1, 1, 1],
        // size1: [5, 5, 5]              \tiny
        [2, 1, 1],
        // size2: [6, 5, 5]
        [3, 1, 1],
        // size3: [7, 5, 5]              \scriptsize
        [4, 2, 1],
        // size4: [8, 6, 5]              \footnotesize
        [5, 2, 1],
        // size5: [9, 6, 5]              \small
        [6, 3, 1],
        // size6: [10, 7, 5]             \normalsize
        [7, 4, 2],
        // size7: [12, 8, 6]             \large
        [8, 6, 3],
        // size8: [14.4, 10, 7]          \Large
        [9, 7, 6],
        // size9: [17.28, 12, 10]        \LARGE
        [10, 8, 7],
        // size10: [20.74, 14.4, 12]     \huge
        [11, 10, 9]
        // size11: [24.88, 20.74, 17.28] \HUGE
      ];
      sizeMultipliers = [
        // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
        // you change size indexes, change that function.
        0.5,
        0.6,
        0.7,
        0.8,
        0.9,
        1,
        1.2,
        1.44,
        1.728,
        2.074,
        2.488
      ];
      sizeAtStyle = /* @__PURE__ */ __name(function sizeAtStyle2(size5, style3) {
        return style3.size < 2 ? size5 : sizeStyleMap[size5 - 1][style3.size - 1];
      }, "sizeAtStyle");
      Options = class _Options {
        static {
          __name(this, "Options");
        }
        // A font family applies to a group of fonts (i.e. SansSerif), while a font
        // represents a specific font (i.e. SansSerif Bold).
        // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
        /**
         * The base size index.
         */
        constructor(data5) {
          this.style = void 0;
          this.color = void 0;
          this.size = void 0;
          this.textSize = void 0;
          this.phantom = void 0;
          this.font = void 0;
          this.fontFamily = void 0;
          this.fontWeight = void 0;
          this.fontShape = void 0;
          this.sizeMultiplier = void 0;
          this.maxSize = void 0;
          this.minRuleThickness = void 0;
          this._fontMetrics = void 0;
          this.style = data5.style;
          this.color = data5.color;
          this.size = data5.size || _Options.BASESIZE;
          this.textSize = data5.textSize || this.size;
          this.phantom = !!data5.phantom;
          this.font = data5.font || "";
          this.fontFamily = data5.fontFamily || "";
          this.fontWeight = data5.fontWeight || "";
          this.fontShape = data5.fontShape || "";
          this.sizeMultiplier = sizeMultipliers[this.size - 1];
          this.maxSize = data5.maxSize;
          this.minRuleThickness = data5.minRuleThickness;
          this._fontMetrics = void 0;
        }
        /**
         * Returns a new options object with the same properties as "this".  Properties
         * from "extension" will be copied to the new options object.
         */
        extend(extension5) {
          var data5 = {
            style: this.style,
            size: this.size,
            textSize: this.textSize,
            color: this.color,
            phantom: this.phantom,
            font: this.font,
            fontFamily: this.fontFamily,
            fontWeight: this.fontWeight,
            fontShape: this.fontShape,
            maxSize: this.maxSize,
            minRuleThickness: this.minRuleThickness
          };
          for (var key in extension5) {
            if (extension5.hasOwnProperty(key)) {
              data5[key] = extension5[key];
            }
          }
          return new _Options(data5);
        }
        /**
         * Return an options object with the given style. If `this.style === style`,
         * returns `this`.
         */
        havingStyle(style3) {
          if (this.style === style3) {
            return this;
          } else {
            return this.extend({
              style: style3,
              size: sizeAtStyle(this.textSize, style3)
            });
          }
        }
        /**
         * Return an options object with a cramped version of the current style. If
         * the current style is cramped, returns `this`.
         */
        havingCrampedStyle() {
          return this.havingStyle(this.style.cramp());
        }
        /**
         * Return an options object with the given size and in at least `\textstyle`.
         * Returns `this` if appropriate.
         */
        havingSize(size5) {
          if (this.size === size5 && this.textSize === size5) {
            return this;
          } else {
            return this.extend({
              style: this.style.text(),
              size: size5,
              textSize: size5,
              sizeMultiplier: sizeMultipliers[size5 - 1]
            });
          }
        }
        /**
         * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
         * changes to at least `\textstyle`.
         */
        havingBaseStyle(style3) {
          style3 = style3 || this.style.text();
          var wantSize = sizeAtStyle(_Options.BASESIZE, style3);
          if (this.size === wantSize && this.textSize === _Options.BASESIZE && this.style === style3) {
            return this;
          } else {
            return this.extend({
              style: style3,
              size: wantSize
            });
          }
        }
        /**
         * Remove the effect of sizing changes such as \Huge.
         * Keep the effect of the current style, such as \scriptstyle.
         */
        havingBaseSizing() {
          var size5;
          switch (this.style.id) {
            case 4:
            case 5:
              size5 = 3;
              break;
            case 6:
            case 7:
              size5 = 1;
              break;
            default:
              size5 = 6;
          }
          return this.extend({
            style: this.style.text(),
            size: size5
          });
        }
        /**
         * Create a new options object with the given color.
         */
        withColor(color2) {
          return this.extend({
            color: color2
          });
        }
        /**
         * Create a new options object with "phantom" set to true.
         */
        withPhantom() {
          return this.extend({
            phantom: true
          });
        }
        /**
         * Creates a new options object with the given math font or old text font.
         * @type {[type]}
         */
        withFont(font) {
          return this.extend({
            font
          });
        }
        /**
         * Create a new options objects with the given fontFamily.
         */
        withTextFontFamily(fontFamily) {
          return this.extend({
            fontFamily,
            font: ""
          });
        }
        /**
         * Creates a new options object with the given font weight
         */
        withTextFontWeight(fontWeight) {
          return this.extend({
            fontWeight,
            font: ""
          });
        }
        /**
         * Creates a new options object with the given font weight
         */
        withTextFontShape(fontShape) {
          return this.extend({
            fontShape,
            font: ""
          });
        }
        /**
         * Return the CSS sizing classes required to switch from enclosing options
         * `oldOptions` to `this`. Returns an array of classes.
         */
        sizingClasses(oldOptions) {
          if (oldOptions.size !== this.size) {
            return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
          } else {
            return [];
          }
        }
        /**
         * Return the CSS sizing classes required to switch to the base size. Like
         * `this.havingSize(BASESIZE).sizingClasses(this)`.
         */
        baseSizingClasses() {
          if (this.size !== _Options.BASESIZE) {
            return ["sizing", "reset-size" + this.size, "size" + _Options.BASESIZE];
          } else {
            return [];
          }
        }
        /**
         * Return the font metrics for this size.
         */
        fontMetrics() {
          if (!this._fontMetrics) {
            this._fontMetrics = getGlobalMetrics(this.size);
          }
          return this._fontMetrics;
        }
        /**
         * Gets the CSS color of the current options object
         */
        getColor() {
          if (this.phantom) {
            return "transparent";
          } else {
            return this.color;
          }
        }
      };
      Options.BASESIZE = 6;
      ptPerUnit = {
        // https://en.wikibooks.org/wiki/LaTeX/Lengths and
        // https://tex.stackexchange.com/a/8263
        "pt": 1,
        // TeX point
        "mm": 7227 / 2540,
        // millimeter
        "cm": 7227 / 254,
        // centimeter
        "in": 72.27,
        // inch
        "bp": 803 / 800,
        // big (PostScript) points
        "pc": 12,
        // pica
        "dd": 1238 / 1157,
        // didot
        "cc": 14856 / 1157,
        // cicero (12 didot)
        "nd": 685 / 642,
        // new didot
        "nc": 1370 / 107,
        // new cicero (12 new didot)
        "sp": 1 / 65536,
        // scaled point (TeX's internal smallest unit)
        // https://tex.stackexchange.com/a/41371
        "px": 803 / 800
        // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
      };
      relativeUnit = {
        "ex": true,
        "em": true,
        "mu": true
      };
      validUnit = /* @__PURE__ */ __name(function validUnit2(unit2) {
        if (typeof unit2 !== "string") {
          unit2 = unit2.unit;
        }
        return unit2 in ptPerUnit || unit2 in relativeUnit || unit2 === "ex";
      }, "validUnit");
      calculateSize2 = /* @__PURE__ */ __name(function calculateSize3(sizeValue, options3) {
        var scale;
        if (sizeValue.unit in ptPerUnit) {
          scale = ptPerUnit[sizeValue.unit] / options3.fontMetrics().ptPerEm / options3.sizeMultiplier;
        } else if (sizeValue.unit === "mu") {
          scale = options3.fontMetrics().cssEmPerMu;
        } else {
          var unitOptions;
          if (options3.style.isTight()) {
            unitOptions = options3.havingStyle(options3.style.text());
          } else {
            unitOptions = options3;
          }
          if (sizeValue.unit === "ex") {
            scale = unitOptions.fontMetrics().xHeight;
          } else if (sizeValue.unit === "em") {
            scale = unitOptions.fontMetrics().quad;
          } else {
            throw new ParseError("Invalid unit: '" + sizeValue.unit + "'");
          }
          if (unitOptions !== options3) {
            scale *= unitOptions.sizeMultiplier / options3.sizeMultiplier;
          }
        }
        return Math.min(sizeValue.number * scale, options3.maxSize);
      }, "calculateSize");
      makeEm = /* @__PURE__ */ __name(function makeEm2(n2) {
        return +n2.toFixed(4) + "em";
      }, "makeEm");
      createClass = /* @__PURE__ */ __name(function createClass2(classes6) {
        return classes6.filter((cls) => cls).join(" ");
      }, "createClass");
      initNode = /* @__PURE__ */ __name(function initNode2(classes6, options3, style3) {
        this.classes = classes6 || [];
        this.attributes = {};
        this.height = 0;
        this.depth = 0;
        this.maxFontSize = 0;
        this.style = style3 || {};
        if (options3) {
          if (options3.style.isTight()) {
            this.classes.push("mtight");
          }
          var color2 = options3.getColor();
          if (color2) {
            this.style.color = color2;
          }
        }
      }, "initNode");
      toNode = /* @__PURE__ */ __name(function toNode2(tagName) {
        var node2 = document.createElement(tagName);
        node2.className = createClass(this.classes);
        for (var style3 in this.style) {
          if (this.style.hasOwnProperty(style3)) {
            node2.style[style3] = this.style[style3];
          }
        }
        for (var attr in this.attributes) {
          if (this.attributes.hasOwnProperty(attr)) {
            node2.setAttribute(attr, this.attributes[attr]);
          }
        }
        for (var i2 = 0; i2 < this.children.length; i2++) {
          node2.appendChild(this.children[i2].toNode());
        }
        return node2;
      }, "toNode");
      toMarkup = /* @__PURE__ */ __name(function toMarkup2(tagName) {
        var markup = "<" + tagName;
        if (this.classes.length) {
          markup += ' class="' + utils.escape(createClass(this.classes)) + '"';
        }
        var styles3 = "";
        for (var style3 in this.style) {
          if (this.style.hasOwnProperty(style3)) {
            styles3 += utils.hyphenate(style3) + ":" + this.style[style3] + ";";
          }
        }
        if (styles3) {
          markup += ' style="' + utils.escape(styles3) + '"';
        }
        for (var attr in this.attributes) {
          if (this.attributes.hasOwnProperty(attr)) {
            markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
          }
        }
        markup += ">";
        for (var i2 = 0; i2 < this.children.length; i2++) {
          markup += this.children[i2].toMarkup();
        }
        markup += "</" + tagName + ">";
        return markup;
      }, "toMarkup");
      Span = class {
        static {
          __name(this, "Span");
        }
        constructor(classes6, children2, options3, style3) {
          this.children = void 0;
          this.attributes = void 0;
          this.classes = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.width = void 0;
          this.maxFontSize = void 0;
          this.style = void 0;
          initNode.call(this, classes6, options3, style3);
          this.children = children2 || [];
        }
        /**
         * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
         * all browsers support attributes the same, and having too many custom
         * attributes is probably bad.
         */
        setAttribute(attribute, value2) {
          this.attributes[attribute] = value2;
        }
        hasClass(className) {
          return utils.contains(this.classes, className);
        }
        toNode() {
          return toNode.call(this, "span");
        }
        toMarkup() {
          return toMarkup.call(this, "span");
        }
      };
      Anchor = class {
        static {
          __name(this, "Anchor");
        }
        constructor(href, classes6, children2, options3) {
          this.children = void 0;
          this.attributes = void 0;
          this.classes = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.maxFontSize = void 0;
          this.style = void 0;
          initNode.call(this, classes6, options3);
          this.children = children2 || [];
          this.setAttribute("href", href);
        }
        setAttribute(attribute, value2) {
          this.attributes[attribute] = value2;
        }
        hasClass(className) {
          return utils.contains(this.classes, className);
        }
        toNode() {
          return toNode.call(this, "a");
        }
        toMarkup() {
          return toMarkup.call(this, "a");
        }
      };
      Img = class {
        static {
          __name(this, "Img");
        }
        constructor(src, alt, style3) {
          this.src = void 0;
          this.alt = void 0;
          this.classes = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.maxFontSize = void 0;
          this.style = void 0;
          this.alt = alt;
          this.src = src;
          this.classes = ["mord"];
          this.style = style3;
        }
        hasClass(className) {
          return utils.contains(this.classes, className);
        }
        toNode() {
          var node2 = document.createElement("img");
          node2.src = this.src;
          node2.alt = this.alt;
          node2.className = "mord";
          for (var style3 in this.style) {
            if (this.style.hasOwnProperty(style3)) {
              node2.style[style3] = this.style[style3];
            }
          }
          return node2;
        }
        toMarkup() {
          var markup = '<img src="' + utils.escape(this.src) + '"' + (' alt="' + utils.escape(this.alt) + '"');
          var styles3 = "";
          for (var style3 in this.style) {
            if (this.style.hasOwnProperty(style3)) {
              styles3 += utils.hyphenate(style3) + ":" + this.style[style3] + ";";
            }
          }
          if (styles3) {
            markup += ' style="' + utils.escape(styles3) + '"';
          }
          markup += "'/>";
          return markup;
        }
      };
      iCombinations = {
        "\xEE": "\u0131\u0302",
        "\xEF": "\u0131\u0308",
        "\xED": "\u0131\u0301",
        // 'ī': '\u0131\u0304', // enable when we add Extended Latin
        "\xEC": "\u0131\u0300"
      };
      SymbolNode = class {
        static {
          __name(this, "SymbolNode");
        }
        constructor(text4, height2, depth, italic, skew, width3, classes6, style3) {
          this.text = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.italic = void 0;
          this.skew = void 0;
          this.width = void 0;
          this.maxFontSize = void 0;
          this.classes = void 0;
          this.style = void 0;
          this.text = text4;
          this.height = height2 || 0;
          this.depth = depth || 0;
          this.italic = italic || 0;
          this.skew = skew || 0;
          this.width = width3 || 0;
          this.classes = classes6 || [];
          this.style = style3 || {};
          this.maxFontSize = 0;
          var script = scriptFromCodepoint(this.text.charCodeAt(0));
          if (script) {
            this.classes.push(script + "_fallback");
          }
          if (/[îïíì]/.test(this.text)) {
            this.text = iCombinations[this.text];
          }
        }
        hasClass(className) {
          return utils.contains(this.classes, className);
        }
        /**
         * Creates a text node or span from a symbol node. Note that a span is only
         * created if it is needed.
         */
        toNode() {
          var node2 = document.createTextNode(this.text);
          var span = null;
          if (this.italic > 0) {
            span = document.createElement("span");
            span.style.marginRight = makeEm(this.italic);
          }
          if (this.classes.length > 0) {
            span = span || document.createElement("span");
            span.className = createClass(this.classes);
          }
          for (var style3 in this.style) {
            if (this.style.hasOwnProperty(style3)) {
              span = span || document.createElement("span");
              span.style[style3] = this.style[style3];
            }
          }
          if (span) {
            span.appendChild(node2);
            return span;
          } else {
            return node2;
          }
        }
        /**
         * Creates markup for a symbol node.
         */
        toMarkup() {
          var needsSpan = false;
          var markup = "<span";
          if (this.classes.length) {
            needsSpan = true;
            markup += ' class="';
            markup += utils.escape(createClass(this.classes));
            markup += '"';
          }
          var styles3 = "";
          if (this.italic > 0) {
            styles3 += "margin-right:" + this.italic + "em;";
          }
          for (var style3 in this.style) {
            if (this.style.hasOwnProperty(style3)) {
              styles3 += utils.hyphenate(style3) + ":" + this.style[style3] + ";";
            }
          }
          if (styles3) {
            needsSpan = true;
            markup += ' style="' + utils.escape(styles3) + '"';
          }
          var escaped = utils.escape(this.text);
          if (needsSpan) {
            markup += ">";
            markup += escaped;
            markup += "</span>";
            return markup;
          } else {
            return escaped;
          }
        }
      };
      SvgNode = class {
        static {
          __name(this, "SvgNode");
        }
        constructor(children2, attributes) {
          this.children = void 0;
          this.attributes = void 0;
          this.children = children2 || [];
          this.attributes = attributes || {};
        }
        toNode() {
          var svgNS = "http://www.w3.org/2000/svg";
          var node2 = document.createElementNS(svgNS, "svg");
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              node2.setAttribute(attr, this.attributes[attr]);
            }
          }
          for (var i2 = 0; i2 < this.children.length; i2++) {
            node2.appendChild(this.children[i2].toNode());
          }
          return node2;
        }
        toMarkup() {
          var markup = '<svg xmlns="http://www.w3.org/2000/svg"';
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
            }
          }
          markup += ">";
          for (var i2 = 0; i2 < this.children.length; i2++) {
            markup += this.children[i2].toMarkup();
          }
          markup += "</svg>";
          return markup;
        }
      };
      PathNode = class {
        static {
          __name(this, "PathNode");
        }
        constructor(pathName, alternate) {
          this.pathName = void 0;
          this.alternate = void 0;
          this.pathName = pathName;
          this.alternate = alternate;
        }
        toNode() {
          var svgNS = "http://www.w3.org/2000/svg";
          var node2 = document.createElementNS(svgNS, "path");
          if (this.alternate) {
            node2.setAttribute("d", this.alternate);
          } else {
            node2.setAttribute("d", path[this.pathName]);
          }
          return node2;
        }
        toMarkup() {
          if (this.alternate) {
            return '<path d="' + utils.escape(this.alternate) + '"/>';
          } else {
            return '<path d="' + utils.escape(path[this.pathName]) + '"/>';
          }
        }
      };
      LineNode = class {
        static {
          __name(this, "LineNode");
        }
        constructor(attributes) {
          this.attributes = void 0;
          this.attributes = attributes || {};
        }
        toNode() {
          var svgNS = "http://www.w3.org/2000/svg";
          var node2 = document.createElementNS(svgNS, "line");
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              node2.setAttribute(attr, this.attributes[attr]);
            }
          }
          return node2;
        }
        toMarkup() {
          var markup = "<line";
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
            }
          }
          markup += "/>";
          return markup;
        }
      };
      __name(assertSymbolDomNode, "assertSymbolDomNode");
      __name(assertSpan, "assertSpan");
      ATOMS = {
        "bin": 1,
        "close": 1,
        "inner": 1,
        "open": 1,
        "punct": 1,
        "rel": 1
      };
      NON_ATOMS = {
        "accent-token": 1,
        "mathord": 1,
        "op-token": 1,
        "spacing": 1,
        "textord": 1
      };
      symbols = {
        "math": {},
        "text": {}
      };
      __name(defineSymbol, "defineSymbol");
      math = "math";
      text2 = "text";
      main = "main";
      ams = "ams";
      accent = "accent-token";
      bin = "bin";
      close = "close";
      inner = "inner";
      mathord = "mathord";
      op = "op-token";
      open = "open";
      punct = "punct";
      rel = "rel";
      spacing = "spacing";
      textord = "textord";
      defineSymbol(math, main, rel, "\u2261", "\\equiv", true);
      defineSymbol(math, main, rel, "\u227A", "\\prec", true);
      defineSymbol(math, main, rel, "\u227B", "\\succ", true);
      defineSymbol(math, main, rel, "\u223C", "\\sim", true);
      defineSymbol(math, main, rel, "\u22A5", "\\perp");
      defineSymbol(math, main, rel, "\u2AAF", "\\preceq", true);
      defineSymbol(math, main, rel, "\u2AB0", "\\succeq", true);
      defineSymbol(math, main, rel, "\u2243", "\\simeq", true);
      defineSymbol(math, main, rel, "\u2223", "\\mid", true);
      defineSymbol(math, main, rel, "\u226A", "\\ll", true);
      defineSymbol(math, main, rel, "\u226B", "\\gg", true);
      defineSymbol(math, main, rel, "\u224D", "\\asymp", true);
      defineSymbol(math, main, rel, "\u2225", "\\parallel");
      defineSymbol(math, main, rel, "\u22C8", "\\bowtie", true);
      defineSymbol(math, main, rel, "\u2323", "\\smile", true);
      defineSymbol(math, main, rel, "\u2291", "\\sqsubseteq", true);
      defineSymbol(math, main, rel, "\u2292", "\\sqsupseteq", true);
      defineSymbol(math, main, rel, "\u2250", "\\doteq", true);
      defineSymbol(math, main, rel, "\u2322", "\\frown", true);
      defineSymbol(math, main, rel, "\u220B", "\\ni", true);
      defineSymbol(math, main, rel, "\u221D", "\\propto", true);
      defineSymbol(math, main, rel, "\u22A2", "\\vdash", true);
      defineSymbol(math, main, rel, "\u22A3", "\\dashv", true);
      defineSymbol(math, main, rel, "\u220B", "\\owns");
      defineSymbol(math, main, punct, ".", "\\ldotp");
      defineSymbol(math, main, punct, "\u22C5", "\\cdotp");
      defineSymbol(math, main, textord, "#", "\\#");
      defineSymbol(text2, main, textord, "#", "\\#");
      defineSymbol(math, main, textord, "&", "\\&");
      defineSymbol(text2, main, textord, "&", "\\&");
      defineSymbol(math, main, textord, "\u2135", "\\aleph", true);
      defineSymbol(math, main, textord, "\u2200", "\\forall", true);
      defineSymbol(math, main, textord, "\u210F", "\\hbar", true);
      defineSymbol(math, main, textord, "\u2203", "\\exists", true);
      defineSymbol(math, main, textord, "\u2207", "\\nabla", true);
      defineSymbol(math, main, textord, "\u266D", "\\flat", true);
      defineSymbol(math, main, textord, "\u2113", "\\ell", true);
      defineSymbol(math, main, textord, "\u266E", "\\natural", true);
      defineSymbol(math, main, textord, "\u2663", "\\clubsuit", true);
      defineSymbol(math, main, textord, "\u2118", "\\wp", true);
      defineSymbol(math, main, textord, "\u266F", "\\sharp", true);
      defineSymbol(math, main, textord, "\u2662", "\\diamondsuit", true);
      defineSymbol(math, main, textord, "\u211C", "\\Re", true);
      defineSymbol(math, main, textord, "\u2661", "\\heartsuit", true);
      defineSymbol(math, main, textord, "\u2111", "\\Im", true);
      defineSymbol(math, main, textord, "\u2660", "\\spadesuit", true);
      defineSymbol(math, main, textord, "\xA7", "\\S", true);
      defineSymbol(text2, main, textord, "\xA7", "\\S");
      defineSymbol(math, main, textord, "\xB6", "\\P", true);
      defineSymbol(text2, main, textord, "\xB6", "\\P");
      defineSymbol(math, main, textord, "\u2020", "\\dag");
      defineSymbol(text2, main, textord, "\u2020", "\\dag");
      defineSymbol(text2, main, textord, "\u2020", "\\textdagger");
      defineSymbol(math, main, textord, "\u2021", "\\ddag");
      defineSymbol(text2, main, textord, "\u2021", "\\ddag");
      defineSymbol(text2, main, textord, "\u2021", "\\textdaggerdbl");
      defineSymbol(math, main, close, "\u23B1", "\\rmoustache", true);
      defineSymbol(math, main, open, "\u23B0", "\\lmoustache", true);
      defineSymbol(math, main, close, "\u27EF", "\\rgroup", true);
      defineSymbol(math, main, open, "\u27EE", "\\lgroup", true);
      defineSymbol(math, main, bin, "\u2213", "\\mp", true);
      defineSymbol(math, main, bin, "\u2296", "\\ominus", true);
      defineSymbol(math, main, bin, "\u228E", "\\uplus", true);
      defineSymbol(math, main, bin, "\u2293", "\\sqcap", true);
      defineSymbol(math, main, bin, "\u2217", "\\ast");
      defineSymbol(math, main, bin, "\u2294", "\\sqcup", true);
      defineSymbol(math, main, bin, "\u25EF", "\\bigcirc", true);
      defineSymbol(math, main, bin, "\u2219", "\\bullet", true);
      defineSymbol(math, main, bin, "\u2021", "\\ddagger");
      defineSymbol(math, main, bin, "\u2240", "\\wr", true);
      defineSymbol(math, main, bin, "\u2A3F", "\\amalg");
      defineSymbol(math, main, bin, "&", "\\And");
      defineSymbol(math, main, rel, "\u27F5", "\\longleftarrow", true);
      defineSymbol(math, main, rel, "\u21D0", "\\Leftarrow", true);
      defineSymbol(math, main, rel, "\u27F8", "\\Longleftarrow", true);
      defineSymbol(math, main, rel, "\u27F6", "\\longrightarrow", true);
      defineSymbol(math, main, rel, "\u21D2", "\\Rightarrow", true);
      defineSymbol(math, main, rel, "\u27F9", "\\Longrightarrow", true);
      defineSymbol(math, main, rel, "\u2194", "\\leftrightarrow", true);
      defineSymbol(math, main, rel, "\u27F7", "\\longleftrightarrow", true);
      defineSymbol(math, main, rel, "\u21D4", "\\Leftrightarrow", true);
      defineSymbol(math, main, rel, "\u27FA", "\\Longleftrightarrow", true);
      defineSymbol(math, main, rel, "\u21A6", "\\mapsto", true);
      defineSymbol(math, main, rel, "\u27FC", "\\longmapsto", true);
      defineSymbol(math, main, rel, "\u2197", "\\nearrow", true);
      defineSymbol(math, main, rel, "\u21A9", "\\hookleftarrow", true);
      defineSymbol(math, main, rel, "\u21AA", "\\hookrightarrow", true);
      defineSymbol(math, main, rel, "\u2198", "\\searrow", true);
      defineSymbol(math, main, rel, "\u21BC", "\\leftharpoonup", true);
      defineSymbol(math, main, rel, "\u21C0", "\\rightharpoonup", true);
      defineSymbol(math, main, rel, "\u2199", "\\swarrow", true);
      defineSymbol(math, main, rel, "\u21BD", "\\leftharpoondown", true);
      defineSymbol(math, main, rel, "\u21C1", "\\rightharpoondown", true);
      defineSymbol(math, main, rel, "\u2196", "\\nwarrow", true);
      defineSymbol(math, main, rel, "\u21CC", "\\rightleftharpoons", true);
      defineSymbol(math, ams, rel, "\u226E", "\\nless", true);
      defineSymbol(math, ams, rel, "\uE010", "\\@nleqslant");
      defineSymbol(math, ams, rel, "\uE011", "\\@nleqq");
      defineSymbol(math, ams, rel, "\u2A87", "\\lneq", true);
      defineSymbol(math, ams, rel, "\u2268", "\\lneqq", true);
      defineSymbol(math, ams, rel, "\uE00C", "\\@lvertneqq");
      defineSymbol(math, ams, rel, "\u22E6", "\\lnsim", true);
      defineSymbol(math, ams, rel, "\u2A89", "\\lnapprox", true);
      defineSymbol(math, ams, rel, "\u2280", "\\nprec", true);
      defineSymbol(math, ams, rel, "\u22E0", "\\npreceq", true);
      defineSymbol(math, ams, rel, "\u22E8", "\\precnsim", true);
      defineSymbol(math, ams, rel, "\u2AB9", "\\precnapprox", true);
      defineSymbol(math, ams, rel, "\u2241", "\\nsim", true);
      defineSymbol(math, ams, rel, "\uE006", "\\@nshortmid");
      defineSymbol(math, ams, rel, "\u2224", "\\nmid", true);
      defineSymbol(math, ams, rel, "\u22AC", "\\nvdash", true);
      defineSymbol(math, ams, rel, "\u22AD", "\\nvDash", true);
      defineSymbol(math, ams, rel, "\u22EA", "\\ntriangleleft");
      defineSymbol(math, ams, rel, "\u22EC", "\\ntrianglelefteq", true);
      defineSymbol(math, ams, rel, "\u228A", "\\subsetneq", true);
      defineSymbol(math, ams, rel, "\uE01A", "\\@varsubsetneq");
      defineSymbol(math, ams, rel, "\u2ACB", "\\subsetneqq", true);
      defineSymbol(math, ams, rel, "\uE017", "\\@varsubsetneqq");
      defineSymbol(math, ams, rel, "\u226F", "\\ngtr", true);
      defineSymbol(math, ams, rel, "\uE00F", "\\@ngeqslant");
      defineSymbol(math, ams, rel, "\uE00E", "\\@ngeqq");
      defineSymbol(math, ams, rel, "\u2A88", "\\gneq", true);
      defineSymbol(math, ams, rel, "\u2269", "\\gneqq", true);
      defineSymbol(math, ams, rel, "\uE00D", "\\@gvertneqq");
      defineSymbol(math, ams, rel, "\u22E7", "\\gnsim", true);
      defineSymbol(math, ams, rel, "\u2A8A", "\\gnapprox", true);
      defineSymbol(math, ams, rel, "\u2281", "\\nsucc", true);
      defineSymbol(math, ams, rel, "\u22E1", "\\nsucceq", true);
      defineSymbol(math, ams, rel, "\u22E9", "\\succnsim", true);
      defineSymbol(math, ams, rel, "\u2ABA", "\\succnapprox", true);
      defineSymbol(math, ams, rel, "\u2246", "\\ncong", true);
      defineSymbol(math, ams, rel, "\uE007", "\\@nshortparallel");
      defineSymbol(math, ams, rel, "\u2226", "\\nparallel", true);
      defineSymbol(math, ams, rel, "\u22AF", "\\nVDash", true);
      defineSymbol(math, ams, rel, "\u22EB", "\\ntriangleright");
      defineSymbol(math, ams, rel, "\u22ED", "\\ntrianglerighteq", true);
      defineSymbol(math, ams, rel, "\uE018", "\\@nsupseteqq");
      defineSymbol(math, ams, rel, "\u228B", "\\supsetneq", true);
      defineSymbol(math, ams, rel, "\uE01B", "\\@varsupsetneq");
      defineSymbol(math, ams, rel, "\u2ACC", "\\supsetneqq", true);
      defineSymbol(math, ams, rel, "\uE019", "\\@varsupsetneqq");
      defineSymbol(math, ams, rel, "\u22AE", "\\nVdash", true);
      defineSymbol(math, ams, rel, "\u2AB5", "\\precneqq", true);
      defineSymbol(math, ams, rel, "\u2AB6", "\\succneqq", true);
      defineSymbol(math, ams, rel, "\uE016", "\\@nsubseteqq");
      defineSymbol(math, ams, bin, "\u22B4", "\\unlhd");
      defineSymbol(math, ams, bin, "\u22B5", "\\unrhd");
      defineSymbol(math, ams, rel, "\u219A", "\\nleftarrow", true);
      defineSymbol(math, ams, rel, "\u219B", "\\nrightarrow", true);
      defineSymbol(math, ams, rel, "\u21CD", "\\nLeftarrow", true);
      defineSymbol(math, ams, rel, "\u21CF", "\\nRightarrow", true);
      defineSymbol(math, ams, rel, "\u21AE", "\\nleftrightarrow", true);
      defineSymbol(math, ams, rel, "\u21CE", "\\nLeftrightarrow", true);
      defineSymbol(math, ams, rel, "\u25B3", "\\vartriangle");
      defineSymbol(math, ams, textord, "\u210F", "\\hslash");
      defineSymbol(math, ams, textord, "\u25BD", "\\triangledown");
      defineSymbol(math, ams, textord, "\u25CA", "\\lozenge");
      defineSymbol(math, ams, textord, "\u24C8", "\\circledS");
      defineSymbol(math, ams, textord, "\xAE", "\\circledR");
      defineSymbol(text2, ams, textord, "\xAE", "\\circledR");
      defineSymbol(math, ams, textord, "\u2221", "\\measuredangle", true);
      defineSymbol(math, ams, textord, "\u2204", "\\nexists");
      defineSymbol(math, ams, textord, "\u2127", "\\mho");
      defineSymbol(math, ams, textord, "\u2132", "\\Finv", true);
      defineSymbol(math, ams, textord, "\u2141", "\\Game", true);
      defineSymbol(math, ams, textord, "\u2035", "\\backprime");
      defineSymbol(math, ams, textord, "\u25B2", "\\blacktriangle");
      defineSymbol(math, ams, textord, "\u25BC", "\\blacktriangledown");
      defineSymbol(math, ams, textord, "\u25A0", "\\blacksquare");
      defineSymbol(math, ams, textord, "\u29EB", "\\blacklozenge");
      defineSymbol(math, ams, textord, "\u2605", "\\bigstar");
      defineSymbol(math, ams, textord, "\u2222", "\\sphericalangle", true);
      defineSymbol(math, ams, textord, "\u2201", "\\complement", true);
      defineSymbol(math, ams, textord, "\xF0", "\\eth", true);
      defineSymbol(text2, main, textord, "\xF0", "\xF0");
      defineSymbol(math, ams, textord, "\u2571", "\\diagup");
      defineSymbol(math, ams, textord, "\u2572", "\\diagdown");
      defineSymbol(math, ams, textord, "\u25A1", "\\square");
      defineSymbol(math, ams, textord, "\u25A1", "\\Box");
      defineSymbol(math, ams, textord, "\u25CA", "\\Diamond");
      defineSymbol(math, ams, textord, "\xA5", "\\yen", true);
      defineSymbol(text2, ams, textord, "\xA5", "\\yen", true);
      defineSymbol(math, ams, textord, "\u2713", "\\checkmark", true);
      defineSymbol(text2, ams, textord, "\u2713", "\\checkmark");
      defineSymbol(math, ams, textord, "\u2136", "\\beth", true);
      defineSymbol(math, ams, textord, "\u2138", "\\daleth", true);
      defineSymbol(math, ams, textord, "\u2137", "\\gimel", true);
      defineSymbol(math, ams, textord, "\u03DD", "\\digamma", true);
      defineSymbol(math, ams, textord, "\u03F0", "\\varkappa");
      defineSymbol(math, ams, open, "\u250C", "\\@ulcorner", true);
      defineSymbol(math, ams, close, "\u2510", "\\@urcorner", true);
      defineSymbol(math, ams, open, "\u2514", "\\@llcorner", true);
      defineSymbol(math, ams, close, "\u2518", "\\@lrcorner", true);
      defineSymbol(math, ams, rel, "\u2266", "\\leqq", true);
      defineSymbol(math, ams, rel, "\u2A7D", "\\leqslant", true);
      defineSymbol(math, ams, rel, "\u2A95", "\\eqslantless", true);
      defineSymbol(math, ams, rel, "\u2272", "\\lesssim", true);
      defineSymbol(math, ams, rel, "\u2A85", "\\lessapprox", true);
      defineSymbol(math, ams, rel, "\u224A", "\\approxeq", true);
      defineSymbol(math, ams, bin, "\u22D6", "\\lessdot");
      defineSymbol(math, ams, rel, "\u22D8", "\\lll", true);
      defineSymbol(math, ams, rel, "\u2276", "\\lessgtr", true);
      defineSymbol(math, ams, rel, "\u22DA", "\\lesseqgtr", true);
      defineSymbol(math, ams, rel, "\u2A8B", "\\lesseqqgtr", true);
      defineSymbol(math, ams, rel, "\u2251", "\\doteqdot");
      defineSymbol(math, ams, rel, "\u2253", "\\risingdotseq", true);
      defineSymbol(math, ams, rel, "\u2252", "\\fallingdotseq", true);
      defineSymbol(math, ams, rel, "\u223D", "\\backsim", true);
      defineSymbol(math, ams, rel, "\u22CD", "\\backsimeq", true);
      defineSymbol(math, ams, rel, "\u2AC5", "\\subseteqq", true);
      defineSymbol(math, ams, rel, "\u22D0", "\\Subset", true);
      defineSymbol(math, ams, rel, "\u228F", "\\sqsubset", true);
      defineSymbol(math, ams, rel, "\u227C", "\\preccurlyeq", true);
      defineSymbol(math, ams, rel, "\u22DE", "\\curlyeqprec", true);
      defineSymbol(math, ams, rel, "\u227E", "\\precsim", true);
      defineSymbol(math, ams, rel, "\u2AB7", "\\precapprox", true);
      defineSymbol(math, ams, rel, "\u22B2", "\\vartriangleleft");
      defineSymbol(math, ams, rel, "\u22B4", "\\trianglelefteq");
      defineSymbol(math, ams, rel, "\u22A8", "\\vDash", true);
      defineSymbol(math, ams, rel, "\u22AA", "\\Vvdash", true);
      defineSymbol(math, ams, rel, "\u2323", "\\smallsmile");
      defineSymbol(math, ams, rel, "\u2322", "\\smallfrown");
      defineSymbol(math, ams, rel, "\u224F", "\\bumpeq", true);
      defineSymbol(math, ams, rel, "\u224E", "\\Bumpeq", true);
      defineSymbol(math, ams, rel, "\u2267", "\\geqq", true);
      defineSymbol(math, ams, rel, "\u2A7E", "\\geqslant", true);
      defineSymbol(math, ams, rel, "\u2A96", "\\eqslantgtr", true);
      defineSymbol(math, ams, rel, "\u2273", "\\gtrsim", true);
      defineSymbol(math, ams, rel, "\u2A86", "\\gtrapprox", true);
      defineSymbol(math, ams, bin, "\u22D7", "\\gtrdot");
      defineSymbol(math, ams, rel, "\u22D9", "\\ggg", true);
      defineSymbol(math, ams, rel, "\u2277", "\\gtrless", true);
      defineSymbol(math, ams, rel, "\u22DB", "\\gtreqless", true);
      defineSymbol(math, ams, rel, "\u2A8C", "\\gtreqqless", true);
      defineSymbol(math, ams, rel, "\u2256", "\\eqcirc", true);
      defineSymbol(math, ams, rel, "\u2257", "\\circeq", true);
      defineSymbol(math, ams, rel, "\u225C", "\\triangleq", true);
      defineSymbol(math, ams, rel, "\u223C", "\\thicksim");
      defineSymbol(math, ams, rel, "\u2248", "\\thickapprox");
      defineSymbol(math, ams, rel, "\u2AC6", "\\supseteqq", true);
      defineSymbol(math, ams, rel, "\u22D1", "\\Supset", true);
      defineSymbol(math, ams, rel, "\u2290", "\\sqsupset", true);
      defineSymbol(math, ams, rel, "\u227D", "\\succcurlyeq", true);
      defineSymbol(math, ams, rel, "\u22DF", "\\curlyeqsucc", true);
      defineSymbol(math, ams, rel, "\u227F", "\\succsim", true);
      defineSymbol(math, ams, rel, "\u2AB8", "\\succapprox", true);
      defineSymbol(math, ams, rel, "\u22B3", "\\vartriangleright");
      defineSymbol(math, ams, rel, "\u22B5", "\\trianglerighteq");
      defineSymbol(math, ams, rel, "\u22A9", "\\Vdash", true);
      defineSymbol(math, ams, rel, "\u2223", "\\shortmid");
      defineSymbol(math, ams, rel, "\u2225", "\\shortparallel");
      defineSymbol(math, ams, rel, "\u226C", "\\between", true);
      defineSymbol(math, ams, rel, "\u22D4", "\\pitchfork", true);
      defineSymbol(math, ams, rel, "\u221D", "\\varpropto");
      defineSymbol(math, ams, rel, "\u25C0", "\\blacktriangleleft");
      defineSymbol(math, ams, rel, "\u2234", "\\therefore", true);
      defineSymbol(math, ams, rel, "\u220D", "\\backepsilon");
      defineSymbol(math, ams, rel, "\u25B6", "\\blacktriangleright");
      defineSymbol(math, ams, rel, "\u2235", "\\because", true);
      defineSymbol(math, ams, rel, "\u22D8", "\\llless");
      defineSymbol(math, ams, rel, "\u22D9", "\\gggtr");
      defineSymbol(math, ams, bin, "\u22B2", "\\lhd");
      defineSymbol(math, ams, bin, "\u22B3", "\\rhd");
      defineSymbol(math, ams, rel, "\u2242", "\\eqsim", true);
      defineSymbol(math, main, rel, "\u22C8", "\\Join");
      defineSymbol(math, ams, rel, "\u2251", "\\Doteq", true);
      defineSymbol(math, ams, bin, "\u2214", "\\dotplus", true);
      defineSymbol(math, ams, bin, "\u2216", "\\smallsetminus");
      defineSymbol(math, ams, bin, "\u22D2", "\\Cap", true);
      defineSymbol(math, ams, bin, "\u22D3", "\\Cup", true);
      defineSymbol(math, ams, bin, "\u2A5E", "\\doublebarwedge", true);
      defineSymbol(math, ams, bin, "\u229F", "\\boxminus", true);
      defineSymbol(math, ams, bin, "\u229E", "\\boxplus", true);
      defineSymbol(math, ams, bin, "\u22C7", "\\divideontimes", true);
      defineSymbol(math, ams, bin, "\u22C9", "\\ltimes", true);
      defineSymbol(math, ams, bin, "\u22CA", "\\rtimes", true);
      defineSymbol(math, ams, bin, "\u22CB", "\\leftthreetimes", true);
      defineSymbol(math, ams, bin, "\u22CC", "\\rightthreetimes", true);
      defineSymbol(math, ams, bin, "\u22CF", "\\curlywedge", true);
      defineSymbol(math, ams, bin, "\u22CE", "\\curlyvee", true);
      defineSymbol(math, ams, bin, "\u229D", "\\circleddash", true);
      defineSymbol(math, ams, bin, "\u229B", "\\circledast", true);
      defineSymbol(math, ams, bin, "\u22C5", "\\centerdot");
      defineSymbol(math, ams, bin, "\u22BA", "\\intercal", true);
      defineSymbol(math, ams, bin, "\u22D2", "\\doublecap");
      defineSymbol(math, ams, bin, "\u22D3", "\\doublecup");
      defineSymbol(math, ams, bin, "\u22A0", "\\boxtimes", true);
      defineSymbol(math, ams, rel, "\u21E2", "\\dashrightarrow", true);
      defineSymbol(math, ams, rel, "\u21E0", "\\dashleftarrow", true);
      defineSymbol(math, ams, rel, "\u21C7", "\\leftleftarrows", true);
      defineSymbol(math, ams, rel, "\u21C6", "\\leftrightarrows", true);
      defineSymbol(math, ams, rel, "\u21DA", "\\Lleftarrow", true);
      defineSymbol(math, ams, rel, "\u219E", "\\twoheadleftarrow", true);
      defineSymbol(math, ams, rel, "\u21A2", "\\leftarrowtail", true);
      defineSymbol(math, ams, rel, "\u21AB", "\\looparrowleft", true);
      defineSymbol(math, ams, rel, "\u21CB", "\\leftrightharpoons", true);
      defineSymbol(math, ams, rel, "\u21B6", "\\curvearrowleft", true);
      defineSymbol(math, ams, rel, "\u21BA", "\\circlearrowleft", true);
      defineSymbol(math, ams, rel, "\u21B0", "\\Lsh", true);
      defineSymbol(math, ams, rel, "\u21C8", "\\upuparrows", true);
      defineSymbol(math, ams, rel, "\u21BF", "\\upharpoonleft", true);
      defineSymbol(math, ams, rel, "\u21C3", "\\downharpoonleft", true);
      defineSymbol(math, main, rel, "\u22B6", "\\origof", true);
      defineSymbol(math, main, rel, "\u22B7", "\\imageof", true);
      defineSymbol(math, ams, rel, "\u22B8", "\\multimap", true);
      defineSymbol(math, ams, rel, "\u21AD", "\\leftrightsquigarrow", true);
      defineSymbol(math, ams, rel, "\u21C9", "\\rightrightarrows", true);
      defineSymbol(math, ams, rel, "\u21C4", "\\rightleftarrows", true);
      defineSymbol(math, ams, rel, "\u21A0", "\\twoheadrightarrow", true);
      defineSymbol(math, ams, rel, "\u21A3", "\\rightarrowtail", true);
      defineSymbol(math, ams, rel, "\u21AC", "\\looparrowright", true);
      defineSymbol(math, ams, rel, "\u21B7", "\\curvearrowright", true);
      defineSymbol(math, ams, rel, "\u21BB", "\\circlearrowright", true);
      defineSymbol(math, ams, rel, "\u21B1", "\\Rsh", true);
      defineSymbol(math, ams, rel, "\u21CA", "\\downdownarrows", true);
      defineSymbol(math, ams, rel, "\u21BE", "\\upharpoonright", true);
      defineSymbol(math, ams, rel, "\u21C2", "\\downharpoonright", true);
      defineSymbol(math, ams, rel, "\u21DD", "\\rightsquigarrow", true);
      defineSymbol(math, ams, rel, "\u21DD", "\\leadsto");
      defineSymbol(math, ams, rel, "\u21DB", "\\Rrightarrow", true);
      defineSymbol(math, ams, rel, "\u21BE", "\\restriction");
      defineSymbol(math, main, textord, "\u2018", "`");
      defineSymbol(math, main, textord, "$", "\\$");
      defineSymbol(text2, main, textord, "$", "\\$");
      defineSymbol(text2, main, textord, "$", "\\textdollar");
      defineSymbol(math, main, textord, "%", "\\%");
      defineSymbol(text2, main, textord, "%", "\\%");
      defineSymbol(math, main, textord, "_", "\\_");
      defineSymbol(text2, main, textord, "_", "\\_");
      defineSymbol(text2, main, textord, "_", "\\textunderscore");
      defineSymbol(math, main, textord, "\u2220", "\\angle", true);
      defineSymbol(math, main, textord, "\u221E", "\\infty", true);
      defineSymbol(math, main, textord, "\u2032", "\\prime");
      defineSymbol(math, main, textord, "\u25B3", "\\triangle");
      defineSymbol(math, main, textord, "\u0393", "\\Gamma", true);
      defineSymbol(math, main, textord, "\u0394", "\\Delta", true);
      defineSymbol(math, main, textord, "\u0398", "\\Theta", true);
      defineSymbol(math, main, textord, "\u039B", "\\Lambda", true);
      defineSymbol(math, main, textord, "\u039E", "\\Xi", true);
      defineSymbol(math, main, textord, "\u03A0", "\\Pi", true);
      defineSymbol(math, main, textord, "\u03A3", "\\Sigma", true);
      defineSymbol(math, main, textord, "\u03A5", "\\Upsilon", true);
      defineSymbol(math, main, textord, "\u03A6", "\\Phi", true);
      defineSymbol(math, main, textord, "\u03A8", "\\Psi", true);
      defineSymbol(math, main, textord, "\u03A9", "\\Omega", true);
      defineSymbol(math, main, textord, "A", "\u0391");
      defineSymbol(math, main, textord, "B", "\u0392");
      defineSymbol(math, main, textord, "E", "\u0395");
      defineSymbol(math, main, textord, "Z", "\u0396");
      defineSymbol(math, main, textord, "H", "\u0397");
      defineSymbol(math, main, textord, "I", "\u0399");
      defineSymbol(math, main, textord, "K", "\u039A");
      defineSymbol(math, main, textord, "M", "\u039C");
      defineSymbol(math, main, textord, "N", "\u039D");
      defineSymbol(math, main, textord, "O", "\u039F");
      defineSymbol(math, main, textord, "P", "\u03A1");
      defineSymbol(math, main, textord, "T", "\u03A4");
      defineSymbol(math, main, textord, "X", "\u03A7");
      defineSymbol(math, main, textord, "\xAC", "\\neg", true);
      defineSymbol(math, main, textord, "\xAC", "\\lnot");
      defineSymbol(math, main, textord, "\u22A4", "\\top");
      defineSymbol(math, main, textord, "\u22A5", "\\bot");
      defineSymbol(math, main, textord, "\u2205", "\\emptyset");
      defineSymbol(math, ams, textord, "\u2205", "\\varnothing");
      defineSymbol(math, main, mathord, "\u03B1", "\\alpha", true);
      defineSymbol(math, main, mathord, "\u03B2", "\\beta", true);
      defineSymbol(math, main, mathord, "\u03B3", "\\gamma", true);
      defineSymbol(math, main, mathord, "\u03B4", "\\delta", true);
      defineSymbol(math, main, mathord, "\u03F5", "\\epsilon", true);
      defineSymbol(math, main, mathord, "\u03B6", "\\zeta", true);
      defineSymbol(math, main, mathord, "\u03B7", "\\eta", true);
      defineSymbol(math, main, mathord, "\u03B8", "\\theta", true);
      defineSymbol(math, main, mathord, "\u03B9", "\\iota", true);
      defineSymbol(math, main, mathord, "\u03BA", "\\kappa", true);
      defineSymbol(math, main, mathord, "\u03BB", "\\lambda", true);
      defineSymbol(math, main, mathord, "\u03BC", "\\mu", true);
      defineSymbol(math, main, mathord, "\u03BD", "\\nu", true);
      defineSymbol(math, main, mathord, "\u03BE", "\\xi", true);
      defineSymbol(math, main, mathord, "\u03BF", "\\omicron", true);
      defineSymbol(math, main, mathord, "\u03C0", "\\pi", true);
      defineSymbol(math, main, mathord, "\u03C1", "\\rho", true);
      defineSymbol(math, main, mathord, "\u03C3", "\\sigma", true);
      defineSymbol(math, main, mathord, "\u03C4", "\\tau", true);
      defineSymbol(math, main, mathord, "\u03C5", "\\upsilon", true);
      defineSymbol(math, main, mathord, "\u03D5", "\\phi", true);
      defineSymbol(math, main, mathord, "\u03C7", "\\chi", true);
      defineSymbol(math, main, mathord, "\u03C8", "\\psi", true);
      defineSymbol(math, main, mathord, "\u03C9", "\\omega", true);
      defineSymbol(math, main, mathord, "\u03B5", "\\varepsilon", true);
      defineSymbol(math, main, mathord, "\u03D1", "\\vartheta", true);
      defineSymbol(math, main, mathord, "\u03D6", "\\varpi", true);
      defineSymbol(math, main, mathord, "\u03F1", "\\varrho", true);
      defineSymbol(math, main, mathord, "\u03C2", "\\varsigma", true);
      defineSymbol(math, main, mathord, "\u03C6", "\\varphi", true);
      defineSymbol(math, main, bin, "\u2217", "*", true);
      defineSymbol(math, main, bin, "+", "+");
      defineSymbol(math, main, bin, "\u2212", "-", true);
      defineSymbol(math, main, bin, "\u22C5", "\\cdot", true);
      defineSymbol(math, main, bin, "\u2218", "\\circ", true);
      defineSymbol(math, main, bin, "\xF7", "\\div", true);
      defineSymbol(math, main, bin, "\xB1", "\\pm", true);
      defineSymbol(math, main, bin, "\xD7", "\\times", true);
      defineSymbol(math, main, bin, "\u2229", "\\cap", true);
      defineSymbol(math, main, bin, "\u222A", "\\cup", true);
      defineSymbol(math, main, bin, "\u2216", "\\setminus", true);
      defineSymbol(math, main, bin, "\u2227", "\\land");
      defineSymbol(math, main, bin, "\u2228", "\\lor");
      defineSymbol(math, main, bin, "\u2227", "\\wedge", true);
      defineSymbol(math, main, bin, "\u2228", "\\vee", true);
      defineSymbol(math, main, textord, "\u221A", "\\surd");
      defineSymbol(math, main, open, "\u27E8", "\\langle", true);
      defineSymbol(math, main, open, "\u2223", "\\lvert");
      defineSymbol(math, main, open, "\u2225", "\\lVert");
      defineSymbol(math, main, close, "?", "?");
      defineSymbol(math, main, close, "!", "!");
      defineSymbol(math, main, close, "\u27E9", "\\rangle", true);
      defineSymbol(math, main, close, "\u2223", "\\rvert");
      defineSymbol(math, main, close, "\u2225", "\\rVert");
      defineSymbol(math, main, rel, "=", "=");
      defineSymbol(math, main, rel, ":", ":");
      defineSymbol(math, main, rel, "\u2248", "\\approx", true);
      defineSymbol(math, main, rel, "\u2245", "\\cong", true);
      defineSymbol(math, main, rel, "\u2265", "\\ge");
      defineSymbol(math, main, rel, "\u2265", "\\geq", true);
      defineSymbol(math, main, rel, "\u2190", "\\gets");
      defineSymbol(math, main, rel, ">", "\\gt", true);
      defineSymbol(math, main, rel, "\u2208", "\\in", true);
      defineSymbol(math, main, rel, "\uE020", "\\@not");
      defineSymbol(math, main, rel, "\u2282", "\\subset", true);
      defineSymbol(math, main, rel, "\u2283", "\\supset", true);
      defineSymbol(math, main, rel, "\u2286", "\\subseteq", true);
      defineSymbol(math, main, rel, "\u2287", "\\supseteq", true);
      defineSymbol(math, ams, rel, "\u2288", "\\nsubseteq", true);
      defineSymbol(math, ams, rel, "\u2289", "\\nsupseteq", true);
      defineSymbol(math, main, rel, "\u22A8", "\\models");
      defineSymbol(math, main, rel, "\u2190", "\\leftarrow", true);
      defineSymbol(math, main, rel, "\u2264", "\\le");
      defineSymbol(math, main, rel, "\u2264", "\\leq", true);
      defineSymbol(math, main, rel, "<", "\\lt", true);
      defineSymbol(math, main, rel, "\u2192", "\\rightarrow", true);
      defineSymbol(math, main, rel, "\u2192", "\\to");
      defineSymbol(math, ams, rel, "\u2271", "\\ngeq", true);
      defineSymbol(math, ams, rel, "\u2270", "\\nleq", true);
      defineSymbol(math, main, spacing, "\xA0", "\\ ");
      defineSymbol(math, main, spacing, "\xA0", "\\space");
      defineSymbol(math, main, spacing, "\xA0", "\\nobreakspace");
      defineSymbol(text2, main, spacing, "\xA0", "\\ ");
      defineSymbol(text2, main, spacing, "\xA0", " ");
      defineSymbol(text2, main, spacing, "\xA0", "\\space");
      defineSymbol(text2, main, spacing, "\xA0", "\\nobreakspace");
      defineSymbol(math, main, spacing, null, "\\nobreak");
      defineSymbol(math, main, spacing, null, "\\allowbreak");
      defineSymbol(math, main, punct, ",", ",");
      defineSymbol(math, main, punct, ";", ";");
      defineSymbol(math, ams, bin, "\u22BC", "\\barwedge", true);
      defineSymbol(math, ams, bin, "\u22BB", "\\veebar", true);
      defineSymbol(math, main, bin, "\u2299", "\\odot", true);
      defineSymbol(math, main, bin, "\u2295", "\\oplus", true);
      defineSymbol(math, main, bin, "\u2297", "\\otimes", true);
      defineSymbol(math, main, textord, "\u2202", "\\partial", true);
      defineSymbol(math, main, bin, "\u2298", "\\oslash", true);
      defineSymbol(math, ams, bin, "\u229A", "\\circledcirc", true);
      defineSymbol(math, ams, bin, "\u22A1", "\\boxdot", true);
      defineSymbol(math, main, bin, "\u25B3", "\\bigtriangleup");
      defineSymbol(math, main, bin, "\u25BD", "\\bigtriangledown");
      defineSymbol(math, main, bin, "\u2020", "\\dagger");
      defineSymbol(math, main, bin, "\u22C4", "\\diamond");
      defineSymbol(math, main, bin, "\u22C6", "\\star");
      defineSymbol(math, main, bin, "\u25C3", "\\triangleleft");
      defineSymbol(math, main, bin, "\u25B9", "\\triangleright");
      defineSymbol(math, main, open, "{", "\\{");
      defineSymbol(text2, main, textord, "{", "\\{");
      defineSymbol(text2, main, textord, "{", "\\textbraceleft");
      defineSymbol(math, main, close, "}", "\\}");
      defineSymbol(text2, main, textord, "}", "\\}");
      defineSymbol(text2, main, textord, "}", "\\textbraceright");
      defineSymbol(math, main, open, "{", "\\lbrace");
      defineSymbol(math, main, close, "}", "\\rbrace");
      defineSymbol(math, main, open, "[", "\\lbrack", true);
      defineSymbol(text2, main, textord, "[", "\\lbrack", true);
      defineSymbol(math, main, close, "]", "\\rbrack", true);
      defineSymbol(text2, main, textord, "]", "\\rbrack", true);
      defineSymbol(math, main, open, "(", "\\lparen", true);
      defineSymbol(math, main, close, ")", "\\rparen", true);
      defineSymbol(text2, main, textord, "<", "\\textless", true);
      defineSymbol(text2, main, textord, ">", "\\textgreater", true);
      defineSymbol(math, main, open, "\u230A", "\\lfloor", true);
      defineSymbol(math, main, close, "\u230B", "\\rfloor", true);
      defineSymbol(math, main, open, "\u2308", "\\lceil", true);
      defineSymbol(math, main, close, "\u2309", "\\rceil", true);
      defineSymbol(math, main, textord, "\\", "\\backslash");
      defineSymbol(math, main, textord, "\u2223", "|");
      defineSymbol(math, main, textord, "\u2223", "\\vert");
      defineSymbol(text2, main, textord, "|", "\\textbar", true);
      defineSymbol(math, main, textord, "\u2225", "\\|");
      defineSymbol(math, main, textord, "\u2225", "\\Vert");
      defineSymbol(text2, main, textord, "\u2225", "\\textbardbl");
      defineSymbol(text2, main, textord, "~", "\\textasciitilde");
      defineSymbol(text2, main, textord, "\\", "\\textbackslash");
      defineSymbol(text2, main, textord, "^", "\\textasciicircum");
      defineSymbol(math, main, rel, "\u2191", "\\uparrow", true);
      defineSymbol(math, main, rel, "\u21D1", "\\Uparrow", true);
      defineSymbol(math, main, rel, "\u2193", "\\downarrow", true);
      defineSymbol(math, main, rel, "\u21D3", "\\Downarrow", true);
      defineSymbol(math, main, rel, "\u2195", "\\updownarrow", true);
      defineSymbol(math, main, rel, "\u21D5", "\\Updownarrow", true);
      defineSymbol(math, main, op, "\u2210", "\\coprod");
      defineSymbol(math, main, op, "\u22C1", "\\bigvee");
      defineSymbol(math, main, op, "\u22C0", "\\bigwedge");
      defineSymbol(math, main, op, "\u2A04", "\\biguplus");
      defineSymbol(math, main, op, "\u22C2", "\\bigcap");
      defineSymbol(math, main, op, "\u22C3", "\\bigcup");
      defineSymbol(math, main, op, "\u222B", "\\int");
      defineSymbol(math, main, op, "\u222B", "\\intop");
      defineSymbol(math, main, op, "\u222C", "\\iint");
      defineSymbol(math, main, op, "\u222D", "\\iiint");
      defineSymbol(math, main, op, "\u220F", "\\prod");
      defineSymbol(math, main, op, "\u2211", "\\sum");
      defineSymbol(math, main, op, "\u2A02", "\\bigotimes");
      defineSymbol(math, main, op, "\u2A01", "\\bigoplus");
      defineSymbol(math, main, op, "\u2A00", "\\bigodot");
      defineSymbol(math, main, op, "\u222E", "\\oint");
      defineSymbol(math, main, op, "\u222F", "\\oiint");
      defineSymbol(math, main, op, "\u2230", "\\oiiint");
      defineSymbol(math, main, op, "\u2A06", "\\bigsqcup");
      defineSymbol(math, main, op, "\u222B", "\\smallint");
      defineSymbol(text2, main, inner, "\u2026", "\\textellipsis");
      defineSymbol(math, main, inner, "\u2026", "\\mathellipsis");
      defineSymbol(text2, main, inner, "\u2026", "\\ldots", true);
      defineSymbol(math, main, inner, "\u2026", "\\ldots", true);
      defineSymbol(math, main, inner, "\u22EF", "\\@cdots", true);
      defineSymbol(math, main, inner, "\u22F1", "\\ddots", true);
      defineSymbol(math, main, textord, "\u22EE", "\\varvdots");
      defineSymbol(math, main, accent, "\u02CA", "\\acute");
      defineSymbol(math, main, accent, "\u02CB", "\\grave");
      defineSymbol(math, main, accent, "\xA8", "\\ddot");
      defineSymbol(math, main, accent, "~", "\\tilde");
      defineSymbol(math, main, accent, "\u02C9", "\\bar");
      defineSymbol(math, main, accent, "\u02D8", "\\breve");
      defineSymbol(math, main, accent, "\u02C7", "\\check");
      defineSymbol(math, main, accent, "^", "\\hat");
      defineSymbol(math, main, accent, "\u20D7", "\\vec");
      defineSymbol(math, main, accent, "\u02D9", "\\dot");
      defineSymbol(math, main, accent, "\u02DA", "\\mathring");
      defineSymbol(math, main, mathord, "\uE131", "\\@imath");
      defineSymbol(math, main, mathord, "\uE237", "\\@jmath");
      defineSymbol(math, main, textord, "\u0131", "\u0131");
      defineSymbol(math, main, textord, "\u0237", "\u0237");
      defineSymbol(text2, main, textord, "\u0131", "\\i", true);
      defineSymbol(text2, main, textord, "\u0237", "\\j", true);
      defineSymbol(text2, main, textord, "\xDF", "\\ss", true);
      defineSymbol(text2, main, textord, "\xE6", "\\ae", true);
      defineSymbol(text2, main, textord, "\u0153", "\\oe", true);
      defineSymbol(text2, main, textord, "\xF8", "\\o", true);
      defineSymbol(text2, main, textord, "\xC6", "\\AE", true);
      defineSymbol(text2, main, textord, "\u0152", "\\OE", true);
      defineSymbol(text2, main, textord, "\xD8", "\\O", true);
      defineSymbol(text2, main, accent, "\u02CA", "\\'");
      defineSymbol(text2, main, accent, "\u02CB", "\\`");
      defineSymbol(text2, main, accent, "\u02C6", "\\^");
      defineSymbol(text2, main, accent, "\u02DC", "\\~");
      defineSymbol(text2, main, accent, "\u02C9", "\\=");
      defineSymbol(text2, main, accent, "\u02D8", "\\u");
      defineSymbol(text2, main, accent, "\u02D9", "\\.");
      defineSymbol(text2, main, accent, "\xB8", "\\c");
      defineSymbol(text2, main, accent, "\u02DA", "\\r");
      defineSymbol(text2, main, accent, "\u02C7", "\\v");
      defineSymbol(text2, main, accent, "\xA8", '\\"');
      defineSymbol(text2, main, accent, "\u02DD", "\\H");
      defineSymbol(text2, main, accent, "\u25EF", "\\textcircled");
      ligatures = {
        "--": true,
        "---": true,
        "``": true,
        "''": true
      };
      defineSymbol(text2, main, textord, "\u2013", "--", true);
      defineSymbol(text2, main, textord, "\u2013", "\\textendash");
      defineSymbol(text2, main, textord, "\u2014", "---", true);
      defineSymbol(text2, main, textord, "\u2014", "\\textemdash");
      defineSymbol(text2, main, textord, "\u2018", "`", true);
      defineSymbol(text2, main, textord, "\u2018", "\\textquoteleft");
      defineSymbol(text2, main, textord, "\u2019", "'", true);
      defineSymbol(text2, main, textord, "\u2019", "\\textquoteright");
      defineSymbol(text2, main, textord, "\u201C", "``", true);
      defineSymbol(text2, main, textord, "\u201C", "\\textquotedblleft");
      defineSymbol(text2, main, textord, "\u201D", "''", true);
      defineSymbol(text2, main, textord, "\u201D", "\\textquotedblright");
      defineSymbol(math, main, textord, "\xB0", "\\degree", true);
      defineSymbol(text2, main, textord, "\xB0", "\\degree");
      defineSymbol(text2, main, textord, "\xB0", "\\textdegree", true);
      defineSymbol(math, main, textord, "\xA3", "\\pounds");
      defineSymbol(math, main, textord, "\xA3", "\\mathsterling", true);
      defineSymbol(text2, main, textord, "\xA3", "\\pounds");
      defineSymbol(text2, main, textord, "\xA3", "\\textsterling", true);
      defineSymbol(math, ams, textord, "\u2720", "\\maltese");
      defineSymbol(text2, ams, textord, "\u2720", "\\maltese");
      mathTextSymbols = '0123456789/@."';
      for (i2 = 0; i2 < mathTextSymbols.length; i2++) {
        ch = mathTextSymbols.charAt(i2);
        defineSymbol(math, main, textord, ch, ch);
      }
      textSymbols = '0123456789!@*()-=+";:?/.,';
      for (_i = 0; _i < textSymbols.length; _i++) {
        _ch = textSymbols.charAt(_i);
        defineSymbol(text2, main, textord, _ch, _ch);
      }
      letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
      for (_i2 = 0; _i2 < letters.length; _i2++) {
        _ch2 = letters.charAt(_i2);
        defineSymbol(math, main, mathord, _ch2, _ch2);
        defineSymbol(text2, main, textord, _ch2, _ch2);
      }
      defineSymbol(math, ams, textord, "C", "\u2102");
      defineSymbol(text2, ams, textord, "C", "\u2102");
      defineSymbol(math, ams, textord, "H", "\u210D");
      defineSymbol(text2, ams, textord, "H", "\u210D");
      defineSymbol(math, ams, textord, "N", "\u2115");
      defineSymbol(text2, ams, textord, "N", "\u2115");
      defineSymbol(math, ams, textord, "P", "\u2119");
      defineSymbol(text2, ams, textord, "P", "\u2119");
      defineSymbol(math, ams, textord, "Q", "\u211A");
      defineSymbol(text2, ams, textord, "Q", "\u211A");
      defineSymbol(math, ams, textord, "R", "\u211D");
      defineSymbol(text2, ams, textord, "R", "\u211D");
      defineSymbol(math, ams, textord, "Z", "\u2124");
      defineSymbol(text2, ams, textord, "Z", "\u2124");
      defineSymbol(math, main, mathord, "h", "\u210E");
      defineSymbol(text2, main, mathord, "h", "\u210E");
      wideChar = "";
      for (_i3 = 0; _i3 < letters.length; _i3++) {
        _ch3 = letters.charAt(_i3);
        wideChar = String.fromCharCode(55349, 56320 + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(text2, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56372 + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(text2, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56424 + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(text2, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56580 + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(text2, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56684 + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(text2, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56736 + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(text2, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56788 + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(text2, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56840 + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(text2, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56944 + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(text2, main, textord, _ch3, wideChar);
        if (_i3 < 26) {
          wideChar = String.fromCharCode(55349, 56632 + _i3);
          defineSymbol(math, main, mathord, _ch3, wideChar);
          defineSymbol(text2, main, textord, _ch3, wideChar);
          wideChar = String.fromCharCode(55349, 56476 + _i3);
          defineSymbol(math, main, mathord, _ch3, wideChar);
          defineSymbol(text2, main, textord, _ch3, wideChar);
        }
      }
      wideChar = String.fromCharCode(55349, 56668);
      defineSymbol(math, main, mathord, "k", wideChar);
      defineSymbol(text2, main, textord, "k", wideChar);
      for (_i4 = 0; _i4 < 10; _i4++) {
        _ch4 = _i4.toString();
        wideChar = String.fromCharCode(55349, 57294 + _i4);
        defineSymbol(math, main, mathord, _ch4, wideChar);
        defineSymbol(text2, main, textord, _ch4, wideChar);
        wideChar = String.fromCharCode(55349, 57314 + _i4);
        defineSymbol(math, main, mathord, _ch4, wideChar);
        defineSymbol(text2, main, textord, _ch4, wideChar);
        wideChar = String.fromCharCode(55349, 57324 + _i4);
        defineSymbol(math, main, mathord, _ch4, wideChar);
        defineSymbol(text2, main, textord, _ch4, wideChar);
        wideChar = String.fromCharCode(55349, 57334 + _i4);
        defineSymbol(math, main, mathord, _ch4, wideChar);
        defineSymbol(text2, main, textord, _ch4, wideChar);
      }
      extraLatin = "\xD0\xDE\xFE";
      for (_i5 = 0; _i5 < extraLatin.length; _i5++) {
        _ch5 = extraLatin.charAt(_i5);
        defineSymbol(math, main, mathord, _ch5, _ch5);
        defineSymbol(text2, main, textord, _ch5, _ch5);
      }
      wideLatinLetterData = [
        ["mathbf", "textbf", "Main-Bold"],
        // A-Z bold upright
        ["mathbf", "textbf", "Main-Bold"],
        // a-z bold upright
        ["mathnormal", "textit", "Math-Italic"],
        // A-Z italic
        ["mathnormal", "textit", "Math-Italic"],
        // a-z italic
        ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
        // A-Z bold italic
        ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
        // a-z bold italic
        // Map fancy A-Z letters to script, not calligraphic.
        // This aligns with unicode-math and math fonts (except Cambria Math).
        ["mathscr", "textscr", "Script-Regular"],
        // A-Z script
        ["", "", ""],
        // a-z script.  No font
        ["", "", ""],
        // A-Z bold script. No font
        ["", "", ""],
        // a-z bold script. No font
        ["mathfrak", "textfrak", "Fraktur-Regular"],
        // A-Z Fraktur
        ["mathfrak", "textfrak", "Fraktur-Regular"],
        // a-z Fraktur
        ["mathbb", "textbb", "AMS-Regular"],
        // A-Z double-struck
        ["mathbb", "textbb", "AMS-Regular"],
        // k double-struck
        // Note that we are using a bold font, but font metrics for regular Fraktur.
        ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
        // A-Z bold Fraktur
        ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
        // a-z bold Fraktur
        ["mathsf", "textsf", "SansSerif-Regular"],
        // A-Z sans-serif
        ["mathsf", "textsf", "SansSerif-Regular"],
        // a-z sans-serif
        ["mathboldsf", "textboldsf", "SansSerif-Bold"],
        // A-Z bold sans-serif
        ["mathboldsf", "textboldsf", "SansSerif-Bold"],
        // a-z bold sans-serif
        ["mathitsf", "textitsf", "SansSerif-Italic"],
        // A-Z italic sans-serif
        ["mathitsf", "textitsf", "SansSerif-Italic"],
        // a-z italic sans-serif
        ["", "", ""],
        // A-Z bold italic sans. No font
        ["", "", ""],
        // a-z bold italic sans. No font
        ["mathtt", "texttt", "Typewriter-Regular"],
        // A-Z monospace
        ["mathtt", "texttt", "Typewriter-Regular"]
        // a-z monospace
      ];
      wideNumeralData = [
        ["mathbf", "textbf", "Main-Bold"],
        // 0-9 bold
        ["", "", ""],
        // 0-9 double-struck. No KaTeX font.
        ["mathsf", "textsf", "SansSerif-Regular"],
        // 0-9 sans-serif
        ["mathboldsf", "textboldsf", "SansSerif-Bold"],
        // 0-9 bold sans-serif
        ["mathtt", "texttt", "Typewriter-Regular"]
        // 0-9 monospace
      ];
      wideCharacterFont = /* @__PURE__ */ __name(function wideCharacterFont2(wideChar2, mode) {
        var H2 = wideChar2.charCodeAt(0);
        var L2 = wideChar2.charCodeAt(1);
        var codePoint = (H2 - 55296) * 1024 + (L2 - 56320) + 65536;
        var j2 = mode === "math" ? 0 : 1;
        if (119808 <= codePoint && codePoint < 120484) {
          var i2 = Math.floor((codePoint - 119808) / 26);
          return [wideLatinLetterData[i2][2], wideLatinLetterData[i2][j2]];
        } else if (120782 <= codePoint && codePoint <= 120831) {
          var _i = Math.floor((codePoint - 120782) / 10);
          return [wideNumeralData[_i][2], wideNumeralData[_i][j2]];
        } else if (codePoint === 120485 || codePoint === 120486) {
          return [wideLatinLetterData[0][2], wideLatinLetterData[0][j2]];
        } else if (120486 < codePoint && codePoint < 120782) {
          return ["", ""];
        } else {
          throw new ParseError("Unsupported character: " + wideChar2);
        }
      }, "wideCharacterFont");
      lookupSymbol = /* @__PURE__ */ __name(function lookupSymbol2(value2, fontName, mode) {
        if (symbols[mode][value2] && symbols[mode][value2].replace) {
          value2 = symbols[mode][value2].replace;
        }
        return {
          value: value2,
          metrics: getCharacterMetrics(value2, fontName, mode)
        };
      }, "lookupSymbol");
      makeSymbol = /* @__PURE__ */ __name(function makeSymbol2(value2, fontName, mode, options3, classes6) {
        var lookup2 = lookupSymbol(value2, fontName, mode);
        var metrics = lookup2.metrics;
        value2 = lookup2.value;
        var symbolNode;
        if (metrics) {
          var italic = metrics.italic;
          if (mode === "text" || options3 && options3.font === "mathit") {
            italic = 0;
          }
          symbolNode = new SymbolNode(value2, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes6);
        } else {
          typeof console !== "undefined" && console.warn("No character metrics " + ("for '" + value2 + "' in style '" + fontName + "' and mode '" + mode + "'"));
          symbolNode = new SymbolNode(value2, 0, 0, 0, 0, 0, classes6);
        }
        if (options3) {
          symbolNode.maxFontSize = options3.sizeMultiplier;
          if (options3.style.isTight()) {
            symbolNode.classes.push("mtight");
          }
          var color2 = options3.getColor();
          if (color2) {
            symbolNode.style.color = color2;
          }
        }
        return symbolNode;
      }, "makeSymbol");
      mathsym = /* @__PURE__ */ __name(function mathsym2(value2, mode, options3, classes6) {
        if (classes6 === void 0) {
          classes6 = [];
        }
        if (options3.font === "boldsymbol" && lookupSymbol(value2, "Main-Bold", mode).metrics) {
          return makeSymbol(value2, "Main-Bold", mode, options3, classes6.concat(["mathbf"]));
        } else if (value2 === "\\" || symbols[mode][value2].font === "main") {
          return makeSymbol(value2, "Main-Regular", mode, options3, classes6);
        } else {
          return makeSymbol(value2, "AMS-Regular", mode, options3, classes6.concat(["amsrm"]));
        }
      }, "mathsym");
      boldsymbol = /* @__PURE__ */ __name(function boldsymbol2(value2, mode, options3, classes6, type3) {
        if (type3 !== "textord" && lookupSymbol(value2, "Math-BoldItalic", mode).metrics) {
          return {
            fontName: "Math-BoldItalic",
            fontClass: "boldsymbol"
          };
        } else {
          return {
            fontName: "Main-Bold",
            fontClass: "mathbf"
          };
        }
      }, "boldsymbol");
      makeOrd = /* @__PURE__ */ __name(function makeOrd2(group2, options3, type3) {
        var mode = group2.mode;
        var text4 = group2.text;
        var classes6 = ["mord"];
        var isFont = mode === "math" || mode === "text" && options3.font;
        var fontOrFamily = isFont ? options3.font : options3.fontFamily;
        var wideFontName = "";
        var wideFontClass = "";
        if (text4.charCodeAt(0) === 55349) {
          [wideFontName, wideFontClass] = wideCharacterFont(text4, mode);
        }
        if (wideFontName.length > 0) {
          return makeSymbol(text4, wideFontName, mode, options3, classes6.concat(wideFontClass));
        } else if (fontOrFamily) {
          var fontName;
          var fontClasses;
          if (fontOrFamily === "boldsymbol") {
            var fontData = boldsymbol(text4, mode, options3, classes6, type3);
            fontName = fontData.fontName;
            fontClasses = [fontData.fontClass];
          } else if (isFont) {
            fontName = fontMap[fontOrFamily].fontName;
            fontClasses = [fontOrFamily];
          } else {
            fontName = retrieveTextFontName(fontOrFamily, options3.fontWeight, options3.fontShape);
            fontClasses = [fontOrFamily, options3.fontWeight, options3.fontShape];
          }
          if (lookupSymbol(text4, fontName, mode).metrics) {
            return makeSymbol(text4, fontName, mode, options3, classes6.concat(fontClasses));
          } else if (ligatures.hasOwnProperty(text4) && fontName.slice(0, 10) === "Typewriter") {
            var parts = [];
            for (var i2 = 0; i2 < text4.length; i2++) {
              parts.push(makeSymbol(text4[i2], fontName, mode, options3, classes6.concat(fontClasses)));
            }
            return makeFragment(parts);
          }
        }
        if (type3 === "mathord") {
          return makeSymbol(text4, "Math-Italic", mode, options3, classes6.concat(["mathnormal"]));
        } else if (type3 === "textord") {
          var font = symbols[mode][text4] && symbols[mode][text4].font;
          if (font === "ams") {
            var _fontName = retrieveTextFontName("amsrm", options3.fontWeight, options3.fontShape);
            return makeSymbol(text4, _fontName, mode, options3, classes6.concat("amsrm", options3.fontWeight, options3.fontShape));
          } else if (font === "main" || !font) {
            var _fontName2 = retrieveTextFontName("textrm", options3.fontWeight, options3.fontShape);
            return makeSymbol(text4, _fontName2, mode, options3, classes6.concat(options3.fontWeight, options3.fontShape));
          } else {
            var _fontName3 = retrieveTextFontName(font, options3.fontWeight, options3.fontShape);
            return makeSymbol(text4, _fontName3, mode, options3, classes6.concat(_fontName3, options3.fontWeight, options3.fontShape));
          }
        } else {
          throw new Error("unexpected type: " + type3 + " in makeOrd");
        }
      }, "makeOrd");
      canCombine = /* @__PURE__ */ __name((prev2, next3) => {
        if (createClass(prev2.classes) !== createClass(next3.classes) || prev2.skew !== next3.skew || prev2.maxFontSize !== next3.maxFontSize) {
          return false;
        }
        if (prev2.classes.length === 1) {
          var cls = prev2.classes[0];
          if (cls === "mbin" || cls === "mord") {
            return false;
          }
        }
        for (var style3 in prev2.style) {
          if (prev2.style.hasOwnProperty(style3) && prev2.style[style3] !== next3.style[style3]) {
            return false;
          }
        }
        for (var _style in next3.style) {
          if (next3.style.hasOwnProperty(_style) && prev2.style[_style] !== next3.style[_style]) {
            return false;
          }
        }
        return true;
      }, "canCombine");
      tryCombineChars = /* @__PURE__ */ __name((chars) => {
        for (var i2 = 0; i2 < chars.length - 1; i2++) {
          var prev2 = chars[i2];
          var next3 = chars[i2 + 1];
          if (prev2 instanceof SymbolNode && next3 instanceof SymbolNode && canCombine(prev2, next3)) {
            prev2.text += next3.text;
            prev2.height = Math.max(prev2.height, next3.height);
            prev2.depth = Math.max(prev2.depth, next3.depth);
            prev2.italic = next3.italic;
            chars.splice(i2 + 1, 1);
            i2--;
          }
        }
        return chars;
      }, "tryCombineChars");
      sizeElementFromChildren = /* @__PURE__ */ __name(function sizeElementFromChildren2(elem) {
        var height2 = 0;
        var depth = 0;
        var maxFontSize = 0;
        for (var i2 = 0; i2 < elem.children.length; i2++) {
          var child = elem.children[i2];
          if (child.height > height2) {
            height2 = child.height;
          }
          if (child.depth > depth) {
            depth = child.depth;
          }
          if (child.maxFontSize > maxFontSize) {
            maxFontSize = child.maxFontSize;
          }
        }
        elem.height = height2;
        elem.depth = depth;
        elem.maxFontSize = maxFontSize;
      }, "sizeElementFromChildren");
      makeSpan$2 = /* @__PURE__ */ __name(function makeSpan(classes6, children2, options3, style3) {
        var span = new Span(classes6, children2, options3, style3);
        sizeElementFromChildren(span);
        return span;
      }, "makeSpan");
      makeSvgSpan = /* @__PURE__ */ __name((classes6, children2, options3, style3) => new Span(classes6, children2, options3, style3), "makeSvgSpan");
      makeLineSpan = /* @__PURE__ */ __name(function makeLineSpan2(className, options3, thickness) {
        var line2 = makeSpan$2([className], [], options3);
        line2.height = Math.max(thickness || options3.fontMetrics().defaultRuleThickness, options3.minRuleThickness);
        line2.style.borderBottomWidth = makeEm(line2.height);
        line2.maxFontSize = 1;
        return line2;
      }, "makeLineSpan");
      makeAnchor = /* @__PURE__ */ __name(function makeAnchor2(href, classes6, children2, options3) {
        var anchor2 = new Anchor(href, classes6, children2, options3);
        sizeElementFromChildren(anchor2);
        return anchor2;
      }, "makeAnchor");
      makeFragment = /* @__PURE__ */ __name(function makeFragment2(children2) {
        var fragment = new DocumentFragment(children2);
        sizeElementFromChildren(fragment);
        return fragment;
      }, "makeFragment");
      wrapFragment = /* @__PURE__ */ __name(function wrapFragment2(group2, options3) {
        if (group2 instanceof DocumentFragment) {
          return makeSpan$2([], [group2], options3);
        }
        return group2;
      }, "wrapFragment");
      getVListChildrenAndDepth = /* @__PURE__ */ __name(function getVListChildrenAndDepth2(params) {
        if (params.positionType === "individualShift") {
          var oldChildren = params.children;
          var children2 = [oldChildren[0]];
          var _depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
          var currPos = _depth;
          for (var i2 = 1; i2 < oldChildren.length; i2++) {
            var diff2 = -oldChildren[i2].shift - currPos - oldChildren[i2].elem.depth;
            var size5 = diff2 - (oldChildren[i2 - 1].elem.height + oldChildren[i2 - 1].elem.depth);
            currPos = currPos + diff2;
            children2.push({
              type: "kern",
              size: size5
            });
            children2.push(oldChildren[i2]);
          }
          return {
            children: children2,
            depth: _depth
          };
        }
        var depth;
        if (params.positionType === "top") {
          var bottom2 = params.positionData;
          for (var _i = 0; _i < params.children.length; _i++) {
            var child = params.children[_i];
            bottom2 -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
          }
          depth = bottom2;
        } else if (params.positionType === "bottom") {
          depth = -params.positionData;
        } else {
          var firstChild = params.children[0];
          if (firstChild.type !== "elem") {
            throw new Error('First child must have type "elem".');
          }
          if (params.positionType === "shift") {
            depth = -firstChild.elem.depth - params.positionData;
          } else if (params.positionType === "firstBaseline") {
            depth = -firstChild.elem.depth;
          } else {
            throw new Error("Invalid positionType " + params.positionType + ".");
          }
        }
        return {
          children: params.children,
          depth
        };
      }, "getVListChildrenAndDepth");
      makeVList = /* @__PURE__ */ __name(function makeVList2(params, options3) {
        var {
          children: children2,
          depth
        } = getVListChildrenAndDepth(params);
        var pstrutSize = 0;
        for (var i2 = 0; i2 < children2.length; i2++) {
          var child = children2[i2];
          if (child.type === "elem") {
            var elem = child.elem;
            pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
          }
        }
        pstrutSize += 2;
        var pstrut = makeSpan$2(["pstrut"], []);
        pstrut.style.height = makeEm(pstrutSize);
        var realChildren = [];
        var minPos = depth;
        var maxPos2 = depth;
        var currPos = depth;
        for (var _i2 = 0; _i2 < children2.length; _i2++) {
          var _child = children2[_i2];
          if (_child.type === "kern") {
            currPos += _child.size;
          } else {
            var _elem = _child.elem;
            var classes6 = _child.wrapperClasses || [];
            var style3 = _child.wrapperStyle || {};
            var childWrap = makeSpan$2(classes6, [pstrut, _elem], void 0, style3);
            childWrap.style.top = makeEm(-pstrutSize - currPos - _elem.depth);
            if (_child.marginLeft) {
              childWrap.style.marginLeft = _child.marginLeft;
            }
            if (_child.marginRight) {
              childWrap.style.marginRight = _child.marginRight;
            }
            realChildren.push(childWrap);
            currPos += _elem.height + _elem.depth;
          }
          minPos = Math.min(minPos, currPos);
          maxPos2 = Math.max(maxPos2, currPos);
        }
        var vlist = makeSpan$2(["vlist"], realChildren);
        vlist.style.height = makeEm(maxPos2);
        var rows;
        if (minPos < 0) {
          var emptySpan = makeSpan$2([], []);
          var depthStrut = makeSpan$2(["vlist"], [emptySpan]);
          depthStrut.style.height = makeEm(-minPos);
          var topStrut = makeSpan$2(["vlist-s"], [new SymbolNode("\u200B")]);
          rows = [makeSpan$2(["vlist-r"], [vlist, topStrut]), makeSpan$2(["vlist-r"], [depthStrut])];
        } else {
          rows = [makeSpan$2(["vlist-r"], [vlist])];
        }
        var vtable = makeSpan$2(["vlist-t"], rows);
        if (rows.length === 2) {
          vtable.classes.push("vlist-t2");
        }
        vtable.height = maxPos2;
        vtable.depth = -minPos;
        return vtable;
      }, "makeVList");
      makeGlue = /* @__PURE__ */ __name((measurement, options3) => {
        var rule = makeSpan$2(["mspace"], [], options3);
        var size5 = calculateSize2(measurement, options3);
        rule.style.marginRight = makeEm(size5);
        return rule;
      }, "makeGlue");
      retrieveTextFontName = /* @__PURE__ */ __name(function retrieveTextFontName2(fontFamily, fontWeight, fontShape) {
        var baseFontName = "";
        switch (fontFamily) {
          case "amsrm":
            baseFontName = "AMS";
            break;
          case "textrm":
            baseFontName = "Main";
            break;
          case "textsf":
            baseFontName = "SansSerif";
            break;
          case "texttt":
            baseFontName = "Typewriter";
            break;
          default:
            baseFontName = fontFamily;
        }
        var fontStylesName;
        if (fontWeight === "textbf" && fontShape === "textit") {
          fontStylesName = "BoldItalic";
        } else if (fontWeight === "textbf") {
          fontStylesName = "Bold";
        } else if (fontWeight === "textit") {
          fontStylesName = "Italic";
        } else {
          fontStylesName = "Regular";
        }
        return baseFontName + "-" + fontStylesName;
      }, "retrieveTextFontName");
      fontMap = {
        // styles
        "mathbf": {
          variant: "bold",
          fontName: "Main-Bold"
        },
        "mathrm": {
          variant: "normal",
          fontName: "Main-Regular"
        },
        "textit": {
          variant: "italic",
          fontName: "Main-Italic"
        },
        "mathit": {
          variant: "italic",
          fontName: "Main-Italic"
        },
        "mathnormal": {
          variant: "italic",
          fontName: "Math-Italic"
        },
        // "boldsymbol" is missing because they require the use of multiple fonts:
        // Math-BoldItalic and Main-Bold.  This is handled by a special case in
        // makeOrd which ends up calling boldsymbol.
        // families
        "mathbb": {
          variant: "double-struck",
          fontName: "AMS-Regular"
        },
        "mathcal": {
          variant: "script",
          fontName: "Caligraphic-Regular"
        },
        "mathfrak": {
          variant: "fraktur",
          fontName: "Fraktur-Regular"
        },
        "mathscr": {
          variant: "script",
          fontName: "Script-Regular"
        },
        "mathsf": {
          variant: "sans-serif",
          fontName: "SansSerif-Regular"
        },
        "mathtt": {
          variant: "monospace",
          fontName: "Typewriter-Regular"
        }
      };
      svgData = {
        //   path, width, height
        vec: ["vec", 0.471, 0.714],
        // values from the font glyph
        oiintSize1: ["oiintSize1", 0.957, 0.499],
        // oval to overlay the integrand
        oiintSize2: ["oiintSize2", 1.472, 0.659],
        oiiintSize1: ["oiiintSize1", 1.304, 0.499],
        oiiintSize2: ["oiiintSize2", 1.98, 0.659]
      };
      staticSvg = /* @__PURE__ */ __name(function staticSvg2(value2, options3) {
        var [pathName, width3, height2] = svgData[value2];
        var path4 = new PathNode(pathName);
        var svgNode2 = new SvgNode([path4], {
          "width": makeEm(width3),
          "height": makeEm(height2),
          // Override CSS rule `.katex svg { width: 100% }`
          "style": "width:" + makeEm(width3),
          "viewBox": "0 0 " + 1e3 * width3 + " " + 1e3 * height2,
          "preserveAspectRatio": "xMinYMin"
        });
        var span = makeSvgSpan(["overlay"], [svgNode2], options3);
        span.height = height2;
        span.style.height = makeEm(height2);
        span.style.width = makeEm(width3);
        return span;
      }, "staticSvg");
      buildCommon = {
        fontMap,
        makeSymbol,
        mathsym,
        makeSpan: makeSpan$2,
        makeSvgSpan,
        makeLineSpan,
        makeAnchor,
        makeFragment,
        wrapFragment,
        makeVList,
        makeOrd,
        makeGlue,
        staticSvg,
        svgData,
        tryCombineChars
      };
      thinspace = {
        number: 3,
        unit: "mu"
      };
      mediumspace = {
        number: 4,
        unit: "mu"
      };
      thickspace = {
        number: 5,
        unit: "mu"
      };
      spacings = {
        mord: {
          mop: thinspace,
          mbin: mediumspace,
          mrel: thickspace,
          minner: thinspace
        },
        mop: {
          mord: thinspace,
          mop: thinspace,
          mrel: thickspace,
          minner: thinspace
        },
        mbin: {
          mord: mediumspace,
          mop: mediumspace,
          mopen: mediumspace,
          minner: mediumspace
        },
        mrel: {
          mord: thickspace,
          mop: thickspace,
          mopen: thickspace,
          minner: thickspace
        },
        mopen: {},
        mclose: {
          mop: thinspace,
          mbin: mediumspace,
          mrel: thickspace,
          minner: thinspace
        },
        mpunct: {
          mord: thinspace,
          mop: thinspace,
          mrel: thickspace,
          mopen: thinspace,
          mclose: thinspace,
          mpunct: thinspace,
          minner: thinspace
        },
        minner: {
          mord: thinspace,
          mop: thinspace,
          mbin: mediumspace,
          mrel: thickspace,
          mopen: thinspace,
          mpunct: thinspace,
          minner: thinspace
        }
      };
      tightSpacings = {
        mord: {
          mop: thinspace
        },
        mop: {
          mord: thinspace,
          mop: thinspace
        },
        mbin: {},
        mrel: {},
        mopen: {},
        mclose: {
          mop: thinspace
        },
        mpunct: {},
        minner: {
          mop: thinspace
        }
      };
      _functions = {};
      _htmlGroupBuilders = {};
      _mathmlGroupBuilders = {};
      __name(defineFunction, "defineFunction");
      __name(defineFunctionBuilders, "defineFunctionBuilders");
      normalizeArgument = /* @__PURE__ */ __name(function normalizeArgument2(arg) {
        return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg;
      }, "normalizeArgument");
      ordargument = /* @__PURE__ */ __name(function ordargument2(arg) {
        return arg.type === "ordgroup" ? arg.body : [arg];
      }, "ordargument");
      makeSpan$1 = buildCommon.makeSpan;
      binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
      binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
      styleMap$1 = {
        "display": Style$1.DISPLAY,
        "text": Style$1.TEXT,
        "script": Style$1.SCRIPT,
        "scriptscript": Style$1.SCRIPTSCRIPT
      };
      DomEnum = {
        mord: "mord",
        mop: "mop",
        mbin: "mbin",
        mrel: "mrel",
        mopen: "mopen",
        mclose: "mclose",
        mpunct: "mpunct",
        minner: "minner"
      };
      buildExpression$1 = /* @__PURE__ */ __name(function buildExpression(expression, options3, isRealGroup, surrounding) {
        if (surrounding === void 0) {
          surrounding = [null, null];
        }
        var groups = [];
        for (var i2 = 0; i2 < expression.length; i2++) {
          var output2 = buildGroup$1(expression[i2], options3);
          if (output2 instanceof DocumentFragment) {
            var children2 = output2.children;
            groups.push(...children2);
          } else {
            groups.push(output2);
          }
        }
        buildCommon.tryCombineChars(groups);
        if (!isRealGroup) {
          return groups;
        }
        var glueOptions = options3;
        if (expression.length === 1) {
          var node2 = expression[0];
          if (node2.type === "sizing") {
            glueOptions = options3.havingSize(node2.size);
          } else if (node2.type === "styling") {
            glueOptions = options3.havingStyle(styleMap$1[node2.style]);
          }
        }
        var dummyPrev = makeSpan$1([surrounding[0] || "leftmost"], [], options3);
        var dummyNext = makeSpan$1([surrounding[1] || "rightmost"], [], options3);
        var isRoot = isRealGroup === "root";
        traverseNonSpaceNodes(groups, (node3, prev2) => {
          var prevType = prev2.classes[0];
          var type3 = node3.classes[0];
          if (prevType === "mbin" && utils.contains(binRightCanceller, type3)) {
            prev2.classes[0] = "mord";
          } else if (type3 === "mbin" && utils.contains(binLeftCanceller, prevType)) {
            node3.classes[0] = "mord";
          }
        }, {
          node: dummyPrev
        }, dummyNext, isRoot);
        traverseNonSpaceNodes(groups, (node3, prev2) => {
          var prevType = getTypeOfDomTree(prev2);
          var type3 = getTypeOfDomTree(node3);
          var space = prevType && type3 ? node3.hasClass("mtight") ? tightSpacings[prevType][type3] : spacings[prevType][type3] : null;
          if (space) {
            return buildCommon.makeGlue(space, glueOptions);
          }
        }, {
          node: dummyPrev
        }, dummyNext, isRoot);
        return groups;
      }, "buildExpression");
      traverseNonSpaceNodes = /* @__PURE__ */ __name(function traverseNonSpaceNodes2(nodes7, callback, prev2, next3, isRoot) {
        if (next3) {
          nodes7.push(next3);
        }
        var i2 = 0;
        for (; i2 < nodes7.length; i2++) {
          var node2 = nodes7[i2];
          var partialGroup = checkPartialGroup(node2);
          if (partialGroup) {
            traverseNonSpaceNodes2(partialGroup.children, callback, prev2, null, isRoot);
            continue;
          }
          var nonspace = !node2.hasClass("mspace");
          if (nonspace) {
            var result = callback(node2, prev2.node);
            if (result) {
              if (prev2.insertAfter) {
                prev2.insertAfter(result);
              } else {
                nodes7.unshift(result);
                i2++;
              }
            }
          }
          if (nonspace) {
            prev2.node = node2;
          } else if (isRoot && node2.hasClass("newline")) {
            prev2.node = makeSpan$1(["leftmost"]);
          }
          prev2.insertAfter = /* @__PURE__ */ ((index) => (n2) => {
            nodes7.splice(index + 1, 0, n2);
            i2++;
          })(i2);
        }
        if (next3) {
          nodes7.pop();
        }
      }, "traverseNonSpaceNodes");
      checkPartialGroup = /* @__PURE__ */ __name(function checkPartialGroup2(node2) {
        if (node2 instanceof DocumentFragment || node2 instanceof Anchor || node2 instanceof Span && node2.hasClass("enclosing")) {
          return node2;
        }
        return null;
      }, "checkPartialGroup");
      getOutermostNode = /* @__PURE__ */ __name(function getOutermostNode2(node2, side) {
        var partialGroup = checkPartialGroup(node2);
        if (partialGroup) {
          var children2 = partialGroup.children;
          if (children2.length) {
            if (side === "right") {
              return getOutermostNode2(children2[children2.length - 1], "right");
            } else if (side === "left") {
              return getOutermostNode2(children2[0], "left");
            }
          }
        }
        return node2;
      }, "getOutermostNode");
      getTypeOfDomTree = /* @__PURE__ */ __name(function getTypeOfDomTree2(node2, side) {
        if (!node2) {
          return null;
        }
        if (side) {
          node2 = getOutermostNode(node2, side);
        }
        return DomEnum[node2.classes[0]] || null;
      }, "getTypeOfDomTree");
      makeNullDelimiter = /* @__PURE__ */ __name(function makeNullDelimiter2(options3, classes6) {
        var moreClasses = ["nulldelimiter"].concat(options3.baseSizingClasses());
        return makeSpan$1(classes6.concat(moreClasses));
      }, "makeNullDelimiter");
      buildGroup$1 = /* @__PURE__ */ __name(function buildGroup(group2, options3, baseOptions) {
        if (!group2) {
          return makeSpan$1();
        }
        if (_htmlGroupBuilders[group2.type]) {
          var groupNode = _htmlGroupBuilders[group2.type](group2, options3);
          if (baseOptions && options3.size !== baseOptions.size) {
            groupNode = makeSpan$1(options3.sizingClasses(baseOptions), [groupNode], options3);
            var multiplier = options3.sizeMultiplier / baseOptions.sizeMultiplier;
            groupNode.height *= multiplier;
            groupNode.depth *= multiplier;
          }
          return groupNode;
        } else {
          throw new ParseError("Got group of unknown type: '" + group2.type + "'");
        }
      }, "buildGroup");
      __name(buildHTMLUnbreakable, "buildHTMLUnbreakable");
      __name(buildHTML, "buildHTML");
      __name(newDocumentFragment, "newDocumentFragment");
      MathNode = class {
        static {
          __name(this, "MathNode");
        }
        constructor(type3, children2, classes6) {
          this.type = void 0;
          this.attributes = void 0;
          this.children = void 0;
          this.classes = void 0;
          this.type = type3;
          this.attributes = {};
          this.children = children2 || [];
          this.classes = classes6 || [];
        }
        /**
         * Sets an attribute on a MathML node. MathML depends on attributes to convey a
         * semantic content, so this is used heavily.
         */
        setAttribute(name, value2) {
          this.attributes[name] = value2;
        }
        /**
         * Gets an attribute on a MathML node.
         */
        getAttribute(name) {
          return this.attributes[name];
        }
        /**
         * Converts the math node into a MathML-namespaced DOM element.
         */
        toNode() {
          var node2 = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              node2.setAttribute(attr, this.attributes[attr]);
            }
          }
          if (this.classes.length > 0) {
            node2.className = createClass(this.classes);
          }
          for (var i2 = 0; i2 < this.children.length; i2++) {
            node2.appendChild(this.children[i2].toNode());
          }
          return node2;
        }
        /**
         * Converts the math node into an HTML markup string.
         */
        toMarkup() {
          var markup = "<" + this.type;
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              markup += " " + attr + '="';
              markup += utils.escape(this.attributes[attr]);
              markup += '"';
            }
          }
          if (this.classes.length > 0) {
            markup += ' class ="' + utils.escape(createClass(this.classes)) + '"';
          }
          markup += ">";
          for (var i2 = 0; i2 < this.children.length; i2++) {
            markup += this.children[i2].toMarkup();
          }
          markup += "</" + this.type + ">";
          return markup;
        }
        /**
         * Converts the math node into a string, similar to innerText, but escaped.
         */
        toText() {
          return this.children.map((child) => child.toText()).join("");
        }
      };
      TextNode = class {
        static {
          __name(this, "TextNode");
        }
        constructor(text4) {
          this.text = void 0;
          this.text = text4;
        }
        /**
         * Converts the text node into a DOM text node.
         */
        toNode() {
          return document.createTextNode(this.text);
        }
        /**
         * Converts the text node into escaped HTML markup
         * (representing the text itself).
         */
        toMarkup() {
          return utils.escape(this.toText());
        }
        /**
         * Converts the text node into a string
         * (representing the text itself).
         */
        toText() {
          return this.text;
        }
      };
      SpaceNode = class {
        static {
          __name(this, "SpaceNode");
        }
        /**
         * Create a Space node with width given in CSS ems.
         */
        constructor(width3) {
          this.width = void 0;
          this.character = void 0;
          this.width = width3;
          if (width3 >= 0.05555 && width3 <= 0.05556) {
            this.character = "\u200A";
          } else if (width3 >= 0.1666 && width3 <= 0.1667) {
            this.character = "\u2009";
          } else if (width3 >= 0.2222 && width3 <= 0.2223) {
            this.character = "\u2005";
          } else if (width3 >= 0.2777 && width3 <= 0.2778) {
            this.character = "\u2005\u200A";
          } else if (width3 >= -0.05556 && width3 <= -0.05555) {
            this.character = "\u200A\u2063";
          } else if (width3 >= -0.1667 && width3 <= -0.1666) {
            this.character = "\u2009\u2063";
          } else if (width3 >= -0.2223 && width3 <= -0.2222) {
            this.character = "\u205F\u2063";
          } else if (width3 >= -0.2778 && width3 <= -0.2777) {
            this.character = "\u2005\u2063";
          } else {
            this.character = null;
          }
        }
        /**
         * Converts the math node into a MathML-namespaced DOM element.
         */
        toNode() {
          if (this.character) {
            return document.createTextNode(this.character);
          } else {
            var node2 = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
            node2.setAttribute("width", makeEm(this.width));
            return node2;
          }
        }
        /**
         * Converts the math node into an HTML markup string.
         */
        toMarkup() {
          if (this.character) {
            return "<mtext>" + this.character + "</mtext>";
          } else {
            return '<mspace width="' + makeEm(this.width) + '"/>';
          }
        }
        /**
         * Converts the math node into a string, similar to innerText.
         */
        toText() {
          if (this.character) {
            return this.character;
          } else {
            return " ";
          }
        }
      };
      mathMLTree = {
        MathNode,
        TextNode,
        SpaceNode,
        newDocumentFragment
      };
      makeText = /* @__PURE__ */ __name(function makeText2(text4, mode, options3) {
        if (symbols[mode][text4] && symbols[mode][text4].replace && text4.charCodeAt(0) !== 55349 && !(ligatures.hasOwnProperty(text4) && options3 && (options3.fontFamily && options3.fontFamily.slice(4, 6) === "tt" || options3.font && options3.font.slice(4, 6) === "tt"))) {
          text4 = symbols[mode][text4].replace;
        }
        return new mathMLTree.TextNode(text4);
      }, "makeText");
      makeRow = /* @__PURE__ */ __name(function makeRow2(body) {
        if (body.length === 1) {
          return body[0];
        } else {
          return new mathMLTree.MathNode("mrow", body);
        }
      }, "makeRow");
      getVariant = /* @__PURE__ */ __name(function getVariant2(group2, options3) {
        if (options3.fontFamily === "texttt") {
          return "monospace";
        } else if (options3.fontFamily === "textsf") {
          if (options3.fontShape === "textit" && options3.fontWeight === "textbf") {
            return "sans-serif-bold-italic";
          } else if (options3.fontShape === "textit") {
            return "sans-serif-italic";
          } else if (options3.fontWeight === "textbf") {
            return "bold-sans-serif";
          } else {
            return "sans-serif";
          }
        } else if (options3.fontShape === "textit" && options3.fontWeight === "textbf") {
          return "bold-italic";
        } else if (options3.fontShape === "textit") {
          return "italic";
        } else if (options3.fontWeight === "textbf") {
          return "bold";
        }
        var font = options3.font;
        if (!font || font === "mathnormal") {
          return null;
        }
        var mode = group2.mode;
        if (font === "mathit") {
          return "italic";
        } else if (font === "boldsymbol") {
          return group2.type === "textord" ? "bold" : "bold-italic";
        } else if (font === "mathbf") {
          return "bold";
        } else if (font === "mathbb") {
          return "double-struck";
        } else if (font === "mathfrak") {
          return "fraktur";
        } else if (font === "mathscr" || font === "mathcal") {
          return "script";
        } else if (font === "mathsf") {
          return "sans-serif";
        } else if (font === "mathtt") {
          return "monospace";
        }
        var text4 = group2.text;
        if (utils.contains(["\\imath", "\\jmath"], text4)) {
          return null;
        }
        if (symbols[mode][text4] && symbols[mode][text4].replace) {
          text4 = symbols[mode][text4].replace;
        }
        var fontName = buildCommon.fontMap[font].fontName;
        if (getCharacterMetrics(text4, fontName, mode)) {
          return buildCommon.fontMap[font].variant;
        }
        return null;
      }, "getVariant");
      buildExpression2 = /* @__PURE__ */ __name(function buildExpression3(expression, options3, isOrdgroup) {
        if (expression.length === 1) {
          var group2 = buildGroup2(expression[0], options3);
          if (isOrdgroup && group2 instanceof MathNode && group2.type === "mo") {
            group2.setAttribute("lspace", "0em");
            group2.setAttribute("rspace", "0em");
          }
          return [group2];
        }
        var groups = [];
        var lastGroup;
        for (var i2 = 0; i2 < expression.length; i2++) {
          var _group = buildGroup2(expression[i2], options3);
          if (_group instanceof MathNode && lastGroup instanceof MathNode) {
            if (_group.type === "mtext" && lastGroup.type === "mtext" && _group.getAttribute("mathvariant") === lastGroup.getAttribute("mathvariant")) {
              lastGroup.children.push(..._group.children);
              continue;
            } else if (_group.type === "mn" && lastGroup.type === "mn") {
              lastGroup.children.push(..._group.children);
              continue;
            } else if (_group.type === "mi" && _group.children.length === 1 && lastGroup.type === "mn") {
              var child = _group.children[0];
              if (child instanceof TextNode && child.text === ".") {
                lastGroup.children.push(..._group.children);
                continue;
              }
            } else if (lastGroup.type === "mi" && lastGroup.children.length === 1) {
              var lastChild = lastGroup.children[0];
              if (lastChild instanceof TextNode && lastChild.text === "\u0338" && (_group.type === "mo" || _group.type === "mi" || _group.type === "mn")) {
                var _child = _group.children[0];
                if (_child instanceof TextNode && _child.text.length > 0) {
                  _child.text = _child.text.slice(0, 1) + "\u0338" + _child.text.slice(1);
                  groups.pop();
                }
              }
            }
          }
          groups.push(_group);
          lastGroup = _group;
        }
        return groups;
      }, "buildExpression");
      buildExpressionRow = /* @__PURE__ */ __name(function buildExpressionRow2(expression, options3, isOrdgroup) {
        return makeRow(buildExpression2(expression, options3, isOrdgroup));
      }, "buildExpressionRow");
      buildGroup2 = /* @__PURE__ */ __name(function buildGroup3(group2, options3) {
        if (!group2) {
          return new mathMLTree.MathNode("mrow");
        }
        if (_mathmlGroupBuilders[group2.type]) {
          var result = _mathmlGroupBuilders[group2.type](group2, options3);
          return result;
        } else {
          throw new ParseError("Got group of unknown type: '" + group2.type + "'");
        }
      }, "buildGroup");
      __name(buildMathML, "buildMathML");
      optionsFromSettings = /* @__PURE__ */ __name(function optionsFromSettings2(settings) {
        return new Options({
          style: settings.displayMode ? Style$1.DISPLAY : Style$1.TEXT,
          maxSize: settings.maxSize,
          minRuleThickness: settings.minRuleThickness
        });
      }, "optionsFromSettings");
      displayWrap = /* @__PURE__ */ __name(function displayWrap2(node2, settings) {
        if (settings.displayMode) {
          var classes6 = ["katex-display"];
          if (settings.leqno) {
            classes6.push("leqno");
          }
          if (settings.fleqn) {
            classes6.push("fleqn");
          }
          node2 = buildCommon.makeSpan(classes6, [node2]);
        }
        return node2;
      }, "displayWrap");
      buildTree = /* @__PURE__ */ __name(function buildTree2(tree, expression, settings) {
        var options3 = optionsFromSettings(settings);
        var katexNode;
        if (settings.output === "mathml") {
          return buildMathML(tree, expression, options3, settings.displayMode, true);
        } else if (settings.output === "html") {
          var htmlNode = buildHTML(tree, options3);
          katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
        } else {
          var mathMLNode = buildMathML(tree, expression, options3, settings.displayMode, false);
          var _htmlNode = buildHTML(tree, options3);
          katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, _htmlNode]);
        }
        return displayWrap(katexNode, settings);
      }, "buildTree");
      buildHTMLTree = /* @__PURE__ */ __name(function buildHTMLTree2(tree, expression, settings) {
        var options3 = optionsFromSettings(settings);
        var htmlNode = buildHTML(tree, options3);
        var katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
        return displayWrap(katexNode, settings);
      }, "buildHTMLTree");
      stretchyCodePoint = {
        widehat: "^",
        widecheck: "\u02C7",
        widetilde: "~",
        utilde: "~",
        overleftarrow: "\u2190",
        underleftarrow: "\u2190",
        xleftarrow: "\u2190",
        overrightarrow: "\u2192",
        underrightarrow: "\u2192",
        xrightarrow: "\u2192",
        underbrace: "\u23DF",
        overbrace: "\u23DE",
        overgroup: "\u23E0",
        undergroup: "\u23E1",
        overleftrightarrow: "\u2194",
        underleftrightarrow: "\u2194",
        xleftrightarrow: "\u2194",
        Overrightarrow: "\u21D2",
        xRightarrow: "\u21D2",
        overleftharpoon: "\u21BC",
        xleftharpoonup: "\u21BC",
        overrightharpoon: "\u21C0",
        xrightharpoonup: "\u21C0",
        xLeftarrow: "\u21D0",
        xLeftrightarrow: "\u21D4",
        xhookleftarrow: "\u21A9",
        xhookrightarrow: "\u21AA",
        xmapsto: "\u21A6",
        xrightharpoondown: "\u21C1",
        xleftharpoondown: "\u21BD",
        xrightleftharpoons: "\u21CC",
        xleftrightharpoons: "\u21CB",
        xtwoheadleftarrow: "\u219E",
        xtwoheadrightarrow: "\u21A0",
        xlongequal: "=",
        xtofrom: "\u21C4",
        xrightleftarrows: "\u21C4",
        xrightequilibrium: "\u21CC",
        // Not a perfect match.
        xleftequilibrium: "\u21CB",
        // None better available.
        "\\cdrightarrow": "\u2192",
        "\\cdleftarrow": "\u2190",
        "\\cdlongequal": "="
      };
      mathMLnode = /* @__PURE__ */ __name(function mathMLnode2(label) {
        var node2 = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.replace(/^\\/, "")])]);
        node2.setAttribute("stretchy", "true");
        return node2;
      }, "mathMLnode");
      katexImagesData = {
        //   path(s), minWidth, height, align
        overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
        overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
        underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
        underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
        xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
        "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
        // CD minwwidth2.5pc
        xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
        "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
        Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
        xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
        xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
        overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
        xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
        xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
        overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
        xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
        xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
        xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
        "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
        xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
        xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
        overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
        overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
        underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
        underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
        xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
        xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
        xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
        xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
        xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
        xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
        overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
        underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
        overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
        undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
        xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
        xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
        // The next three arrows are from the mhchem package.
        // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
        // document as \xrightarrow or \xrightleftharpoons. Those have
        // min-length = 1.75em, so we set min-length on these next three to match.
        xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
        xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
        xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
      };
      groupLength = /* @__PURE__ */ __name(function groupLength2(arg) {
        if (arg.type === "ordgroup") {
          return arg.body.length;
        } else {
          return 1;
        }
      }, "groupLength");
      svgSpan = /* @__PURE__ */ __name(function svgSpan2(group2, options3) {
        function buildSvgSpan_() {
          var viewBoxWidth = 4e5;
          var label = group2.label.slice(1);
          if (utils.contains(["widehat", "widecheck", "widetilde", "utilde"], label)) {
            var grp = group2;
            var numChars = groupLength(grp.base);
            var viewBoxHeight;
            var pathName;
            var _height;
            if (numChars > 5) {
              if (label === "widehat" || label === "widecheck") {
                viewBoxHeight = 420;
                viewBoxWidth = 2364;
                _height = 0.42;
                pathName = label + "4";
              } else {
                viewBoxHeight = 312;
                viewBoxWidth = 2340;
                _height = 0.34;
                pathName = "tilde4";
              }
            } else {
              var imgIndex = [1, 1, 2, 2, 3, 3][numChars];
              if (label === "widehat" || label === "widecheck") {
                viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
                viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
                _height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
                pathName = label + imgIndex;
              } else {
                viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
                viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
                _height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
                pathName = "tilde" + imgIndex;
              }
            }
            var path4 = new PathNode(pathName);
            var svgNode2 = new SvgNode([path4], {
              "width": "100%",
              "height": makeEm(_height),
              "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
              "preserveAspectRatio": "none"
            });
            return {
              span: buildCommon.makeSvgSpan([], [svgNode2], options3),
              minWidth: 0,
              height: _height
            };
          } else {
            var spans = [];
            var data5 = katexImagesData[label];
            var [paths, _minWidth, _viewBoxHeight] = data5;
            var _height2 = _viewBoxHeight / 1e3;
            var numSvgChildren = paths.length;
            var widthClasses;
            var aligns;
            if (numSvgChildren === 1) {
              var align1 = data5[3];
              widthClasses = ["hide-tail"];
              aligns = [align1];
            } else if (numSvgChildren === 2) {
              widthClasses = ["halfarrow-left", "halfarrow-right"];
              aligns = ["xMinYMin", "xMaxYMin"];
            } else if (numSvgChildren === 3) {
              widthClasses = ["brace-left", "brace-center", "brace-right"];
              aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
            } else {
              throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
            }
            for (var i2 = 0; i2 < numSvgChildren; i2++) {
              var _path = new PathNode(paths[i2]);
              var _svgNode = new SvgNode([_path], {
                "width": "400em",
                "height": makeEm(_height2),
                "viewBox": "0 0 " + viewBoxWidth + " " + _viewBoxHeight,
                "preserveAspectRatio": aligns[i2] + " slice"
              });
              var _span = buildCommon.makeSvgSpan([widthClasses[i2]], [_svgNode], options3);
              if (numSvgChildren === 1) {
                return {
                  span: _span,
                  minWidth: _minWidth,
                  height: _height2
                };
              } else {
                _span.style.height = makeEm(_height2);
                spans.push(_span);
              }
            }
            return {
              span: buildCommon.makeSpan(["stretchy"], spans, options3),
              minWidth: _minWidth,
              height: _height2
            };
          }
        }
        __name(buildSvgSpan_, "buildSvgSpan_");
        var {
          span,
          minWidth,
          height: height2
        } = buildSvgSpan_();
        span.height = height2;
        span.style.height = makeEm(height2);
        if (minWidth > 0) {
          span.style.minWidth = makeEm(minWidth);
        }
        return span;
      }, "svgSpan");
      encloseSpan = /* @__PURE__ */ __name(function encloseSpan2(inner2, label, topPad, bottomPad, options3) {
        var img;
        var totalHeight = inner2.height + inner2.depth + topPad + bottomPad;
        if (/fbox|color|angl/.test(label)) {
          img = buildCommon.makeSpan(["stretchy", label], [], options3);
          if (label === "fbox") {
            var color2 = options3.color && options3.getColor();
            if (color2) {
              img.style.borderColor = color2;
            }
          }
        } else {
          var lines = [];
          if (/^[bx]cancel$/.test(label)) {
            lines.push(new LineNode({
              "x1": "0",
              "y1": "0",
              "x2": "100%",
              "y2": "100%",
              "stroke-width": "0.046em"
            }));
          }
          if (/^x?cancel$/.test(label)) {
            lines.push(new LineNode({
              "x1": "0",
              "y1": "100%",
              "x2": "100%",
              "y2": "0",
              "stroke-width": "0.046em"
            }));
          }
          var svgNode2 = new SvgNode(lines, {
            "width": "100%",
            "height": makeEm(totalHeight)
          });
          img = buildCommon.makeSvgSpan([], [svgNode2], options3);
        }
        img.height = totalHeight;
        img.style.height = makeEm(totalHeight);
        return img;
      }, "encloseSpan");
      stretchy = {
        encloseSpan,
        mathMLnode,
        svgSpan
      };
      __name(assertNodeType, "assertNodeType");
      __name(assertSymbolNodeType, "assertSymbolNodeType");
      __name(checkSymbolNodeType, "checkSymbolNodeType");
      htmlBuilder$a = /* @__PURE__ */ __name((grp, options3) => {
        var base;
        var group2;
        var supSubGroup;
        if (grp && grp.type === "supsub") {
          group2 = assertNodeType(grp.base, "accent");
          base = group2.base;
          grp.base = base;
          supSubGroup = assertSpan(buildGroup$1(grp, options3));
          grp.base = group2;
        } else {
          group2 = assertNodeType(grp, "accent");
          base = group2.base;
        }
        var body = buildGroup$1(base, options3.havingCrampedStyle());
        var mustShift = group2.isShifty && utils.isCharacterBox(base);
        var skew = 0;
        if (mustShift) {
          var baseChar = utils.getBaseElem(base);
          var baseGroup = buildGroup$1(baseChar, options3.havingCrampedStyle());
          skew = assertSymbolDomNode(baseGroup).skew;
        }
        var accentBelow = group2.label === "\\c";
        var clearance = accentBelow ? body.height + body.depth : Math.min(body.height, options3.fontMetrics().xHeight);
        var accentBody;
        if (!group2.isStretchy) {
          var accent2;
          var width3;
          if (group2.label === "\\vec") {
            accent2 = buildCommon.staticSvg("vec", options3);
            width3 = buildCommon.svgData.vec[1];
          } else {
            accent2 = buildCommon.makeOrd({
              mode: group2.mode,
              text: group2.label
            }, options3, "textord");
            accent2 = assertSymbolDomNode(accent2);
            accent2.italic = 0;
            width3 = accent2.width;
            if (accentBelow) {
              clearance += accent2.depth;
            }
          }
          accentBody = buildCommon.makeSpan(["accent-body"], [accent2]);
          var accentFull = group2.label === "\\textcircled";
          if (accentFull) {
            accentBody.classes.push("accent-full");
            clearance = body.height;
          }
          var left3 = skew;
          if (!accentFull) {
            left3 -= width3 / 2;
          }
          accentBody.style.left = makeEm(left3);
          if (group2.label === "\\textcircled") {
            accentBody.style.top = ".2em";
          }
          accentBody = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: body
            }, {
              type: "kern",
              size: -clearance
            }, {
              type: "elem",
              elem: accentBody
            }]
          }, options3);
        } else {
          accentBody = stretchy.svgSpan(group2, options3);
          accentBody = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: body
            }, {
              type: "elem",
              elem: accentBody,
              wrapperClasses: ["svg-align"],
              wrapperStyle: skew > 0 ? {
                width: "calc(100% - " + makeEm(2 * skew) + ")",
                marginLeft: makeEm(2 * skew)
              } : void 0
            }]
          }, options3);
        }
        var accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options3);
        if (supSubGroup) {
          supSubGroup.children[0] = accentWrap;
          supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height);
          supSubGroup.classes[0] = "mord";
          return supSubGroup;
        } else {
          return accentWrap;
        }
      }, "htmlBuilder$a");
      mathmlBuilder$9 = /* @__PURE__ */ __name((group2, options3) => {
        var accentNode = group2.isStretchy ? stretchy.mathMLnode(group2.label) : new mathMLTree.MathNode("mo", [makeText(group2.label, group2.mode)]);
        var node2 = new mathMLTree.MathNode("mover", [buildGroup2(group2.base, options3), accentNode]);
        node2.setAttribute("accent", "true");
        return node2;
      }, "mathmlBuilder$9");
      NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((accent2) => "\\" + accent2).join("|"));
      defineFunction({
        type: "accent",
        names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
        props: {
          numArgs: 1
        },
        handler: /* @__PURE__ */ __name((context, args) => {
          var base = normalizeArgument(args[0]);
          var isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
          var isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
          return {
            type: "accent",
            mode: context.parser.mode,
            label: context.funcName,
            isStretchy,
            isShifty,
            base
          };
        }, "handler"),
        htmlBuilder: htmlBuilder$a,
        mathmlBuilder: mathmlBuilder$9
      });
      defineFunction({
        type: "accent",
        names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
        props: {
          numArgs: 1,
          allowedInText: true,
          allowedInMath: true,
          // unless in strict mode
          argTypes: ["primitive"]
        },
        handler: /* @__PURE__ */ __name((context, args) => {
          var base = args[0];
          var mode = context.parser.mode;
          if (mode === "math") {
            context.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + context.funcName + " works only in text mode");
            mode = "text";
          }
          return {
            type: "accent",
            mode,
            label: context.funcName,
            isStretchy: false,
            isShifty: true,
            base
          };
        }, "handler"),
        htmlBuilder: htmlBuilder$a,
        mathmlBuilder: mathmlBuilder$9
      });
      defineFunction({
        type: "accentUnder",
        names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
        props: {
          numArgs: 1
        },
        handler: /* @__PURE__ */ __name((_ref, args) => {
          var {
            parser: parser23,
            funcName
          } = _ref;
          var base = args[0];
          return {
            type: "accentUnder",
            mode: parser23.mode,
            label: funcName,
            base
          };
        }, "handler"),
        htmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          var innerGroup = buildGroup$1(group2.base, options3);
          var accentBody = stretchy.svgSpan(group2, options3);
          var kern = group2.label === "\\utilde" ? 0.12 : 0;
          var vlist = buildCommon.makeVList({
            positionType: "top",
            positionData: innerGroup.height,
            children: [{
              type: "elem",
              elem: accentBody,
              wrapperClasses: ["svg-align"]
            }, {
              type: "kern",
              size: kern
            }, {
              type: "elem",
              elem: innerGroup
            }]
          }, options3);
          return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options3);
        }, "htmlBuilder"),
        mathmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          var accentNode = stretchy.mathMLnode(group2.label);
          var node2 = new mathMLTree.MathNode("munder", [buildGroup2(group2.base, options3), accentNode]);
          node2.setAttribute("accentunder", "true");
          return node2;
        }, "mathmlBuilder")
      });
      paddedNode = /* @__PURE__ */ __name((group2) => {
        var node2 = new mathMLTree.MathNode("mpadded", group2 ? [group2] : []);
        node2.setAttribute("width", "+0.6em");
        node2.setAttribute("lspace", "0.3em");
        return node2;
      }, "paddedNode");
      defineFunction({
        type: "xArrow",
        names: [
          "\\xleftarrow",
          "\\xrightarrow",
          "\\xLeftarrow",
          "\\xRightarrow",
          "\\xleftrightarrow",
          "\\xLeftrightarrow",
          "\\xhookleftarrow",
          "\\xhookrightarrow",
          "\\xmapsto",
          "\\xrightharpoondown",
          "\\xrightharpoonup",
          "\\xleftharpoondown",
          "\\xleftharpoonup",
          "\\xrightleftharpoons",
          "\\xleftrightharpoons",
          "\\xlongequal",
          "\\xtwoheadrightarrow",
          "\\xtwoheadleftarrow",
          "\\xtofrom",
          // The next 3 functions are here to support the mhchem extension.
          // Direct use of these functions is discouraged and may break someday.
          "\\xrightleftarrows",
          "\\xrightequilibrium",
          "\\xleftequilibrium",
          // The next 3 functions are here only to support the {CD} environment.
          "\\\\cdrightarrow",
          "\\\\cdleftarrow",
          "\\\\cdlongequal"
        ],
        props: {
          numArgs: 1,
          numOptionalArgs: 1
        },
        handler(_ref, args, optArgs) {
          var {
            parser: parser23,
            funcName
          } = _ref;
          return {
            type: "xArrow",
            mode: parser23.mode,
            label: funcName,
            body: args[0],
            below: optArgs[0]
          };
        },
        // Flow is unable to correctly infer the type of `group`, even though it's
        // unambiguously determined from the passed-in `type` above.
        htmlBuilder(group2, options3) {
          var style3 = options3.style;
          var newOptions = options3.havingStyle(style3.sup());
          var upperGroup = buildCommon.wrapFragment(buildGroup$1(group2.body, newOptions, options3), options3);
          var arrowPrefix = group2.label.slice(0, 2) === "\\x" ? "x" : "cd";
          upperGroup.classes.push(arrowPrefix + "-arrow-pad");
          var lowerGroup;
          if (group2.below) {
            newOptions = options3.havingStyle(style3.sub());
            lowerGroup = buildCommon.wrapFragment(buildGroup$1(group2.below, newOptions, options3), options3);
            lowerGroup.classes.push(arrowPrefix + "-arrow-pad");
          }
          var arrowBody = stretchy.svgSpan(group2, options3);
          var arrowShift = -options3.fontMetrics().axisHeight + 0.5 * arrowBody.height;
          var upperShift = -options3.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111;
          if (upperGroup.depth > 0.25 || group2.label === "\\xleftequilibrium") {
            upperShift -= upperGroup.depth;
          }
          var vlist;
          if (lowerGroup) {
            var lowerShift = -options3.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
            vlist = buildCommon.makeVList({
              positionType: "individualShift",
              children: [{
                type: "elem",
                elem: upperGroup,
                shift: upperShift
              }, {
                type: "elem",
                elem: arrowBody,
                shift: arrowShift
              }, {
                type: "elem",
                elem: lowerGroup,
                shift: lowerShift
              }]
            }, options3);
          } else {
            vlist = buildCommon.makeVList({
              positionType: "individualShift",
              children: [{
                type: "elem",
                elem: upperGroup,
                shift: upperShift
              }, {
                type: "elem",
                elem: arrowBody,
                shift: arrowShift
              }]
            }, options3);
          }
          vlist.children[0].children[0].children[1].classes.push("svg-align");
          return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options3);
        },
        mathmlBuilder(group2, options3) {
          var arrowNode = stretchy.mathMLnode(group2.label);
          arrowNode.setAttribute("minsize", group2.label.charAt(0) === "x" ? "1.75em" : "3.0em");
          var node2;
          if (group2.body) {
            var upperNode = paddedNode(buildGroup2(group2.body, options3));
            if (group2.below) {
              var lowerNode = paddedNode(buildGroup2(group2.below, options3));
              node2 = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
            } else {
              node2 = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
            }
          } else if (group2.below) {
            var _lowerNode = paddedNode(buildGroup2(group2.below, options3));
            node2 = new mathMLTree.MathNode("munder", [arrowNode, _lowerNode]);
          } else {
            node2 = paddedNode();
            node2 = new mathMLTree.MathNode("mover", [arrowNode, node2]);
          }
          return node2;
        }
      });
      makeSpan2 = buildCommon.makeSpan;
      __name(htmlBuilder$9, "htmlBuilder$9");
      __name(mathmlBuilder$8, "mathmlBuilder$8");
      defineFunction({
        type: "mclass",
        names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler(_ref, args) {
          var {
            parser: parser23,
            funcName
          } = _ref;
          var body = args[0];
          return {
            type: "mclass",
            mode: parser23.mode,
            mclass: "m" + funcName.slice(5),
            // TODO(kevinb): don't prefix with 'm'
            body: ordargument(body),
            isCharacterBox: utils.isCharacterBox(body)
          };
        },
        htmlBuilder: htmlBuilder$9,
        mathmlBuilder: mathmlBuilder$8
      });
      binrelClass = /* @__PURE__ */ __name((arg) => {
        var atom2 = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
        if (atom2.type === "atom" && (atom2.family === "bin" || atom2.family === "rel")) {
          return "m" + atom2.family;
        } else {
          return "mord";
        }
      }, "binrelClass");
      defineFunction({
        type: "mclass",
        names: ["\\@binrel"],
        props: {
          numArgs: 2
        },
        handler(_ref2, args) {
          var {
            parser: parser23
          } = _ref2;
          return {
            type: "mclass",
            mode: parser23.mode,
            mclass: binrelClass(args[0]),
            body: ordargument(args[1]),
            isCharacterBox: utils.isCharacterBox(args[1])
          };
        }
      });
      defineFunction({
        type: "mclass",
        names: ["\\stackrel", "\\overset", "\\underset"],
        props: {
          numArgs: 2
        },
        handler(_ref3, args) {
          var {
            parser: parser23,
            funcName
          } = _ref3;
          var baseArg = args[1];
          var shiftedArg = args[0];
          var mclass;
          if (funcName !== "\\stackrel") {
            mclass = binrelClass(baseArg);
          } else {
            mclass = "mrel";
          }
          var baseOp = {
            type: "op",
            mode: baseArg.mode,
            limits: true,
            alwaysHandleSupSub: true,
            parentIsSupSub: false,
            symbol: false,
            suppressBaseShift: funcName !== "\\stackrel",
            body: ordargument(baseArg)
          };
          var supsub = {
            type: "supsub",
            mode: shiftedArg.mode,
            base: baseOp,
            sup: funcName === "\\underset" ? null : shiftedArg,
            sub: funcName === "\\underset" ? shiftedArg : null
          };
          return {
            type: "mclass",
            mode: parser23.mode,
            mclass,
            body: [supsub],
            isCharacterBox: utils.isCharacterBox(supsub)
          };
        },
        htmlBuilder: htmlBuilder$9,
        mathmlBuilder: mathmlBuilder$8
      });
      defineFunction({
        type: "pmb",
        names: ["\\pmb"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler(_ref, args) {
          var {
            parser: parser23
          } = _ref;
          return {
            type: "pmb",
            mode: parser23.mode,
            mclass: binrelClass(args[0]),
            body: ordargument(args[0])
          };
        },
        htmlBuilder(group2, options3) {
          var elements4 = buildExpression$1(group2.body, options3, true);
          var node2 = buildCommon.makeSpan([group2.mclass], elements4, options3);
          node2.style.textShadow = "0.02em 0.01em 0.04px";
          return node2;
        },
        mathmlBuilder(group2, style3) {
          var inner2 = buildExpression2(group2.body, style3);
          var node2 = new mathMLTree.MathNode("mstyle", inner2);
          node2.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px");
          return node2;
        }
      });
      cdArrowFunctionName = {
        ">": "\\\\cdrightarrow",
        "<": "\\\\cdleftarrow",
        "=": "\\\\cdlongequal",
        "A": "\\uparrow",
        "V": "\\downarrow",
        "|": "\\Vert",
        ".": "no arrow"
      };
      newCell = /* @__PURE__ */ __name(() => {
        return {
          type: "styling",
          body: [],
          mode: "math",
          style: "display"
        };
      }, "newCell");
      isStartOfArrow = /* @__PURE__ */ __name((node2) => {
        return node2.type === "textord" && node2.text === "@";
      }, "isStartOfArrow");
      isLabelEnd = /* @__PURE__ */ __name((node2, endChar) => {
        return (node2.type === "mathord" || node2.type === "atom") && node2.text === endChar;
      }, "isLabelEnd");
      __name(cdArrow, "cdArrow");
      __name(parseCD, "parseCD");
      defineFunction({
        type: "cdlabel",
        names: ["\\\\cdleft", "\\\\cdright"],
        props: {
          numArgs: 1
        },
        handler(_ref, args) {
          var {
            parser: parser23,
            funcName
          } = _ref;
          return {
            type: "cdlabel",
            mode: parser23.mode,
            side: funcName.slice(4),
            label: args[0]
          };
        },
        htmlBuilder(group2, options3) {
          var newOptions = options3.havingStyle(options3.style.sup());
          var label = buildCommon.wrapFragment(buildGroup$1(group2.label, newOptions, options3), options3);
          label.classes.push("cd-label-" + group2.side);
          label.style.bottom = makeEm(0.8 - label.depth);
          label.height = 0;
          label.depth = 0;
          return label;
        },
        mathmlBuilder(group2, options3) {
          var label = new mathMLTree.MathNode("mrow", [buildGroup2(group2.label, options3)]);
          label = new mathMLTree.MathNode("mpadded", [label]);
          label.setAttribute("width", "0");
          if (group2.side === "left") {
            label.setAttribute("lspace", "-1width");
          }
          label.setAttribute("voffset", "0.7em");
          label = new mathMLTree.MathNode("mstyle", [label]);
          label.setAttribute("displaystyle", "false");
          label.setAttribute("scriptlevel", "1");
          return label;
        }
      });
      defineFunction({
        type: "cdlabelparent",
        names: ["\\\\cdparent"],
        props: {
          numArgs: 1
        },
        handler(_ref2, args) {
          var {
            parser: parser23
          } = _ref2;
          return {
            type: "cdlabelparent",
            mode: parser23.mode,
            fragment: args[0]
          };
        },
        htmlBuilder(group2, options3) {
          var parent4 = buildCommon.wrapFragment(buildGroup$1(group2.fragment, options3), options3);
          parent4.classes.push("cd-vert-arrow");
          return parent4;
        },
        mathmlBuilder(group2, options3) {
          return new mathMLTree.MathNode("mrow", [buildGroup2(group2.fragment, options3)]);
        }
      });
      defineFunction({
        type: "textord",
        names: ["\\@char"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler(_ref, args) {
          var {
            parser: parser23
          } = _ref;
          var arg = assertNodeType(args[0], "ordgroup");
          var group2 = arg.body;
          var number7 = "";
          for (var i2 = 0; i2 < group2.length; i2++) {
            var node2 = assertNodeType(group2[i2], "textord");
            number7 += node2.text;
          }
          var code = parseInt(number7);
          var text4;
          if (isNaN(code)) {
            throw new ParseError("\\@char has non-numeric argument " + number7);
          } else if (code < 0 || code >= 1114111) {
            throw new ParseError("\\@char with invalid code point " + number7);
          } else if (code <= 65535) {
            text4 = String.fromCharCode(code);
          } else {
            code -= 65536;
            text4 = String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
          }
          return {
            type: "textord",
            mode: parser23.mode,
            text: text4
          };
        }
      });
      htmlBuilder$8 = /* @__PURE__ */ __name((group2, options3) => {
        var elements4 = buildExpression$1(group2.body, options3.withColor(group2.color), false);
        return buildCommon.makeFragment(elements4);
      }, "htmlBuilder$8");
      mathmlBuilder$7 = /* @__PURE__ */ __name((group2, options3) => {
        var inner2 = buildExpression2(group2.body, options3.withColor(group2.color));
        var node2 = new mathMLTree.MathNode("mstyle", inner2);
        node2.setAttribute("mathcolor", group2.color);
        return node2;
      }, "mathmlBuilder$7");
      defineFunction({
        type: "color",
        names: ["\\textcolor"],
        props: {
          numArgs: 2,
          allowedInText: true,
          argTypes: ["color", "original"]
        },
        handler(_ref, args) {
          var {
            parser: parser23
          } = _ref;
          var color2 = assertNodeType(args[0], "color-token").color;
          var body = args[1];
          return {
            type: "color",
            mode: parser23.mode,
            color: color2,
            body: ordargument(body)
          };
        },
        htmlBuilder: htmlBuilder$8,
        mathmlBuilder: mathmlBuilder$7
      });
      defineFunction({
        type: "color",
        names: ["\\color"],
        props: {
          numArgs: 1,
          allowedInText: true,
          argTypes: ["color"]
        },
        handler(_ref2, args) {
          var {
            parser: parser23,
            breakOnTokenText
          } = _ref2;
          var color2 = assertNodeType(args[0], "color-token").color;
          parser23.gullet.macros.set("\\current@color", color2);
          var body = parser23.parseExpression(true, breakOnTokenText);
          return {
            type: "color",
            mode: parser23.mode,
            color: color2,
            body
          };
        },
        htmlBuilder: htmlBuilder$8,
        mathmlBuilder: mathmlBuilder$7
      });
      defineFunction({
        type: "cr",
        names: ["\\\\"],
        props: {
          numArgs: 0,
          numOptionalArgs: 0,
          allowedInText: true
        },
        handler(_ref, args, optArgs) {
          var {
            parser: parser23
          } = _ref;
          var size5 = parser23.gullet.future().text === "[" ? parser23.parseSizeGroup(true) : null;
          var newLine = !parser23.settings.displayMode || !parser23.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
          return {
            type: "cr",
            mode: parser23.mode,
            newLine,
            size: size5 && assertNodeType(size5, "size").value
          };
        },
        // The following builders are called only at the top level,
        // not within tabular/array environments.
        htmlBuilder(group2, options3) {
          var span = buildCommon.makeSpan(["mspace"], [], options3);
          if (group2.newLine) {
            span.classes.push("newline");
            if (group2.size) {
              span.style.marginTop = makeEm(calculateSize2(group2.size, options3));
            }
          }
          return span;
        },
        mathmlBuilder(group2, options3) {
          var node2 = new mathMLTree.MathNode("mspace");
          if (group2.newLine) {
            node2.setAttribute("linebreak", "newline");
            if (group2.size) {
              node2.setAttribute("height", makeEm(calculateSize2(group2.size, options3)));
            }
          }
          return node2;
        }
      });
      globalMap = {
        "\\global": "\\global",
        "\\long": "\\\\globallong",
        "\\\\globallong": "\\\\globallong",
        "\\def": "\\gdef",
        "\\gdef": "\\gdef",
        "\\edef": "\\xdef",
        "\\xdef": "\\xdef",
        "\\let": "\\\\globallet",
        "\\futurelet": "\\\\globalfuture"
      };
      checkControlSequence = /* @__PURE__ */ __name((tok) => {
        var name = tok.text;
        if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
          throw new ParseError("Expected a control sequence", tok);
        }
        return name;
      }, "checkControlSequence");
      getRHS = /* @__PURE__ */ __name((parser23) => {
        var tok = parser23.gullet.popToken();
        if (tok.text === "=") {
          tok = parser23.gullet.popToken();
          if (tok.text === " ") {
            tok = parser23.gullet.popToken();
          }
        }
        return tok;
      }, "getRHS");
      letCommand = /* @__PURE__ */ __name((parser23, name, tok, global2) => {
        var macro = parser23.gullet.macros.get(tok.text);
        if (macro == null) {
          tok.noexpand = true;
          macro = {
            tokens: [tok],
            numArgs: 0,
            // reproduce the same behavior in expansion
            unexpandable: !parser23.gullet.isExpandable(tok.text)
          };
        }
        parser23.gullet.macros.set(name, macro, global2);
      }, "letCommand");
      defineFunction({
        type: "internal",
        names: [
          "\\global",
          "\\long",
          "\\\\globallong"
          // can’t be entered directly
        ],
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler(_ref) {
          var {
            parser: parser23,
            funcName
          } = _ref;
          parser23.consumeSpaces();
          var token2 = parser23.fetch();
          if (globalMap[token2.text]) {
            if (funcName === "\\global" || funcName === "\\\\globallong") {
              token2.text = globalMap[token2.text];
            }
            return assertNodeType(parser23.parseFunction(), "internal");
          }
          throw new ParseError("Invalid token after macro prefix", token2);
        }
      });
      defineFunction({
        type: "internal",
        names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler(_ref2) {
          var {
            parser: parser23,
            funcName
          } = _ref2;
          var tok = parser23.gullet.popToken();
          var name = tok.text;
          if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
            throw new ParseError("Expected a control sequence", tok);
          }
          var numArgs = 0;
          var insert;
          var delimiters2 = [[]];
          while (parser23.gullet.future().text !== "{") {
            tok = parser23.gullet.popToken();
            if (tok.text === "#") {
              if (parser23.gullet.future().text === "{") {
                insert = parser23.gullet.future();
                delimiters2[numArgs].push("{");
                break;
              }
              tok = parser23.gullet.popToken();
              if (!/^[1-9]$/.test(tok.text)) {
                throw new ParseError('Invalid argument number "' + tok.text + '"');
              }
              if (parseInt(tok.text) !== numArgs + 1) {
                throw new ParseError('Argument number "' + tok.text + '" out of order');
              }
              numArgs++;
              delimiters2.push([]);
            } else if (tok.text === "EOF") {
              throw new ParseError("Expected a macro definition");
            } else {
              delimiters2[numArgs].push(tok.text);
            }
          }
          var {
            tokens: tokens2
          } = parser23.gullet.consumeArg();
          if (insert) {
            tokens2.unshift(insert);
          }
          if (funcName === "\\edef" || funcName === "\\xdef") {
            tokens2 = parser23.gullet.expandTokens(tokens2);
            tokens2.reverse();
          }
          parser23.gullet.macros.set(name, {
            tokens: tokens2,
            numArgs,
            delimiters: delimiters2
          }, funcName === globalMap[funcName]);
          return {
            type: "internal",
            mode: parser23.mode
          };
        }
      });
      defineFunction({
        type: "internal",
        names: [
          "\\let",
          "\\\\globallet"
          // can’t be entered directly
        ],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler(_ref3) {
          var {
            parser: parser23,
            funcName
          } = _ref3;
          var name = checkControlSequence(parser23.gullet.popToken());
          parser23.gullet.consumeSpaces();
          var tok = getRHS(parser23);
          letCommand(parser23, name, tok, funcName === "\\\\globallet");
          return {
            type: "internal",
            mode: parser23.mode
          };
        }
      });
      defineFunction({
        type: "internal",
        names: [
          "\\futurelet",
          "\\\\globalfuture"
          // can’t be entered directly
        ],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler(_ref4) {
          var {
            parser: parser23,
            funcName
          } = _ref4;
          var name = checkControlSequence(parser23.gullet.popToken());
          var middle = parser23.gullet.popToken();
          var tok = parser23.gullet.popToken();
          letCommand(parser23, name, tok, funcName === "\\\\globalfuture");
          parser23.gullet.pushToken(tok);
          parser23.gullet.pushToken(middle);
          return {
            type: "internal",
            mode: parser23.mode
          };
        }
      });
      getMetrics = /* @__PURE__ */ __name(function getMetrics2(symbol, font, mode) {
        var replace2 = symbols.math[symbol] && symbols.math[symbol].replace;
        var metrics = getCharacterMetrics(replace2 || symbol, font, mode);
        if (!metrics) {
          throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
        }
        return metrics;
      }, "getMetrics");
      styleWrap = /* @__PURE__ */ __name(function styleWrap2(delim, toStyle, options3, classes6) {
        var newOptions = options3.havingBaseStyle(toStyle);
        var span = buildCommon.makeSpan(classes6.concat(newOptions.sizingClasses(options3)), [delim], options3);
        var delimSizeMultiplier = newOptions.sizeMultiplier / options3.sizeMultiplier;
        span.height *= delimSizeMultiplier;
        span.depth *= delimSizeMultiplier;
        span.maxFontSize = newOptions.sizeMultiplier;
        return span;
      }, "styleWrap");
      centerSpan = /* @__PURE__ */ __name(function centerSpan2(span, options3, style3) {
        var newOptions = options3.havingBaseStyle(style3);
        var shift2 = (1 - options3.sizeMultiplier / newOptions.sizeMultiplier) * options3.fontMetrics().axisHeight;
        span.classes.push("delimcenter");
        span.style.top = makeEm(shift2);
        span.height -= shift2;
        span.depth += shift2;
      }, "centerSpan");
      makeSmallDelim = /* @__PURE__ */ __name(function makeSmallDelim2(delim, style3, center4, options3, mode, classes6) {
        var text4 = buildCommon.makeSymbol(delim, "Main-Regular", mode, options3);
        var span = styleWrap(text4, style3, options3, classes6);
        if (center4) {
          centerSpan(span, options3, style3);
        }
        return span;
      }, "makeSmallDelim");
      mathrmSize = /* @__PURE__ */ __name(function mathrmSize2(value2, size5, mode, options3) {
        return buildCommon.makeSymbol(value2, "Size" + size5 + "-Regular", mode, options3);
      }, "mathrmSize");
      makeLargeDelim = /* @__PURE__ */ __name(function makeLargeDelim2(delim, size5, center4, options3, mode, classes6) {
        var inner2 = mathrmSize(delim, size5, mode, options3);
        var span = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size5], [inner2], options3), Style$1.TEXT, options3, classes6);
        if (center4) {
          centerSpan(span, options3, Style$1.TEXT);
        }
        return span;
      }, "makeLargeDelim");
      makeGlyphSpan = /* @__PURE__ */ __name(function makeGlyphSpan2(symbol, font, mode) {
        var sizeClass;
        if (font === "Size1-Regular") {
          sizeClass = "delim-size1";
        } else {
          sizeClass = "delim-size4";
        }
        var corner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);
        return {
          type: "elem",
          elem: corner
        };
      }, "makeGlyphSpan");
      makeInner = /* @__PURE__ */ __name(function makeInner2(ch, height2, options3) {
        var width3 = fontMetricsData["Size4-Regular"][ch.charCodeAt(0)] ? fontMetricsData["Size4-Regular"][ch.charCodeAt(0)][4] : fontMetricsData["Size1-Regular"][ch.charCodeAt(0)][4];
        var path4 = new PathNode("inner", innerPath(ch, Math.round(1e3 * height2)));
        var svgNode2 = new SvgNode([path4], {
          "width": makeEm(width3),
          "height": makeEm(height2),
          // Override CSS rule `.katex svg { width: 100% }`
          "style": "width:" + makeEm(width3),
          "viewBox": "0 0 " + 1e3 * width3 + " " + Math.round(1e3 * height2),
          "preserveAspectRatio": "xMinYMin"
        });
        var span = buildCommon.makeSvgSpan([], [svgNode2], options3);
        span.height = height2;
        span.style.height = makeEm(height2);
        span.style.width = makeEm(width3);
        return {
          type: "elem",
          elem: span
        };
      }, "makeInner");
      lapInEms = 8e-3;
      lap = {
        type: "kern",
        size: -1 * lapInEms
      };
      verts = ["|", "\\lvert", "\\rvert", "\\vert"];
      doubleVerts = ["\\|", "\\lVert", "\\rVert", "\\Vert"];
      makeStackedDelim = /* @__PURE__ */ __name(function makeStackedDelim2(delim, heightTotal, center4, options3, mode, classes6) {
        var top2;
        var middle;
        var repeat2;
        var bottom2;
        var svgLabel = "";
        var viewBoxWidth = 0;
        top2 = repeat2 = bottom2 = delim;
        middle = null;
        var font = "Size1-Regular";
        if (delim === "\\uparrow") {
          repeat2 = bottom2 = "\u23D0";
        } else if (delim === "\\Uparrow") {
          repeat2 = bottom2 = "\u2016";
        } else if (delim === "\\downarrow") {
          top2 = repeat2 = "\u23D0";
        } else if (delim === "\\Downarrow") {
          top2 = repeat2 = "\u2016";
        } else if (delim === "\\updownarrow") {
          top2 = "\\uparrow";
          repeat2 = "\u23D0";
          bottom2 = "\\downarrow";
        } else if (delim === "\\Updownarrow") {
          top2 = "\\Uparrow";
          repeat2 = "\u2016";
          bottom2 = "\\Downarrow";
        } else if (utils.contains(verts, delim)) {
          repeat2 = "\u2223";
          svgLabel = "vert";
          viewBoxWidth = 333;
        } else if (utils.contains(doubleVerts, delim)) {
          repeat2 = "\u2225";
          svgLabel = "doublevert";
          viewBoxWidth = 556;
        } else if (delim === "[" || delim === "\\lbrack") {
          top2 = "\u23A1";
          repeat2 = "\u23A2";
          bottom2 = "\u23A3";
          font = "Size4-Regular";
          svgLabel = "lbrack";
          viewBoxWidth = 667;
        } else if (delim === "]" || delim === "\\rbrack") {
          top2 = "\u23A4";
          repeat2 = "\u23A5";
          bottom2 = "\u23A6";
          font = "Size4-Regular";
          svgLabel = "rbrack";
          viewBoxWidth = 667;
        } else if (delim === "\\lfloor" || delim === "\u230A") {
          repeat2 = top2 = "\u23A2";
          bottom2 = "\u23A3";
          font = "Size4-Regular";
          svgLabel = "lfloor";
          viewBoxWidth = 667;
        } else if (delim === "\\lceil" || delim === "\u2308") {
          top2 = "\u23A1";
          repeat2 = bottom2 = "\u23A2";
          font = "Size4-Regular";
          svgLabel = "lceil";
          viewBoxWidth = 667;
        } else if (delim === "\\rfloor" || delim === "\u230B") {
          repeat2 = top2 = "\u23A5";
          bottom2 = "\u23A6";
          font = "Size4-Regular";
          svgLabel = "rfloor";
          viewBoxWidth = 667;
        } else if (delim === "\\rceil" || delim === "\u2309") {
          top2 = "\u23A4";
          repeat2 = bottom2 = "\u23A5";
          font = "Size4-Regular";
          svgLabel = "rceil";
          viewBoxWidth = 667;
        } else if (delim === "(" || delim === "\\lparen") {
          top2 = "\u239B";
          repeat2 = "\u239C";
          bottom2 = "\u239D";
          font = "Size4-Regular";
          svgLabel = "lparen";
          viewBoxWidth = 875;
        } else if (delim === ")" || delim === "\\rparen") {
          top2 = "\u239E";
          repeat2 = "\u239F";
          bottom2 = "\u23A0";
          font = "Size4-Regular";
          svgLabel = "rparen";
          viewBoxWidth = 875;
        } else if (delim === "\\{" || delim === "\\lbrace") {
          top2 = "\u23A7";
          middle = "\u23A8";
          bottom2 = "\u23A9";
          repeat2 = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\}" || delim === "\\rbrace") {
          top2 = "\u23AB";
          middle = "\u23AC";
          bottom2 = "\u23AD";
          repeat2 = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\lgroup" || delim === "\u27EE") {
          top2 = "\u23A7";
          bottom2 = "\u23A9";
          repeat2 = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\rgroup" || delim === "\u27EF") {
          top2 = "\u23AB";
          bottom2 = "\u23AD";
          repeat2 = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\lmoustache" || delim === "\u23B0") {
          top2 = "\u23A7";
          bottom2 = "\u23AD";
          repeat2 = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\rmoustache" || delim === "\u23B1") {
          top2 = "\u23AB";
          bottom2 = "\u23A9";
          repeat2 = "\u23AA";
          font = "Size4-Regular";
        }
        var topMetrics = getMetrics(top2, font, mode);
        var topHeightTotal = topMetrics.height + topMetrics.depth;
        var repeatMetrics = getMetrics(repeat2, font, mode);
        var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
        var bottomMetrics = getMetrics(bottom2, font, mode);
        var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
        var middleHeightTotal = 0;
        var middleFactor = 1;
        if (middle !== null) {
          var middleMetrics = getMetrics(middle, font, mode);
          middleHeightTotal = middleMetrics.height + middleMetrics.depth;
          middleFactor = 2;
        }
        var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
        var repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)));
        var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
        var axisHeight = options3.fontMetrics().axisHeight;
        if (center4) {
          axisHeight *= options3.sizeMultiplier;
        }
        var depth = realHeightTotal / 2 - axisHeight;
        var stack = [];
        if (svgLabel.length > 0) {
          var midHeight = realHeightTotal - topHeightTotal - bottomHeightTotal;
          var viewBoxHeight = Math.round(realHeightTotal * 1e3);
          var pathStr = tallDelim(svgLabel, Math.round(midHeight * 1e3));
          var path4 = new PathNode(svgLabel, pathStr);
          var width3 = (viewBoxWidth / 1e3).toFixed(3) + "em";
          var height2 = (viewBoxHeight / 1e3).toFixed(3) + "em";
          var svg2 = new SvgNode([path4], {
            "width": width3,
            "height": height2,
            "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight
          });
          var wrapper = buildCommon.makeSvgSpan([], [svg2], options3);
          wrapper.height = viewBoxHeight / 1e3;
          wrapper.style.width = width3;
          wrapper.style.height = height2;
          stack.push({
            type: "elem",
            elem: wrapper
          });
        } else {
          stack.push(makeGlyphSpan(bottom2, font, mode));
          stack.push(lap);
          if (middle === null) {
            var innerHeight = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms;
            stack.push(makeInner(repeat2, innerHeight, options3));
          } else {
            var _innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms;
            stack.push(makeInner(repeat2, _innerHeight, options3));
            stack.push(lap);
            stack.push(makeGlyphSpan(middle, font, mode));
            stack.push(lap);
            stack.push(makeInner(repeat2, _innerHeight, options3));
          }
          stack.push(lap);
          stack.push(makeGlyphSpan(top2, font, mode));
        }
        var newOptions = options3.havingBaseStyle(Style$1.TEXT);
        var inner2 = buildCommon.makeVList({
          positionType: "bottom",
          positionData: depth,
          children: stack
        }, newOptions);
        return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner2], newOptions), Style$1.TEXT, options3, classes6);
      }, "makeStackedDelim");
      vbPad = 80;
      emPad = 0.08;
      sqrtSvg = /* @__PURE__ */ __name(function sqrtSvg2(sqrtName, height2, viewBoxHeight, extraVinculum, options3) {
        var path4 = sqrtPath(sqrtName, extraVinculum, viewBoxHeight);
        var pathNode = new PathNode(sqrtName, path4);
        var svg2 = new SvgNode([pathNode], {
          // Note: 1000:1 ratio of viewBox to document em width.
          "width": "400em",
          "height": makeEm(height2),
          "viewBox": "0 0 400000 " + viewBoxHeight,
          "preserveAspectRatio": "xMinYMin slice"
        });
        return buildCommon.makeSvgSpan(["hide-tail"], [svg2], options3);
      }, "sqrtSvg");
      makeSqrtImage = /* @__PURE__ */ __name(function makeSqrtImage2(height2, options3) {
        var newOptions = options3.havingBaseSizing();
        var delim = traverseSequence("\\surd", height2 * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
        var sizeMultiplier = newOptions.sizeMultiplier;
        var extraVinculum = Math.max(0, options3.minRuleThickness - options3.fontMetrics().sqrtRuleThickness);
        var span;
        var spanHeight = 0;
        var texHeight = 0;
        var viewBoxHeight = 0;
        var advanceWidth;
        if (delim.type === "small") {
          viewBoxHeight = 1e3 + 1e3 * extraVinculum + vbPad;
          if (height2 < 1) {
            sizeMultiplier = 1;
          } else if (height2 < 1.4) {
            sizeMultiplier = 0.7;
          }
          spanHeight = (1 + extraVinculum + emPad) / sizeMultiplier;
          texHeight = (1 + extraVinculum) / sizeMultiplier;
          span = sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, extraVinculum, options3);
          span.style.minWidth = "0.853em";
          advanceWidth = 0.833 / sizeMultiplier;
        } else if (delim.type === "large") {
          viewBoxHeight = (1e3 + vbPad) * sizeToMaxHeight[delim.size];
          texHeight = (sizeToMaxHeight[delim.size] + extraVinculum) / sizeMultiplier;
          spanHeight = (sizeToMaxHeight[delim.size] + extraVinculum + emPad) / sizeMultiplier;
          span = sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraVinculum, options3);
          span.style.minWidth = "1.02em";
          advanceWidth = 1 / sizeMultiplier;
        } else {
          spanHeight = height2 + extraVinculum + emPad;
          texHeight = height2 + extraVinculum;
          viewBoxHeight = Math.floor(1e3 * height2 + extraVinculum) + vbPad;
          span = sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, extraVinculum, options3);
          span.style.minWidth = "0.742em";
          advanceWidth = 1.056;
        }
        span.height = texHeight;
        span.style.height = makeEm(spanHeight);
        return {
          span,
          advanceWidth,
          // Calculate the actual line width.
          // This actually should depend on the chosen font -- e.g. \boldmath
          // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
          // have thicker rules.
          ruleWidth: (options3.fontMetrics().sqrtRuleThickness + extraVinculum) * sizeMultiplier
        };
      }, "makeSqrtImage");
      stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "\\surd"];
      stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1"];
      stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"];
      sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3];
      makeSizedDelim = /* @__PURE__ */ __name(function makeSizedDelim2(delim, size5, options3, mode, classes6) {
        if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
          delim = "\\langle";
        } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
          delim = "\\rangle";
        }
        if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {
          return makeLargeDelim(delim, size5, false, options3, mode, classes6);
        } else if (utils.contains(stackAlwaysDelimiters, delim)) {
          return makeStackedDelim(delim, sizeToMaxHeight[size5], false, options3, mode, classes6);
        } else {
          throw new ParseError("Illegal delimiter: '" + delim + "'");
        }
      }, "makeSizedDelim");
      stackNeverDelimiterSequence = [{
        type: "small",
        style: Style$1.SCRIPTSCRIPT
      }, {
        type: "small",
        style: Style$1.SCRIPT
      }, {
        type: "small",
        style: Style$1.TEXT
      }, {
        type: "large",
        size: 1
      }, {
        type: "large",
        size: 2
      }, {
        type: "large",
        size: 3
      }, {
        type: "large",
        size: 4
      }];
      stackAlwaysDelimiterSequence = [{
        type: "small",
        style: Style$1.SCRIPTSCRIPT
      }, {
        type: "small",
        style: Style$1.SCRIPT
      }, {
        type: "small",
        style: Style$1.TEXT
      }, {
        type: "stack"
      }];
      stackLargeDelimiterSequence = [{
        type: "small",
        style: Style$1.SCRIPTSCRIPT
      }, {
        type: "small",
        style: Style$1.SCRIPT
      }, {
        type: "small",
        style: Style$1.TEXT
      }, {
        type: "large",
        size: 1
      }, {
        type: "large",
        size: 2
      }, {
        type: "large",
        size: 3
      }, {
        type: "large",
        size: 4
      }, {
        type: "stack"
      }];
      delimTypeToFont = /* @__PURE__ */ __name(function delimTypeToFont2(type3) {
        if (type3.type === "small") {
          return "Main-Regular";
        } else if (type3.type === "large") {
          return "Size" + type3.size + "-Regular";
        } else if (type3.type === "stack") {
          return "Size4-Regular";
        } else {
          throw new Error("Add support for delim type '" + type3.type + "' here.");
        }
      }, "delimTypeToFont");
      traverseSequence = /* @__PURE__ */ __name(function traverseSequence2(delim, height2, sequence, options3) {
        var start3 = Math.min(2, 3 - options3.style.size);
        for (var i2 = start3; i2 < sequence.length; i2++) {
          if (sequence[i2].type === "stack") {
            break;
          }
          var metrics = getMetrics(delim, delimTypeToFont(sequence[i2]), "math");
          var heightDepth = metrics.height + metrics.depth;
          if (sequence[i2].type === "small") {
            var newOptions = options3.havingBaseStyle(sequence[i2].style);
            heightDepth *= newOptions.sizeMultiplier;
          }
          if (heightDepth > height2) {
            return sequence[i2];
          }
        }
        return sequence[sequence.length - 1];
      }, "traverseSequence");
      makeCustomSizedDelim = /* @__PURE__ */ __name(function makeCustomSizedDelim2(delim, height2, center4, options3, mode, classes6) {
        if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
          delim = "\\langle";
        } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
          delim = "\\rangle";
        }
        var sequence;
        if (utils.contains(stackNeverDelimiters, delim)) {
          sequence = stackNeverDelimiterSequence;
        } else if (utils.contains(stackLargeDelimiters, delim)) {
          sequence = stackLargeDelimiterSequence;
        } else {
          sequence = stackAlwaysDelimiterSequence;
        }
        var delimType = traverseSequence(delim, height2, sequence, options3);
        if (delimType.type === "small") {
          return makeSmallDelim(delim, delimType.style, center4, options3, mode, classes6);
        } else if (delimType.type === "large") {
          return makeLargeDelim(delim, delimType.size, center4, options3, mode, classes6);
        } else {
          return makeStackedDelim(delim, height2, center4, options3, mode, classes6);
        }
      }, "makeCustomSizedDelim");
      makeLeftRightDelim = /* @__PURE__ */ __name(function makeLeftRightDelim2(delim, height2, depth, options3, mode, classes6) {
        var axisHeight = options3.fontMetrics().axisHeight * options3.sizeMultiplier;
        var delimiterFactor = 901;
        var delimiterExtend = 5 / options3.fontMetrics().ptPerEm;
        var maxDistFromAxis = Math.max(height2 - axisHeight, depth + axisHeight);
        var totalHeight = Math.max(
          // In real TeX, calculations are done using integral values which are
          // 65536 per pt, or 655360 per em. So, the division here truncates in
          // TeX but doesn't here, producing different results. If we wanted to
          // exactly match TeX's calculation, we could do
          //   Math.floor(655360 * maxDistFromAxis / 500) *
          //    delimiterFactor / 655360
          // (To see the difference, compare
          //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
          // in TeX and KaTeX)
          maxDistFromAxis / 500 * delimiterFactor,
          2 * maxDistFromAxis - delimiterExtend
        );
        return makeCustomSizedDelim(delim, totalHeight, true, options3, mode, classes6);
      }, "makeLeftRightDelim");
      delimiter = {
        sqrtImage: makeSqrtImage,
        sizedDelim: makeSizedDelim,
        sizeToMaxHeight,
        customSizedDelim: makeCustomSizedDelim,
        leftRightDelim: makeLeftRightDelim
      };
      delimiterSizes = {
        "\\bigl": {
          mclass: "mopen",
          size: 1
        },
        "\\Bigl": {
          mclass: "mopen",
          size: 2
        },
        "\\biggl": {
          mclass: "mopen",
          size: 3
        },
        "\\Biggl": {
          mclass: "mopen",
          size: 4
        },
        "\\bigr": {
          mclass: "mclose",
          size: 1
        },
        "\\Bigr": {
          mclass: "mclose",
          size: 2
        },
        "\\biggr": {
          mclass: "mclose",
          size: 3
        },
        "\\Biggr": {
          mclass: "mclose",
          size: 4
        },
        "\\bigm": {
          mclass: "mrel",
          size: 1
        },
        "\\Bigm": {
          mclass: "mrel",
          size: 2
        },
        "\\biggm": {
          mclass: "mrel",
          size: 3
        },
        "\\Biggm": {
          mclass: "mrel",
          size: 4
        },
        "\\big": {
          mclass: "mord",
          size: 1
        },
        "\\Big": {
          mclass: "mord",
          size: 2
        },
        "\\bigg": {
          mclass: "mord",
          size: 3
        },
        "\\Bigg": {
          mclass: "mord",
          size: 4
        }
      };
      delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "<", ">", "\\langle", "\u27E8", "\\rangle", "\u27E9", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
      __name(checkDelimiter, "checkDelimiter");
      defineFunction({
        type: "delimsizing",
        names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
        props: {
          numArgs: 1,
          argTypes: ["primitive"]
        },
        handler: /* @__PURE__ */ __name((context, args) => {
          var delim = checkDelimiter(args[0], context);
          return {
            type: "delimsizing",
            mode: context.parser.mode,
            size: delimiterSizes[context.funcName].size,
            mclass: delimiterSizes[context.funcName].mclass,
            delim: delim.text
          };
        }, "handler"),
        htmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          if (group2.delim === ".") {
            return buildCommon.makeSpan([group2.mclass]);
          }
          return delimiter.sizedDelim(group2.delim, group2.size, options3, group2.mode, [group2.mclass]);
        }, "htmlBuilder"),
        mathmlBuilder: /* @__PURE__ */ __name((group2) => {
          var children2 = [];
          if (group2.delim !== ".") {
            children2.push(makeText(group2.delim, group2.mode));
          }
          var node2 = new mathMLTree.MathNode("mo", children2);
          if (group2.mclass === "mopen" || group2.mclass === "mclose") {
            node2.setAttribute("fence", "true");
          } else {
            node2.setAttribute("fence", "false");
          }
          node2.setAttribute("stretchy", "true");
          var size5 = makeEm(delimiter.sizeToMaxHeight[group2.size]);
          node2.setAttribute("minsize", size5);
          node2.setAttribute("maxsize", size5);
          return node2;
        }, "mathmlBuilder")
      });
      __name(assertParsed, "assertParsed");
      defineFunction({
        type: "leftright-right",
        names: ["\\right"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: /* @__PURE__ */ __name((context, args) => {
          var color2 = context.parser.gullet.macros.get("\\current@color");
          if (color2 && typeof color2 !== "string") {
            throw new ParseError("\\current@color set to non-string in \\right");
          }
          return {
            type: "leftright-right",
            mode: context.parser.mode,
            delim: checkDelimiter(args[0], context).text,
            color: color2
            // undefined if not set via \color
          };
        }, "handler")
      });
      defineFunction({
        type: "leftright",
        names: ["\\left"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: /* @__PURE__ */ __name((context, args) => {
          var delim = checkDelimiter(args[0], context);
          var parser23 = context.parser;
          ++parser23.leftrightDepth;
          var body = parser23.parseExpression(false);
          --parser23.leftrightDepth;
          parser23.expect("\\right", false);
          var right3 = assertNodeType(parser23.parseFunction(), "leftright-right");
          return {
            type: "leftright",
            mode: parser23.mode,
            body,
            left: delim.text,
            right: right3.delim,
            rightColor: right3.color
          };
        }, "handler"),
        htmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          assertParsed(group2);
          var inner2 = buildExpression$1(group2.body, options3, true, ["mopen", "mclose"]);
          var innerHeight = 0;
          var innerDepth = 0;
          var hadMiddle = false;
          for (var i2 = 0; i2 < inner2.length; i2++) {
            if (inner2[i2].isMiddle) {
              hadMiddle = true;
            } else {
              innerHeight = Math.max(inner2[i2].height, innerHeight);
              innerDepth = Math.max(inner2[i2].depth, innerDepth);
            }
          }
          innerHeight *= options3.sizeMultiplier;
          innerDepth *= options3.sizeMultiplier;
          var leftDelim;
          if (group2.left === ".") {
            leftDelim = makeNullDelimiter(options3, ["mopen"]);
          } else {
            leftDelim = delimiter.leftRightDelim(group2.left, innerHeight, innerDepth, options3, group2.mode, ["mopen"]);
          }
          inner2.unshift(leftDelim);
          if (hadMiddle) {
            for (var _i = 1; _i < inner2.length; _i++) {
              var middleDelim = inner2[_i];
              var isMiddle = middleDelim.isMiddle;
              if (isMiddle) {
                inner2[_i] = delimiter.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group2.mode, []);
              }
            }
          }
          var rightDelim;
          if (group2.right === ".") {
            rightDelim = makeNullDelimiter(options3, ["mclose"]);
          } else {
            var colorOptions = group2.rightColor ? options3.withColor(group2.rightColor) : options3;
            rightDelim = delimiter.leftRightDelim(group2.right, innerHeight, innerDepth, colorOptions, group2.mode, ["mclose"]);
          }
          inner2.push(rightDelim);
          return buildCommon.makeSpan(["minner"], inner2, options3);
        }, "htmlBuilder"),
        mathmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          assertParsed(group2);
          var inner2 = buildExpression2(group2.body, options3);
          if (group2.left !== ".") {
            var leftNode = new mathMLTree.MathNode("mo", [makeText(group2.left, group2.mode)]);
            leftNode.setAttribute("fence", "true");
            inner2.unshift(leftNode);
          }
          if (group2.right !== ".") {
            var rightNode = new mathMLTree.MathNode("mo", [makeText(group2.right, group2.mode)]);
            rightNode.setAttribute("fence", "true");
            if (group2.rightColor) {
              rightNode.setAttribute("mathcolor", group2.rightColor);
            }
            inner2.push(rightNode);
          }
          return makeRow(inner2);
        }, "mathmlBuilder")
      });
      defineFunction({
        type: "middle",
        names: ["\\middle"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: /* @__PURE__ */ __name((context, args) => {
          var delim = checkDelimiter(args[0], context);
          if (!context.parser.leftrightDepth) {
            throw new ParseError("\\middle without preceding \\left", delim);
          }
          return {
            type: "middle",
            mode: context.parser.mode,
            delim: delim.text
          };
        }, "handler"),
        htmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          var middleDelim;
          if (group2.delim === ".") {
            middleDelim = makeNullDelimiter(options3, []);
          } else {
            middleDelim = delimiter.sizedDelim(group2.delim, 1, options3, group2.mode, []);
            var isMiddle = {
              delim: group2.delim,
              options: options3
            };
            middleDelim.isMiddle = isMiddle;
          }
          return middleDelim;
        }, "htmlBuilder"),
        mathmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          var textNode = group2.delim === "\\vert" || group2.delim === "|" ? makeText("|", "text") : makeText(group2.delim, group2.mode);
          var middleNode = new mathMLTree.MathNode("mo", [textNode]);
          middleNode.setAttribute("fence", "true");
          middleNode.setAttribute("lspace", "0.05em");
          middleNode.setAttribute("rspace", "0.05em");
          return middleNode;
        }, "mathmlBuilder")
      });
      htmlBuilder$7 = /* @__PURE__ */ __name((group2, options3) => {
        var inner2 = buildCommon.wrapFragment(buildGroup$1(group2.body, options3), options3);
        var label = group2.label.slice(1);
        var scale = options3.sizeMultiplier;
        var img;
        var imgShift = 0;
        var isSingleChar = utils.isCharacterBox(group2.body);
        if (label === "sout") {
          img = buildCommon.makeSpan(["stretchy", "sout"]);
          img.height = options3.fontMetrics().defaultRuleThickness / scale;
          imgShift = -0.5 * options3.fontMetrics().xHeight;
        } else if (label === "phase") {
          var lineWeight = calculateSize2({
            number: 0.6,
            unit: "pt"
          }, options3);
          var clearance = calculateSize2({
            number: 0.35,
            unit: "ex"
          }, options3);
          var newOptions = options3.havingBaseSizing();
          scale = scale / newOptions.sizeMultiplier;
          var angleHeight = inner2.height + inner2.depth + lineWeight + clearance;
          inner2.style.paddingLeft = makeEm(angleHeight / 2 + lineWeight);
          var viewBoxHeight = Math.floor(1e3 * angleHeight * scale);
          var path4 = phasePath(viewBoxHeight);
          var svgNode2 = new SvgNode([new PathNode("phase", path4)], {
            "width": "400em",
            "height": makeEm(viewBoxHeight / 1e3),
            "viewBox": "0 0 400000 " + viewBoxHeight,
            "preserveAspectRatio": "xMinYMin slice"
          });
          img = buildCommon.makeSvgSpan(["hide-tail"], [svgNode2], options3);
          img.style.height = makeEm(angleHeight);
          imgShift = inner2.depth + lineWeight + clearance;
        } else {
          if (/cancel/.test(label)) {
            if (!isSingleChar) {
              inner2.classes.push("cancel-pad");
            }
          } else if (label === "angl") {
            inner2.classes.push("anglpad");
          } else {
            inner2.classes.push("boxpad");
          }
          var topPad = 0;
          var bottomPad = 0;
          var ruleThickness = 0;
          if (/box/.test(label)) {
            ruleThickness = Math.max(
              options3.fontMetrics().fboxrule,
              // default
              options3.minRuleThickness
              // User override.
            );
            topPad = options3.fontMetrics().fboxsep + (label === "colorbox" ? 0 : ruleThickness);
            bottomPad = topPad;
          } else if (label === "angl") {
            ruleThickness = Math.max(options3.fontMetrics().defaultRuleThickness, options3.minRuleThickness);
            topPad = 4 * ruleThickness;
            bottomPad = Math.max(0, 0.25 - inner2.depth);
          } else {
            topPad = isSingleChar ? 0.2 : 0;
            bottomPad = topPad;
          }
          img = stretchy.encloseSpan(inner2, label, topPad, bottomPad, options3);
          if (/fbox|boxed|fcolorbox/.test(label)) {
            img.style.borderStyle = "solid";
            img.style.borderWidth = makeEm(ruleThickness);
          } else if (label === "angl" && ruleThickness !== 0.049) {
            img.style.borderTopWidth = makeEm(ruleThickness);
            img.style.borderRightWidth = makeEm(ruleThickness);
          }
          imgShift = inner2.depth + bottomPad;
          if (group2.backgroundColor) {
            img.style.backgroundColor = group2.backgroundColor;
            if (group2.borderColor) {
              img.style.borderColor = group2.borderColor;
            }
          }
        }
        var vlist;
        if (group2.backgroundColor) {
          vlist = buildCommon.makeVList({
            positionType: "individualShift",
            children: [
              // Put the color background behind inner;
              {
                type: "elem",
                elem: img,
                shift: imgShift
              },
              {
                type: "elem",
                elem: inner2,
                shift: 0
              }
            ]
          }, options3);
        } else {
          var classes6 = /cancel|phase/.test(label) ? ["svg-align"] : [];
          vlist = buildCommon.makeVList({
            positionType: "individualShift",
            children: [
              // Write the \cancel stroke on top of inner.
              {
                type: "elem",
                elem: inner2,
                shift: 0
              },
              {
                type: "elem",
                elem: img,
                shift: imgShift,
                wrapperClasses: classes6
              }
            ]
          }, options3);
        }
        if (/cancel/.test(label)) {
          vlist.height = inner2.height;
          vlist.depth = inner2.depth;
        }
        if (/cancel/.test(label) && !isSingleChar) {
          return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options3);
        } else {
          return buildCommon.makeSpan(["mord"], [vlist], options3);
        }
      }, "htmlBuilder$7");
      mathmlBuilder$6 = /* @__PURE__ */ __name((group2, options3) => {
        var fboxsep = 0;
        var node2 = new mathMLTree.MathNode(group2.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildGroup2(group2.body, options3)]);
        switch (group2.label) {
          case "\\cancel":
            node2.setAttribute("notation", "updiagonalstrike");
            break;
          case "\\bcancel":
            node2.setAttribute("notation", "downdiagonalstrike");
            break;
          case "\\phase":
            node2.setAttribute("notation", "phasorangle");
            break;
          case "\\sout":
            node2.setAttribute("notation", "horizontalstrike");
            break;
          case "\\fbox":
            node2.setAttribute("notation", "box");
            break;
          case "\\angl":
            node2.setAttribute("notation", "actuarial");
            break;
          case "\\fcolorbox":
          case "\\colorbox":
            fboxsep = options3.fontMetrics().fboxsep * options3.fontMetrics().ptPerEm;
            node2.setAttribute("width", "+" + 2 * fboxsep + "pt");
            node2.setAttribute("height", "+" + 2 * fboxsep + "pt");
            node2.setAttribute("lspace", fboxsep + "pt");
            node2.setAttribute("voffset", fboxsep + "pt");
            if (group2.label === "\\fcolorbox") {
              var thk = Math.max(
                options3.fontMetrics().fboxrule,
                // default
                options3.minRuleThickness
                // user override
              );
              node2.setAttribute("style", "border: " + thk + "em solid " + String(group2.borderColor));
            }
            break;
          case "\\xcancel":
            node2.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
            break;
        }
        if (group2.backgroundColor) {
          node2.setAttribute("mathbackground", group2.backgroundColor);
        }
        return node2;
      }, "mathmlBuilder$6");
      defineFunction({
        type: "enclose",
        names: ["\\colorbox"],
        props: {
          numArgs: 2,
          allowedInText: true,
          argTypes: ["color", "text"]
        },
        handler(_ref, args, optArgs) {
          var {
            parser: parser23,
            funcName
          } = _ref;
          var color2 = assertNodeType(args[0], "color-token").color;
          var body = args[1];
          return {
            type: "enclose",
            mode: parser23.mode,
            label: funcName,
            backgroundColor: color2,
            body
          };
        },
        htmlBuilder: htmlBuilder$7,
        mathmlBuilder: mathmlBuilder$6
      });
      defineFunction({
        type: "enclose",
        names: ["\\fcolorbox"],
        props: {
          numArgs: 3,
          allowedInText: true,
          argTypes: ["color", "color", "text"]
        },
        handler(_ref2, args, optArgs) {
          var {
            parser: parser23,
            funcName
          } = _ref2;
          var borderColor = assertNodeType(args[0], "color-token").color;
          var backgroundColor = assertNodeType(args[1], "color-token").color;
          var body = args[2];
          return {
            type: "enclose",
            mode: parser23.mode,
            label: funcName,
            backgroundColor,
            borderColor,
            body
          };
        },
        htmlBuilder: htmlBuilder$7,
        mathmlBuilder: mathmlBuilder$6
      });
      defineFunction({
        type: "enclose",
        names: ["\\fbox"],
        props: {
          numArgs: 1,
          argTypes: ["hbox"],
          allowedInText: true
        },
        handler(_ref3, args) {
          var {
            parser: parser23
          } = _ref3;
          return {
            type: "enclose",
            mode: parser23.mode,
            label: "\\fbox",
            body: args[0]
          };
        }
      });
      defineFunction({
        type: "enclose",
        names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
        props: {
          numArgs: 1
        },
        handler(_ref4, args) {
          var {
            parser: parser23,
            funcName
          } = _ref4;
          var body = args[0];
          return {
            type: "enclose",
            mode: parser23.mode,
            label: funcName,
            body
          };
        },
        htmlBuilder: htmlBuilder$7,
        mathmlBuilder: mathmlBuilder$6
      });
      defineFunction({
        type: "enclose",
        names: ["\\angl"],
        props: {
          numArgs: 1,
          argTypes: ["hbox"],
          allowedInText: false
        },
        handler(_ref5, args) {
          var {
            parser: parser23
          } = _ref5;
          return {
            type: "enclose",
            mode: parser23.mode,
            label: "\\angl",
            body: args[0]
          };
        }
      });
      _environments = {};
      __name(defineEnvironment, "defineEnvironment");
      _macros = {};
      __name(defineMacro, "defineMacro");
      __name(getHLines, "getHLines");
      validateAmsEnvironmentContext = /* @__PURE__ */ __name((context) => {
        var settings = context.parser.settings;
        if (!settings.displayMode) {
          throw new ParseError("{" + context.envName + "} can be used only in display mode.");
        }
      }, "validateAmsEnvironmentContext");
      __name(getAutoTag, "getAutoTag");
      __name(parseArray, "parseArray");
      __name(dCellStyle, "dCellStyle");
      htmlBuilder$6 = /* @__PURE__ */ __name(function htmlBuilder(group2, options3) {
        var r2;
        var c3;
        var nr = group2.body.length;
        var hLinesBeforeRow = group2.hLinesBeforeRow;
        var nc = 0;
        var body = new Array(nr);
        var hlines = [];
        var ruleThickness = Math.max(
          // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
          options3.fontMetrics().arrayRuleWidth,
          options3.minRuleThickness
          // User override.
        );
        var pt = 1 / options3.fontMetrics().ptPerEm;
        var arraycolsep = 5 * pt;
        if (group2.colSeparationType && group2.colSeparationType === "small") {
          var localMultiplier = options3.havingStyle(Style$1.SCRIPT).sizeMultiplier;
          arraycolsep = 0.2778 * (localMultiplier / options3.sizeMultiplier);
        }
        var baselineskip = group2.colSeparationType === "CD" ? calculateSize2({
          number: 3,
          unit: "ex"
        }, options3) : 12 * pt;
        var jot = 3 * pt;
        var arrayskip = group2.arraystretch * baselineskip;
        var arstrutHeight = 0.7 * arrayskip;
        var arstrutDepth = 0.3 * arrayskip;
        var totalHeight = 0;
        function setHLinePos(hlinesInGap) {
          for (var i2 = 0; i2 < hlinesInGap.length; ++i2) {
            if (i2 > 0) {
              totalHeight += 0.25;
            }
            hlines.push({
              pos: totalHeight,
              isDashed: hlinesInGap[i2]
            });
          }
        }
        __name(setHLinePos, "setHLinePos");
        setHLinePos(hLinesBeforeRow[0]);
        for (r2 = 0; r2 < group2.body.length; ++r2) {
          var inrow = group2.body[r2];
          var height2 = arstrutHeight;
          var depth = arstrutDepth;
          if (nc < inrow.length) {
            nc = inrow.length;
          }
          var outrow = new Array(inrow.length);
          for (c3 = 0; c3 < inrow.length; ++c3) {
            var elt = buildGroup$1(inrow[c3], options3);
            if (depth < elt.depth) {
              depth = elt.depth;
            }
            if (height2 < elt.height) {
              height2 = elt.height;
            }
            outrow[c3] = elt;
          }
          var rowGap = group2.rowGaps[r2];
          var gap = 0;
          if (rowGap) {
            gap = calculateSize2(rowGap, options3);
            if (gap > 0) {
              gap += arstrutDepth;
              if (depth < gap) {
                depth = gap;
              }
              gap = 0;
            }
          }
          if (group2.addJot) {
            depth += jot;
          }
          outrow.height = height2;
          outrow.depth = depth;
          totalHeight += height2;
          outrow.pos = totalHeight;
          totalHeight += depth + gap;
          body[r2] = outrow;
          setHLinePos(hLinesBeforeRow[r2 + 1]);
        }
        var offset = totalHeight / 2 + options3.fontMetrics().axisHeight;
        var colDescriptions = group2.cols || [];
        var cols = [];
        var colSep;
        var colDescrNum;
        var tagSpans = [];
        if (group2.tags && group2.tags.some((tag3) => tag3)) {
          for (r2 = 0; r2 < nr; ++r2) {
            var rw = body[r2];
            var shift2 = rw.pos - offset;
            var tag2 = group2.tags[r2];
            var tagSpan = void 0;
            if (tag2 === true) {
              tagSpan = buildCommon.makeSpan(["eqn-num"], [], options3);
            } else if (tag2 === false) {
              tagSpan = buildCommon.makeSpan([], [], options3);
            } else {
              tagSpan = buildCommon.makeSpan([], buildExpression$1(tag2, options3, true), options3);
            }
            tagSpan.depth = rw.depth;
            tagSpan.height = rw.height;
            tagSpans.push({
              type: "elem",
              elem: tagSpan,
              shift: shift2
            });
          }
        }
        for (
          c3 = 0, colDescrNum = 0;
          // Continue while either there are more columns or more column
          // descriptions, so trailing separators don't get lost.
          c3 < nc || colDescrNum < colDescriptions.length;
          ++c3, ++colDescrNum
        ) {
          var colDescr = colDescriptions[colDescrNum] || {};
          var firstSeparator = true;
          while (colDescr.type === "separator") {
            if (!firstSeparator) {
              colSep = buildCommon.makeSpan(["arraycolsep"], []);
              colSep.style.width = makeEm(options3.fontMetrics().doubleRuleSep);
              cols.push(colSep);
            }
            if (colDescr.separator === "|" || colDescr.separator === ":") {
              var lineType3 = colDescr.separator === "|" ? "solid" : "dashed";
              var separator = buildCommon.makeSpan(["vertical-separator"], [], options3);
              separator.style.height = makeEm(totalHeight);
              separator.style.borderRightWidth = makeEm(ruleThickness);
              separator.style.borderRightStyle = lineType3;
              separator.style.margin = "0 " + makeEm(-ruleThickness / 2);
              var _shift = totalHeight - offset;
              if (_shift) {
                separator.style.verticalAlign = makeEm(-_shift);
              }
              cols.push(separator);
            } else {
              throw new ParseError("Invalid separator type: " + colDescr.separator);
            }
            colDescrNum++;
            colDescr = colDescriptions[colDescrNum] || {};
            firstSeparator = false;
          }
          if (c3 >= nc) {
            continue;
          }
          var sepwidth = void 0;
          if (c3 > 0 || group2.hskipBeforeAndAfter) {
            sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
            if (sepwidth !== 0) {
              colSep = buildCommon.makeSpan(["arraycolsep"], []);
              colSep.style.width = makeEm(sepwidth);
              cols.push(colSep);
            }
          }
          var col = [];
          for (r2 = 0; r2 < nr; ++r2) {
            var row = body[r2];
            var elem = row[c3];
            if (!elem) {
              continue;
            }
            var _shift2 = row.pos - offset;
            elem.depth = row.depth;
            elem.height = row.height;
            col.push({
              type: "elem",
              elem,
              shift: _shift2
            });
          }
          col = buildCommon.makeVList({
            positionType: "individualShift",
            children: col
          }, options3);
          col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
          cols.push(col);
          if (c3 < nc - 1 || group2.hskipBeforeAndAfter) {
            sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
            if (sepwidth !== 0) {
              colSep = buildCommon.makeSpan(["arraycolsep"], []);
              colSep.style.width = makeEm(sepwidth);
              cols.push(colSep);
            }
          }
        }
        body = buildCommon.makeSpan(["mtable"], cols);
        if (hlines.length > 0) {
          var line2 = buildCommon.makeLineSpan("hline", options3, ruleThickness);
          var dashes = buildCommon.makeLineSpan("hdashline", options3, ruleThickness);
          var vListElems = [{
            type: "elem",
            elem: body,
            shift: 0
          }];
          while (hlines.length > 0) {
            var hline = hlines.pop();
            var lineShift = hline.pos - offset;
            if (hline.isDashed) {
              vListElems.push({
                type: "elem",
                elem: dashes,
                shift: lineShift
              });
            } else {
              vListElems.push({
                type: "elem",
                elem: line2,
                shift: lineShift
              });
            }
          }
          body = buildCommon.makeVList({
            positionType: "individualShift",
            children: vListElems
          }, options3);
        }
        if (tagSpans.length === 0) {
          return buildCommon.makeSpan(["mord"], [body], options3);
        } else {
          var eqnNumCol = buildCommon.makeVList({
            positionType: "individualShift",
            children: tagSpans
          }, options3);
          eqnNumCol = buildCommon.makeSpan(["tag"], [eqnNumCol], options3);
          return buildCommon.makeFragment([body, eqnNumCol]);
        }
      }, "htmlBuilder");
      alignMap = {
        c: "center ",
        l: "left ",
        r: "right "
      };
      mathmlBuilder$5 = /* @__PURE__ */ __name(function mathmlBuilder(group2, options3) {
        var tbl = [];
        var glue = new mathMLTree.MathNode("mtd", [], ["mtr-glue"]);
        var tag2 = new mathMLTree.MathNode("mtd", [], ["mml-eqn-num"]);
        for (var i2 = 0; i2 < group2.body.length; i2++) {
          var rw = group2.body[i2];
          var row = [];
          for (var j2 = 0; j2 < rw.length; j2++) {
            row.push(new mathMLTree.MathNode("mtd", [buildGroup2(rw[j2], options3)]));
          }
          if (group2.tags && group2.tags[i2]) {
            row.unshift(glue);
            row.push(glue);
            if (group2.leqno) {
              row.unshift(tag2);
            } else {
              row.push(tag2);
            }
          }
          tbl.push(new mathMLTree.MathNode("mtr", row));
        }
        var table = new mathMLTree.MathNode("mtable", tbl);
        var gap = group2.arraystretch === 0.5 ? 0.1 : 0.16 + group2.arraystretch - 1 + (group2.addJot ? 0.09 : 0);
        table.setAttribute("rowspacing", makeEm(gap));
        var menclose = "";
        var align = "";
        if (group2.cols && group2.cols.length > 0) {
          var cols = group2.cols;
          var columnLines = "";
          var prevTypeWasAlign = false;
          var iStart = 0;
          var iEnd = cols.length;
          if (cols[0].type === "separator") {
            menclose += "top ";
            iStart = 1;
          }
          if (cols[cols.length - 1].type === "separator") {
            menclose += "bottom ";
            iEnd -= 1;
          }
          for (var _i = iStart; _i < iEnd; _i++) {
            if (cols[_i].type === "align") {
              align += alignMap[cols[_i].align];
              if (prevTypeWasAlign) {
                columnLines += "none ";
              }
              prevTypeWasAlign = true;
            } else if (cols[_i].type === "separator") {
              if (prevTypeWasAlign) {
                columnLines += cols[_i].separator === "|" ? "solid " : "dashed ";
                prevTypeWasAlign = false;
              }
            }
          }
          table.setAttribute("columnalign", align.trim());
          if (/[sd]/.test(columnLines)) {
            table.setAttribute("columnlines", columnLines.trim());
          }
        }
        if (group2.colSeparationType === "align") {
          var _cols = group2.cols || [];
          var spacing2 = "";
          for (var _i2 = 1; _i2 < _cols.length; _i2++) {
            spacing2 += _i2 % 2 ? "0em " : "1em ";
          }
          table.setAttribute("columnspacing", spacing2.trim());
        } else if (group2.colSeparationType === "alignat" || group2.colSeparationType === "gather") {
          table.setAttribute("columnspacing", "0em");
        } else if (group2.colSeparationType === "small") {
          table.setAttribute("columnspacing", "0.2778em");
        } else if (group2.colSeparationType === "CD") {
          table.setAttribute("columnspacing", "0.5em");
        } else {
          table.setAttribute("columnspacing", "1em");
        }
        var rowLines = "";
        var hlines = group2.hLinesBeforeRow;
        menclose += hlines[0].length > 0 ? "left " : "";
        menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";
        for (var _i3 = 1; _i3 < hlines.length - 1; _i3++) {
          rowLines += hlines[_i3].length === 0 ? "none " : hlines[_i3][0] ? "dashed " : "solid ";
        }
        if (/[sd]/.test(rowLines)) {
          table.setAttribute("rowlines", rowLines.trim());
        }
        if (menclose !== "") {
          table = new mathMLTree.MathNode("menclose", [table]);
          table.setAttribute("notation", menclose.trim());
        }
        if (group2.arraystretch && group2.arraystretch < 1) {
          table = new mathMLTree.MathNode("mstyle", [table]);
          table.setAttribute("scriptlevel", "1");
        }
        return table;
      }, "mathmlBuilder");
      alignedHandler = /* @__PURE__ */ __name(function alignedHandler2(context, args) {
        if (context.envName.indexOf("ed") === -1) {
          validateAmsEnvironmentContext(context);
        }
        var cols = [];
        var separationType = context.envName.indexOf("at") > -1 ? "alignat" : "align";
        var isSplit = context.envName === "split";
        var res = parseArray(context.parser, {
          cols,
          addJot: true,
          autoTag: isSplit ? void 0 : getAutoTag(context.envName),
          emptySingleRow: true,
          colSeparationType: separationType,
          maxNumCols: isSplit ? 2 : void 0,
          leqno: context.parser.settings.leqno
        }, "display");
        var numMaths;
        var numCols = 0;
        var emptyGroup = {
          type: "ordgroup",
          mode: context.mode,
          body: []
        };
        if (args[0] && args[0].type === "ordgroup") {
          var arg0 = "";
          for (var i2 = 0; i2 < args[0].body.length; i2++) {
            var textord2 = assertNodeType(args[0].body[i2], "textord");
            arg0 += textord2.text;
          }
          numMaths = Number(arg0);
          numCols = numMaths * 2;
        }
        var isAligned = !numCols;
        res.body.forEach(function(row) {
          for (var _i4 = 1; _i4 < row.length; _i4 += 2) {
            var styling = assertNodeType(row[_i4], "styling");
            var ordgroup = assertNodeType(styling.body[0], "ordgroup");
            ordgroup.body.unshift(emptyGroup);
          }
          if (!isAligned) {
            var curMaths = row.length / 2;
            if (numMaths < curMaths) {
              throw new ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
            }
          } else if (numCols < row.length) {
            numCols = row.length;
          }
        });
        for (var _i5 = 0; _i5 < numCols; ++_i5) {
          var align = "r";
          var pregap = 0;
          if (_i5 % 2 === 1) {
            align = "l";
          } else if (_i5 > 0 && isAligned) {
            pregap = 1;
          }
          cols[_i5] = {
            type: "align",
            align,
            pregap,
            postgap: 0
          };
        }
        res.colSeparationType = isAligned ? "align" : "alignat";
        return res;
      }, "alignedHandler");
      defineEnvironment({
        type: "array",
        names: ["array", "darray"],
        props: {
          numArgs: 1
        },
        handler(context, args) {
          var symNode = checkSymbolNodeType(args[0]);
          var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
          var cols = colalign.map(function(nde) {
            var node2 = assertSymbolNodeType(nde);
            var ca = node2.text;
            if ("lcr".indexOf(ca) !== -1) {
              return {
                type: "align",
                align: ca
              };
            } else if (ca === "|") {
              return {
                type: "separator",
                separator: "|"
              };
            } else if (ca === ":") {
              return {
                type: "separator",
                separator: ":"
              };
            }
            throw new ParseError("Unknown column alignment: " + ca, nde);
          });
          var res = {
            cols,
            hskipBeforeAndAfter: true,
            // \@preamble in lttab.dtx
            maxNumCols: cols.length
          };
          return parseArray(context.parser, res, dCellStyle(context.envName));
        },
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineEnvironment({
        type: "array",
        names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
        props: {
          numArgs: 0
        },
        handler(context) {
          var delimiters2 = {
            "matrix": null,
            "pmatrix": ["(", ")"],
            "bmatrix": ["[", "]"],
            "Bmatrix": ["\\{", "\\}"],
            "vmatrix": ["|", "|"],
            "Vmatrix": ["\\Vert", "\\Vert"]
          }[context.envName.replace("*", "")];
          var colAlign = "c";
          var payload = {
            hskipBeforeAndAfter: false,
            cols: [{
              type: "align",
              align: colAlign
            }]
          };
          if (context.envName.charAt(context.envName.length - 1) === "*") {
            var parser23 = context.parser;
            parser23.consumeSpaces();
            if (parser23.fetch().text === "[") {
              parser23.consume();
              parser23.consumeSpaces();
              colAlign = parser23.fetch().text;
              if ("lcr".indexOf(colAlign) === -1) {
                throw new ParseError("Expected l or c or r", parser23.nextToken);
              }
              parser23.consume();
              parser23.consumeSpaces();
              parser23.expect("]");
              parser23.consume();
              payload.cols = [{
                type: "align",
                align: colAlign
              }];
            }
          }
          var res = parseArray(context.parser, payload, dCellStyle(context.envName));
          var numCols = Math.max(0, ...res.body.map((row) => row.length));
          res.cols = new Array(numCols).fill({
            type: "align",
            align: colAlign
          });
          return delimiters2 ? {
            type: "leftright",
            mode: context.mode,
            body: [res],
            left: delimiters2[0],
            right: delimiters2[1],
            rightColor: void 0
            // \right uninfluenced by \color in array
          } : res;
        },
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineEnvironment({
        type: "array",
        names: ["smallmatrix"],
        props: {
          numArgs: 0
        },
        handler(context) {
          var payload = {
            arraystretch: 0.5
          };
          var res = parseArray(context.parser, payload, "script");
          res.colSeparationType = "small";
          return res;
        },
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineEnvironment({
        type: "array",
        names: ["subarray"],
        props: {
          numArgs: 1
        },
        handler(context, args) {
          var symNode = checkSymbolNodeType(args[0]);
          var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
          var cols = colalign.map(function(nde) {
            var node2 = assertSymbolNodeType(nde);
            var ca = node2.text;
            if ("lc".indexOf(ca) !== -1) {
              return {
                type: "align",
                align: ca
              };
            }
            throw new ParseError("Unknown column alignment: " + ca, nde);
          });
          if (cols.length > 1) {
            throw new ParseError("{subarray} can contain only one column");
          }
          var res = {
            cols,
            hskipBeforeAndAfter: false,
            arraystretch: 0.5
          };
          res = parseArray(context.parser, res, "script");
          if (res.body.length > 0 && res.body[0].length > 1) {
            throw new ParseError("{subarray} can contain only one column");
          }
          return res;
        },
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineEnvironment({
        type: "array",
        names: ["cases", "dcases", "rcases", "drcases"],
        props: {
          numArgs: 0
        },
        handler(context) {
          var payload = {
            arraystretch: 1.2,
            cols: [{
              type: "align",
              align: "l",
              pregap: 0,
              // TODO(kevinb) get the current style.
              // For now we use the metrics for TEXT style which is what we were
              // doing before.  Before attempting to get the current style we
              // should look at TeX's behavior especially for \over and matrices.
              postgap: 1
              /* 1em quad */
            }, {
              type: "align",
              align: "l",
              pregap: 0,
              postgap: 0
            }]
          };
          var res = parseArray(context.parser, payload, dCellStyle(context.envName));
          return {
            type: "leftright",
            mode: context.mode,
            body: [res],
            left: context.envName.indexOf("r") > -1 ? "." : "\\{",
            right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
            rightColor: void 0
          };
        },
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineEnvironment({
        type: "array",
        names: ["align", "align*", "aligned", "split"],
        props: {
          numArgs: 0
        },
        handler: alignedHandler,
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineEnvironment({
        type: "array",
        names: ["gathered", "gather", "gather*"],
        props: {
          numArgs: 0
        },
        handler(context) {
          if (utils.contains(["gather", "gather*"], context.envName)) {
            validateAmsEnvironmentContext(context);
          }
          var res = {
            cols: [{
              type: "align",
              align: "c"
            }],
            addJot: true,
            colSeparationType: "gather",
            autoTag: getAutoTag(context.envName),
            emptySingleRow: true,
            leqno: context.parser.settings.leqno
          };
          return parseArray(context.parser, res, "display");
        },
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineEnvironment({
        type: "array",
        names: ["alignat", "alignat*", "alignedat"],
        props: {
          numArgs: 1
        },
        handler: alignedHandler,
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineEnvironment({
        type: "array",
        names: ["equation", "equation*"],
        props: {
          numArgs: 0
        },
        handler(context) {
          validateAmsEnvironmentContext(context);
          var res = {
            autoTag: getAutoTag(context.envName),
            emptySingleRow: true,
            singleRow: true,
            maxNumCols: 1,
            leqno: context.parser.settings.leqno
          };
          return parseArray(context.parser, res, "display");
        },
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineEnvironment({
        type: "array",
        names: ["CD"],
        props: {
          numArgs: 0
        },
        handler(context) {
          validateAmsEnvironmentContext(context);
          return parseCD(context.parser);
        },
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineMacro("\\nonumber", "\\gdef\\@eqnsw{0}");
      defineMacro("\\notag", "\\nonumber");
      defineFunction({
        type: "text",
        // Doesn't matter what this is.
        names: ["\\hline", "\\hdashline"],
        props: {
          numArgs: 0,
          allowedInText: true,
          allowedInMath: true
        },
        handler(context, args) {
          throw new ParseError(context.funcName + " valid only within array environment");
        }
      });
      environments = _environments;
      defineFunction({
        type: "environment",
        names: ["\\begin", "\\end"],
        props: {
          numArgs: 1,
          argTypes: ["text"]
        },
        handler(_ref, args) {
          var {
            parser: parser23,
            funcName
          } = _ref;
          var nameGroup = args[0];
          if (nameGroup.type !== "ordgroup") {
            throw new ParseError("Invalid environment name", nameGroup);
          }
          var envName = "";
          for (var i2 = 0; i2 < nameGroup.body.length; ++i2) {
            envName += assertNodeType(nameGroup.body[i2], "textord").text;
          }
          if (funcName === "\\begin") {
            if (!environments.hasOwnProperty(envName)) {
              throw new ParseError("No such environment: " + envName, nameGroup);
            }
            var env = environments[envName];
            var {
              args: _args,
              optArgs
            } = parser23.parseArguments("\\begin{" + envName + "}", env);
            var context = {
              mode: parser23.mode,
              envName,
              parser: parser23
            };
            var result = env.handler(context, _args, optArgs);
            parser23.expect("\\end", false);
            var endNameToken = parser23.nextToken;
            var end2 = assertNodeType(parser23.parseFunction(), "environment");
            if (end2.name !== envName) {
              throw new ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end2.name + "}", endNameToken);
            }
            return result;
          }
          return {
            type: "environment",
            mode: parser23.mode,
            name: envName,
            nameGroup
          };
        }
      });
      htmlBuilder$5 = /* @__PURE__ */ __name((group2, options3) => {
        var font = group2.font;
        var newOptions = options3.withFont(font);
        return buildGroup$1(group2.body, newOptions);
      }, "htmlBuilder$5");
      mathmlBuilder$4 = /* @__PURE__ */ __name((group2, options3) => {
        var font = group2.font;
        var newOptions = options3.withFont(font);
        return buildGroup2(group2.body, newOptions);
      }, "mathmlBuilder$4");
      fontAliases = {
        "\\Bbb": "\\mathbb",
        "\\bold": "\\mathbf",
        "\\frak": "\\mathfrak",
        "\\bm": "\\boldsymbol"
      };
      defineFunction({
        type: "font",
        names: [
          // styles, except \boldsymbol defined below
          "\\mathrm",
          "\\mathit",
          "\\mathbf",
          "\\mathnormal",
          // families
          "\\mathbb",
          "\\mathcal",
          "\\mathfrak",
          "\\mathscr",
          "\\mathsf",
          "\\mathtt",
          // aliases, except \bm defined below
          "\\Bbb",
          "\\bold",
          "\\frak"
        ],
        props: {
          numArgs: 1,
          allowedInArgument: true
        },
        handler: /* @__PURE__ */ __name((_ref, args) => {
          var {
            parser: parser23,
            funcName
          } = _ref;
          var body = normalizeArgument(args[0]);
          var func = funcName;
          if (func in fontAliases) {
            func = fontAliases[func];
          }
          return {
            type: "font",
            mode: parser23.mode,
            font: func.slice(1),
            body
          };
        }, "handler"),
        htmlBuilder: htmlBuilder$5,
        mathmlBuilder: mathmlBuilder$4
      });
      defineFunction({
        type: "mclass",
        names: ["\\boldsymbol", "\\bm"],
        props: {
          numArgs: 1
        },
        handler: /* @__PURE__ */ __name((_ref2, args) => {
          var {
            parser: parser23
          } = _ref2;
          var body = args[0];
          var isCharacterBox3 = utils.isCharacterBox(body);
          return {
            type: "mclass",
            mode: parser23.mode,
            mclass: binrelClass(body),
            body: [{
              type: "font",
              mode: parser23.mode,
              font: "boldsymbol",
              body
            }],
            isCharacterBox: isCharacterBox3
          };
        }, "handler")
      });
      defineFunction({
        type: "font",
        names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler: /* @__PURE__ */ __name((_ref3, args) => {
          var {
            parser: parser23,
            funcName,
            breakOnTokenText
          } = _ref3;
          var {
            mode
          } = parser23;
          var body = parser23.parseExpression(true, breakOnTokenText);
          var style3 = "math" + funcName.slice(1);
          return {
            type: "font",
            mode,
            font: style3,
            body: {
              type: "ordgroup",
              mode: parser23.mode,
              body
            }
          };
        }, "handler"),
        htmlBuilder: htmlBuilder$5,
        mathmlBuilder: mathmlBuilder$4
      });
      adjustStyle = /* @__PURE__ */ __name((size5, originalStyle) => {
        var style3 = originalStyle;
        if (size5 === "display") {
          style3 = style3.id >= Style$1.SCRIPT.id ? style3.text() : Style$1.DISPLAY;
        } else if (size5 === "text" && style3.size === Style$1.DISPLAY.size) {
          style3 = Style$1.TEXT;
        } else if (size5 === "script") {
          style3 = Style$1.SCRIPT;
        } else if (size5 === "scriptscript") {
          style3 = Style$1.SCRIPTSCRIPT;
        }
        return style3;
      }, "adjustStyle");
      htmlBuilder$4 = /* @__PURE__ */ __name((group2, options3) => {
        var style3 = adjustStyle(group2.size, options3.style);
        var nstyle = style3.fracNum();
        var dstyle = style3.fracDen();
        var newOptions;
        newOptions = options3.havingStyle(nstyle);
        var numerm = buildGroup$1(group2.numer, newOptions, options3);
        if (group2.continued) {
          var hStrut = 8.5 / options3.fontMetrics().ptPerEm;
          var dStrut = 3.5 / options3.fontMetrics().ptPerEm;
          numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
          numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
        }
        newOptions = options3.havingStyle(dstyle);
        var denomm = buildGroup$1(group2.denom, newOptions, options3);
        var rule;
        var ruleWidth;
        var ruleSpacing;
        if (group2.hasBarLine) {
          if (group2.barSize) {
            ruleWidth = calculateSize2(group2.barSize, options3);
            rule = buildCommon.makeLineSpan("frac-line", options3, ruleWidth);
          } else {
            rule = buildCommon.makeLineSpan("frac-line", options3);
          }
          ruleWidth = rule.height;
          ruleSpacing = rule.height;
        } else {
          rule = null;
          ruleWidth = 0;
          ruleSpacing = options3.fontMetrics().defaultRuleThickness;
        }
        var numShift;
        var clearance;
        var denomShift;
        if (style3.size === Style$1.DISPLAY.size || group2.size === "display") {
          numShift = options3.fontMetrics().num1;
          if (ruleWidth > 0) {
            clearance = 3 * ruleSpacing;
          } else {
            clearance = 7 * ruleSpacing;
          }
          denomShift = options3.fontMetrics().denom1;
        } else {
          if (ruleWidth > 0) {
            numShift = options3.fontMetrics().num2;
            clearance = ruleSpacing;
          } else {
            numShift = options3.fontMetrics().num3;
            clearance = 3 * ruleSpacing;
          }
          denomShift = options3.fontMetrics().denom2;
        }
        var frac;
        if (!rule) {
          var candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);
          if (candidateClearance < clearance) {
            numShift += 0.5 * (clearance - candidateClearance);
            denomShift += 0.5 * (clearance - candidateClearance);
          }
          frac = buildCommon.makeVList({
            positionType: "individualShift",
            children: [{
              type: "elem",
              elem: denomm,
              shift: denomShift
            }, {
              type: "elem",
              elem: numerm,
              shift: -numShift
            }]
          }, options3);
        } else {
          var axisHeight = options3.fontMetrics().axisHeight;
          if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
            numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
          }
          if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
            denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
          }
          var midShift = -(axisHeight - 0.5 * ruleWidth);
          frac = buildCommon.makeVList({
            positionType: "individualShift",
            children: [{
              type: "elem",
              elem: denomm,
              shift: denomShift
            }, {
              type: "elem",
              elem: rule,
              shift: midShift
            }, {
              type: "elem",
              elem: numerm,
              shift: -numShift
            }]
          }, options3);
        }
        newOptions = options3.havingStyle(style3);
        frac.height *= newOptions.sizeMultiplier / options3.sizeMultiplier;
        frac.depth *= newOptions.sizeMultiplier / options3.sizeMultiplier;
        var delimSize;
        if (style3.size === Style$1.DISPLAY.size) {
          delimSize = options3.fontMetrics().delim1;
        } else if (style3.size === Style$1.SCRIPTSCRIPT.size) {
          delimSize = options3.havingStyle(Style$1.SCRIPT).fontMetrics().delim2;
        } else {
          delimSize = options3.fontMetrics().delim2;
        }
        var leftDelim;
        var rightDelim;
        if (group2.leftDelim == null) {
          leftDelim = makeNullDelimiter(options3, ["mopen"]);
        } else {
          leftDelim = delimiter.customSizedDelim(group2.leftDelim, delimSize, true, options3.havingStyle(style3), group2.mode, ["mopen"]);
        }
        if (group2.continued) {
          rightDelim = buildCommon.makeSpan([]);
        } else if (group2.rightDelim == null) {
          rightDelim = makeNullDelimiter(options3, ["mclose"]);
        } else {
          rightDelim = delimiter.customSizedDelim(group2.rightDelim, delimSize, true, options3.havingStyle(style3), group2.mode, ["mclose"]);
        }
        return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options3)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options3);
      }, "htmlBuilder$4");
      mathmlBuilder$3 = /* @__PURE__ */ __name((group2, options3) => {
        var node2 = new mathMLTree.MathNode("mfrac", [buildGroup2(group2.numer, options3), buildGroup2(group2.denom, options3)]);
        if (!group2.hasBarLine) {
          node2.setAttribute("linethickness", "0px");
        } else if (group2.barSize) {
          var ruleWidth = calculateSize2(group2.barSize, options3);
          node2.setAttribute("linethickness", makeEm(ruleWidth));
        }
        var style3 = adjustStyle(group2.size, options3.style);
        if (style3.size !== options3.style.size) {
          node2 = new mathMLTree.MathNode("mstyle", [node2]);
          var isDisplay = style3.size === Style$1.DISPLAY.size ? "true" : "false";
          node2.setAttribute("displaystyle", isDisplay);
          node2.setAttribute("scriptlevel", "0");
        }
        if (group2.leftDelim != null || group2.rightDelim != null) {
          var withDelims = [];
          if (group2.leftDelim != null) {
            var leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group2.leftDelim.replace("\\", ""))]);
            leftOp.setAttribute("fence", "true");
            withDelims.push(leftOp);
          }
          withDelims.push(node2);
          if (group2.rightDelim != null) {
            var rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group2.rightDelim.replace("\\", ""))]);
            rightOp.setAttribute("fence", "true");
            withDelims.push(rightOp);
          }
          return makeRow(withDelims);
        }
        return node2;
      }, "mathmlBuilder$3");
      defineFunction({
        type: "genfrac",
        names: [
          "\\dfrac",
          "\\frac",
          "\\tfrac",
          "\\dbinom",
          "\\binom",
          "\\tbinom",
          "\\\\atopfrac",
          // can’t be entered directly
          "\\\\bracefrac",
          "\\\\brackfrac"
          // ditto
        ],
        props: {
          numArgs: 2,
          allowedInArgument: true
        },
        handler: /* @__PURE__ */ __name((_ref, args) => {
          var {
            parser: parser23,
            funcName
          } = _ref;
          var numer = args[0];
          var denom = args[1];
          var hasBarLine;
          var leftDelim = null;
          var rightDelim = null;
          var size5 = "auto";
          switch (funcName) {
            case "\\dfrac":
            case "\\frac":
            case "\\tfrac":
              hasBarLine = true;
              break;
            case "\\\\atopfrac":
              hasBarLine = false;
              break;
            case "\\dbinom":
            case "\\binom":
            case "\\tbinom":
              hasBarLine = false;
              leftDelim = "(";
              rightDelim = ")";
              break;
            case "\\\\bracefrac":
              hasBarLine = false;
              leftDelim = "\\{";
              rightDelim = "\\}";
              break;
            case "\\\\brackfrac":
              hasBarLine = false;
              leftDelim = "[";
              rightDelim = "]";
              break;
            default:
              throw new Error("Unrecognized genfrac command");
          }
          switch (funcName) {
            case "\\dfrac":
            case "\\dbinom":
              size5 = "display";
              break;
            case "\\tfrac":
            case "\\tbinom":
              size5 = "text";
              break;
          }
          return {
            type: "genfrac",
            mode: parser23.mode,
            continued: false,
            numer,
            denom,
            hasBarLine,
            leftDelim,
            rightDelim,
            size: size5,
            barSize: null
          };
        }, "handler"),
        htmlBuilder: htmlBuilder$4,
        mathmlBuilder: mathmlBuilder$3
      });
      defineFunction({
        type: "genfrac",
        names: ["\\cfrac"],
        props: {
          numArgs: 2
        },
        handler: /* @__PURE__ */ __name((_ref2, args) => {
          var {
            parser: parser23,
            funcName
          } = _ref2;
          var numer = args[0];
          var denom = args[1];
          return {
            type: "genfrac",
            mode: parser23.mode,
            continued: true,
            numer,
            denom,
            hasBarLine: true,
            leftDelim: null,
            rightDelim: null,
            size: "display",
            barSize: null
          };
        }, "handler")
      });
      defineFunction({
        type: "infix",
        names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
        props: {
          numArgs: 0,
          infix: true
        },
        handler(_ref3) {
          var {
            parser: parser23,
            funcName,
            token: token2
          } = _ref3;
          var replaceWith;
          switch (funcName) {
            case "\\over":
              replaceWith = "\\frac";
              break;
            case "\\choose":
              replaceWith = "\\binom";
              break;
            case "\\atop":
              replaceWith = "\\\\atopfrac";
              break;
            case "\\brace":
              replaceWith = "\\\\bracefrac";
              break;
            case "\\brack":
              replaceWith = "\\\\brackfrac";
              break;
            default:
              throw new Error("Unrecognized infix genfrac command");
          }
          return {
            type: "infix",
            mode: parser23.mode,
            replaceWith,
            token: token2
          };
        }
      });
      stylArray = ["display", "text", "script", "scriptscript"];
      delimFromValue = /* @__PURE__ */ __name(function delimFromValue2(delimString) {
        var delim = null;
        if (delimString.length > 0) {
          delim = delimString;
          delim = delim === "." ? null : delim;
        }
        return delim;
      }, "delimFromValue");
      defineFunction({
        type: "genfrac",
        names: ["\\genfrac"],
        props: {
          numArgs: 6,
          allowedInArgument: true,
          argTypes: ["math", "math", "size", "text", "math", "math"]
        },
        handler(_ref4, args) {
          var {
            parser: parser23
          } = _ref4;
          var numer = args[4];
          var denom = args[5];
          var leftNode = normalizeArgument(args[0]);
          var leftDelim = leftNode.type === "atom" && leftNode.family === "open" ? delimFromValue(leftNode.text) : null;
          var rightNode = normalizeArgument(args[1]);
          var rightDelim = rightNode.type === "atom" && rightNode.family === "close" ? delimFromValue(rightNode.text) : null;
          var barNode = assertNodeType(args[2], "size");
          var hasBarLine;
          var barSize = null;
          if (barNode.isBlank) {
            hasBarLine = true;
          } else {
            barSize = barNode.value;
            hasBarLine = barSize.number > 0;
          }
          var size5 = "auto";
          var styl = args[3];
          if (styl.type === "ordgroup") {
            if (styl.body.length > 0) {
              var textOrd = assertNodeType(styl.body[0], "textord");
              size5 = stylArray[Number(textOrd.text)];
            }
          } else {
            styl = assertNodeType(styl, "textord");
            size5 = stylArray[Number(styl.text)];
          }
          return {
            type: "genfrac",
            mode: parser23.mode,
            numer,
            denom,
            continued: false,
            hasBarLine,
            barSize,
            leftDelim,
            rightDelim,
            size: size5
          };
        },
        htmlBuilder: htmlBuilder$4,
        mathmlBuilder: mathmlBuilder$3
      });
      defineFunction({
        type: "infix",
        names: ["\\above"],
        props: {
          numArgs: 1,
          argTypes: ["size"],
          infix: true
        },
        handler(_ref5, args) {
          var {
            parser: parser23,
            funcName,
            token: token2
          } = _ref5;
          return {
            type: "infix",
            mode: parser23.mode,
            replaceWith: "\\\\abovefrac",
            size: assertNodeType(args[0], "size").value,
            token: token2
          };
        }
      });
      defineFunction({
        type: "genfrac",
        names: ["\\\\abovefrac"],
        props: {
          numArgs: 3,
          argTypes: ["math", "size", "math"]
        },
        handler: /* @__PURE__ */ __name((_ref6, args) => {
          var {
            parser: parser23,
            funcName
          } = _ref6;
          var numer = args[0];
          var barSize = assert(assertNodeType(args[1], "infix").size);
          var denom = args[2];
          var hasBarLine = barSize.number > 0;
          return {
            type: "genfrac",
            mode: parser23.mode,
            numer,
            denom,
            continued: false,
            hasBarLine,
            barSize,
            leftDelim: null,
            rightDelim: null,
            size: "auto"
          };
        }, "handler"),
        htmlBuilder: htmlBuilder$4,
        mathmlBuilder: mathmlBuilder$3
      });
      htmlBuilder$3 = /* @__PURE__ */ __name((grp, options3) => {
        var style3 = options3.style;
        var supSubGroup;
        var group2;
        if (grp.type === "supsub") {
          supSubGroup = grp.sup ? buildGroup$1(grp.sup, options3.havingStyle(style3.sup()), options3) : buildGroup$1(grp.sub, options3.havingStyle(style3.sub()), options3);
          group2 = assertNodeType(grp.base, "horizBrace");
        } else {
          group2 = assertNodeType(grp, "horizBrace");
        }
        var body = buildGroup$1(group2.base, options3.havingBaseStyle(Style$1.DISPLAY));
        var braceBody = stretchy.svgSpan(group2, options3);
        var vlist;
        if (group2.isOver) {
          vlist = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: body
            }, {
              type: "kern",
              size: 0.1
            }, {
              type: "elem",
              elem: braceBody
            }]
          }, options3);
          vlist.children[0].children[0].children[1].classes.push("svg-align");
        } else {
          vlist = buildCommon.makeVList({
            positionType: "bottom",
            positionData: body.depth + 0.1 + braceBody.height,
            children: [{
              type: "elem",
              elem: braceBody
            }, {
              type: "kern",
              size: 0.1
            }, {
              type: "elem",
              elem: body
            }]
          }, options3);
          vlist.children[0].children[0].children[0].classes.push("svg-align");
        }
        if (supSubGroup) {
          var vSpan = buildCommon.makeSpan(["mord", group2.isOver ? "mover" : "munder"], [vlist], options3);
          if (group2.isOver) {
            vlist = buildCommon.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: vSpan
              }, {
                type: "kern",
                size: 0.2
              }, {
                type: "elem",
                elem: supSubGroup
              }]
            }, options3);
          } else {
            vlist = buildCommon.makeVList({
              positionType: "bottom",
              positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
              children: [{
                type: "elem",
                elem: supSubGroup
              }, {
                type: "kern",
                size: 0.2
              }, {
                type: "elem",
                elem: vSpan
              }]
            }, options3);
          }
        }
        return buildCommon.makeSpan(["mord", group2.isOver ? "mover" : "munder"], [vlist], options3);
      }, "htmlBuilder$3");
      mathmlBuilder$2 = /* @__PURE__ */ __name((group2, options3) => {
        var accentNode = stretchy.mathMLnode(group2.label);
        return new mathMLTree.MathNode(group2.isOver ? "mover" : "munder", [buildGroup2(group2.base, options3), accentNode]);
      }, "mathmlBuilder$2");
      defineFunction({
        type: "horizBrace",
        names: ["\\overbrace", "\\underbrace"],
        props: {
          numArgs: 1
        },
        handler(_ref, args) {
          var {
            parser: parser23,
            funcName
          } = _ref;
          return {
            type: "horizBrace",
            mode: parser23.mode,
            label: funcName,
            isOver: /^\\over/.test(funcName),
            base: args[0]
          };
        },
        htmlBuilder: htmlBuilder$3,
        mathmlBuilder: mathmlBuilder$2
      });
      defineFunction({
        type: "href",
        names: ["\\href"],
        props: {
          numArgs: 2,
          argTypes: ["url", "original"],
          allowedInText: true
        },
        handler: /* @__PURE__ */ __name((_ref, args) => {
          var {
            parser: parser23
          } = _ref;
          var body = args[1];
          var href = assertNodeType(args[0], "url").url;
          if (!parser23.settings.isTrusted({
            command: "\\href",
            url: href
          })) {
            return parser23.formatUnsupportedCmd("\\href");
          }
          return {
            type: "href",
            mode: parser23.mode,
            href,
            body: ordargument(body)
          };
        }, "handler"),
        htmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          var elements4 = buildExpression$1(group2.body, options3, false);
          return buildCommon.makeAnchor(group2.href, [], elements4, options3);
        }, "htmlBuilder"),
        mathmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          var math2 = buildExpressionRow(group2.body, options3);
          if (!(math2 instanceof MathNode)) {
            math2 = new MathNode("mrow", [math2]);
          }
          math2.setAttribute("href", group2.href);
          return math2;
        }, "mathmlBuilder")
      });
      defineFunction({
        type: "href",
        names: ["\\url"],
        props: {
          numArgs: 1,
          argTypes: ["url"],
          allowedInText: true
        },
        handler: /* @__PURE__ */ __name((_ref2, args) => {
          var {
            parser: parser23
          } = _ref2;
          var href = assertNodeType(args[0], "url").url;
          if (!parser23.settings.isTrusted({
            command: "\\url",
            url: href
          })) {
            return parser23.formatUnsupportedCmd("\\url");
          }
          var chars = [];
          for (var i2 = 0; i2 < href.length; i2++) {
            var c3 = href[i2];
            if (c3 === "~") {
              c3 = "\\textasciitilde";
            }
            chars.push({
              type: "textord",
              mode: "text",
              text: c3
            });
          }
          var body = {
            type: "text",
            mode: parser23.mode,
            font: "\\texttt",
            body: chars
          };
          return {
            type: "href",
            mode: parser23.mode,
            href,
            body: ordargument(body)
          };
        }, "handler")
      });
      defineFunction({
        type: "hbox",
        names: ["\\hbox"],
        props: {
          numArgs: 1,
          argTypes: ["text"],
          allowedInText: true,
          primitive: true
        },
        handler(_ref, args) {
          var {
            parser: parser23
          } = _ref;
          return {
            type: "hbox",
            mode: parser23.mode,
            body: ordargument(args[0])
          };
        },
        htmlBuilder(group2, options3) {
          var elements4 = buildExpression$1(group2.body, options3, false);
          return buildCommon.makeFragment(elements4);
        },
        mathmlBuilder(group2, options3) {
          return new mathMLTree.MathNode("mrow", buildExpression2(group2.body, options3));
        }
      });
      defineFunction({
        type: "html",
        names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
        props: {
          numArgs: 2,
          argTypes: ["raw", "original"],
          allowedInText: true
        },
        handler: /* @__PURE__ */ __name((_ref, args) => {
          var {
            parser: parser23,
            funcName,
            token: token2
          } = _ref;
          var value2 = assertNodeType(args[0], "raw").string;
          var body = args[1];
          if (parser23.settings.strict) {
            parser23.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
          }
          var trustContext;
          var attributes = {};
          switch (funcName) {
            case "\\htmlClass":
              attributes.class = value2;
              trustContext = {
                command: "\\htmlClass",
                class: value2
              };
              break;
            case "\\htmlId":
              attributes.id = value2;
              trustContext = {
                command: "\\htmlId",
                id: value2
              };
              break;
            case "\\htmlStyle":
              attributes.style = value2;
              trustContext = {
                command: "\\htmlStyle",
                style: value2
              };
              break;
            case "\\htmlData": {
              var data5 = value2.split(",");
              for (var i2 = 0; i2 < data5.length; i2++) {
                var keyVal = data5[i2].split("=");
                if (keyVal.length !== 2) {
                  throw new ParseError("Error parsing key-value for \\htmlData");
                }
                attributes["data-" + keyVal[0].trim()] = keyVal[1].trim();
              }
              trustContext = {
                command: "\\htmlData",
                attributes
              };
              break;
            }
            default:
              throw new Error("Unrecognized html command");
          }
          if (!parser23.settings.isTrusted(trustContext)) {
            return parser23.formatUnsupportedCmd(funcName);
          }
          return {
            type: "html",
            mode: parser23.mode,
            attributes,
            body: ordargument(body)
          };
        }, "handler"),
        htmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          var elements4 = buildExpression$1(group2.body, options3, false);
          var classes6 = ["enclosing"];
          if (group2.attributes.class) {
            classes6.push(...group2.attributes.class.trim().split(/\s+/));
          }
          var span = buildCommon.makeSpan(classes6, elements4, options3);
          for (var attr in group2.attributes) {
            if (attr !== "class" && group2.attributes.hasOwnProperty(attr)) {
              span.setAttribute(attr, group2.attributes[attr]);
            }
          }
          return span;
        }, "htmlBuilder"),
        mathmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          return buildExpressionRow(group2.body, options3);
        }, "mathmlBuilder")
      });
      defineFunction({
        type: "htmlmathml",
        names: ["\\html@mathml"],
        props: {
          numArgs: 2,
          allowedInText: true
        },
        handler: /* @__PURE__ */ __name((_ref, args) => {
          var {
            parser: parser23
          } = _ref;
          return {
            type: "htmlmathml",
            mode: parser23.mode,
            html: ordargument(args[0]),
            mathml: ordargument(args[1])
          };
        }, "handler"),
        htmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          var elements4 = buildExpression$1(group2.html, options3, false);
          return buildCommon.makeFragment(elements4);
        }, "htmlBuilder"),
        mathmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          return buildExpressionRow(group2.mathml, options3);
        }, "mathmlBuilder")
      });
      sizeData = /* @__PURE__ */ __name(function sizeData2(str2) {
        if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str2)) {
          return {
            number: +str2,
            unit: "bp"
          };
        } else {
          var match2 = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str2);
          if (!match2) {
            throw new ParseError("Invalid size: '" + str2 + "' in \\includegraphics");
          }
          var data5 = {
            number: +(match2[1] + match2[2]),
            // sign + magnitude, cast to number
            unit: match2[3]
          };
          if (!validUnit(data5)) {
            throw new ParseError("Invalid unit: '" + data5.unit + "' in \\includegraphics.");
          }
          return data5;
        }
      }, "sizeData");
      defineFunction({
        type: "includegraphics",
        names: ["\\includegraphics"],
        props: {
          numArgs: 1,
          numOptionalArgs: 1,
          argTypes: ["raw", "url"],
          allowedInText: false
        },
        handler: /* @__PURE__ */ __name((_ref, args, optArgs) => {
          var {
            parser: parser23
          } = _ref;
          var width3 = {
            number: 0,
            unit: "em"
          };
          var height2 = {
            number: 0.9,
            unit: "em"
          };
          var totalheight = {
            number: 0,
            unit: "em"
          };
          var alt = "";
          if (optArgs[0]) {
            var attributeStr = assertNodeType(optArgs[0], "raw").string;
            var attributes = attributeStr.split(",");
            for (var i2 = 0; i2 < attributes.length; i2++) {
              var keyVal = attributes[i2].split("=");
              if (keyVal.length === 2) {
                var str2 = keyVal[1].trim();
                switch (keyVal[0].trim()) {
                  case "alt":
                    alt = str2;
                    break;
                  case "width":
                    width3 = sizeData(str2);
                    break;
                  case "height":
                    height2 = sizeData(str2);
                    break;
                  case "totalheight":
                    totalheight = sizeData(str2);
                    break;
                  default:
                    throw new ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
                }
              }
            }
          }
          var src = assertNodeType(args[0], "url").url;
          if (alt === "") {
            alt = src;
            alt = alt.replace(/^.*[\\/]/, "");
            alt = alt.substring(0, alt.lastIndexOf("."));
          }
          if (!parser23.settings.isTrusted({
            command: "\\includegraphics",
            url: src
          })) {
            return parser23.formatUnsupportedCmd("\\includegraphics");
          }
          return {
            type: "includegraphics",
            mode: parser23.mode,
            alt,
            width: width3,
            height: height2,
            totalheight,
            src
          };
        }, "handler"),
        htmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          var height2 = calculateSize2(group2.height, options3);
          var depth = 0;
          if (group2.totalheight.number > 0) {
            depth = calculateSize2(group2.totalheight, options3) - height2;
          }
          var width3 = 0;
          if (group2.width.number > 0) {
            width3 = calculateSize2(group2.width, options3);
          }
          var style3 = {
            height: makeEm(height2 + depth)
          };
          if (width3 > 0) {
            style3.width = makeEm(width3);
          }
          if (depth > 0) {
            style3.verticalAlign = makeEm(-depth);
          }
          var node2 = new Img(group2.src, group2.alt, style3);
          node2.height = height2;
          node2.depth = depth;
          return node2;
        }, "htmlBuilder"),
        mathmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          var node2 = new mathMLTree.MathNode("mglyph", []);
          node2.setAttribute("alt", group2.alt);
          var height2 = calculateSize2(group2.height, options3);
          var depth = 0;
          if (group2.totalheight.number > 0) {
            depth = calculateSize2(group2.totalheight, options3) - height2;
            node2.setAttribute("valign", makeEm(-depth));
          }
          node2.setAttribute("height", makeEm(height2 + depth));
          if (group2.width.number > 0) {
            var width3 = calculateSize2(group2.width, options3);
            node2.setAttribute("width", makeEm(width3));
          }
          node2.setAttribute("src", group2.src);
          return node2;
        }, "mathmlBuilder")
      });
      defineFunction({
        type: "kern",
        names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
        props: {
          numArgs: 1,
          argTypes: ["size"],
          primitive: true,
          allowedInText: true
        },
        handler(_ref, args) {
          var {
            parser: parser23,
            funcName
          } = _ref;
          var size5 = assertNodeType(args[0], "size");
          if (parser23.settings.strict) {
            var mathFunction = funcName[1] === "m";
            var muUnit = size5.value.unit === "mu";
            if (mathFunction) {
              if (!muUnit) {
                parser23.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size5.value.unit + " units"));
              }
              if (parser23.mode !== "math") {
                parser23.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
              }
            } else {
              if (muUnit) {
                parser23.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
              }
            }
          }
          return {
            type: "kern",
            mode: parser23.mode,
            dimension: size5.value
          };
        },
        htmlBuilder(group2, options3) {
          return buildCommon.makeGlue(group2.dimension, options3);
        },
        mathmlBuilder(group2, options3) {
          var dimension = calculateSize2(group2.dimension, options3);
          return new mathMLTree.SpaceNode(dimension);
        }
      });
      defineFunction({
        type: "lap",
        names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: /* @__PURE__ */ __name((_ref, args) => {
          var {
            parser: parser23,
            funcName
          } = _ref;
          var body = args[0];
          return {
            type: "lap",
            mode: parser23.mode,
            alignment: funcName.slice(5),
            body
          };
        }, "handler"),
        htmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          var inner2;
          if (group2.alignment === "clap") {
            inner2 = buildCommon.makeSpan([], [buildGroup$1(group2.body, options3)]);
            inner2 = buildCommon.makeSpan(["inner"], [inner2], options3);
          } else {
            inner2 = buildCommon.makeSpan(["inner"], [buildGroup$1(group2.body, options3)]);
          }
          var fix = buildCommon.makeSpan(["fix"], []);
          var node2 = buildCommon.makeSpan([group2.alignment], [inner2, fix], options3);
          var strut = buildCommon.makeSpan(["strut"]);
          strut.style.height = makeEm(node2.height + node2.depth);
          if (node2.depth) {
            strut.style.verticalAlign = makeEm(-node2.depth);
          }
          node2.children.unshift(strut);
          node2 = buildCommon.makeSpan(["thinbox"], [node2], options3);
          return buildCommon.makeSpan(["mord", "vbox"], [node2], options3);
        }, "htmlBuilder"),
        mathmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          var node2 = new mathMLTree.MathNode("mpadded", [buildGroup2(group2.body, options3)]);
          if (group2.alignment !== "rlap") {
            var offset = group2.alignment === "llap" ? "-1" : "-0.5";
            node2.setAttribute("lspace", offset + "width");
          }
          node2.setAttribute("width", "0px");
          return node2;
        }, "mathmlBuilder")
      });
      defineFunction({
        type: "styling",
        names: ["\\(", "$"],
        props: {
          numArgs: 0,
          allowedInText: true,
          allowedInMath: false
        },
        handler(_ref, args) {
          var {
            funcName,
            parser: parser23
          } = _ref;
          var outerMode = parser23.mode;
          parser23.switchMode("math");
          var close2 = funcName === "\\(" ? "\\)" : "$";
          var body = parser23.parseExpression(false, close2);
          parser23.expect(close2);
          parser23.switchMode(outerMode);
          return {
            type: "styling",
            mode: parser23.mode,
            style: "text",
            body
          };
        }
      });
      defineFunction({
        type: "text",
        // Doesn't matter what this is.
        names: ["\\)", "\\]"],
        props: {
          numArgs: 0,
          allowedInText: true,
          allowedInMath: false
        },
        handler(context, args) {
          throw new ParseError("Mismatched " + context.funcName);
        }
      });
      chooseMathStyle = /* @__PURE__ */ __name((group2, options3) => {
        switch (options3.style.size) {
          case Style$1.DISPLAY.size:
            return group2.display;
          case Style$1.TEXT.size:
            return group2.text;
          case Style$1.SCRIPT.size:
            return group2.script;
          case Style$1.SCRIPTSCRIPT.size:
            return group2.scriptscript;
          default:
            return group2.text;
        }
      }, "chooseMathStyle");
      defineFunction({
        type: "mathchoice",
        names: ["\\mathchoice"],
        props: {
          numArgs: 4,
          primitive: true
        },
        handler: /* @__PURE__ */ __name((_ref, args) => {
          var {
            parser: parser23
          } = _ref;
          return {
            type: "mathchoice",
            mode: parser23.mode,
            display: ordargument(args[0]),
            text: ordargument(args[1]),
            script: ordargument(args[2]),
            scriptscript: ordargument(args[3])
          };
        }, "handler"),
        htmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          var body = chooseMathStyle(group2, options3);
          var elements4 = buildExpression$1(body, options3, false);
          return buildCommon.makeFragment(elements4);
        }, "htmlBuilder"),
        mathmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          var body = chooseMathStyle(group2, options3);
          return buildExpressionRow(body, options3);
        }, "mathmlBuilder")
      });
      assembleSupSub = /* @__PURE__ */ __name((base, supGroup, subGroup, options3, style3, slant, baseShift) => {
        base = buildCommon.makeSpan([], [base]);
        var subIsSingleCharacter = subGroup && utils.isCharacterBox(subGroup);
        var sub2;
        var sup2;
        if (supGroup) {
          var elem = buildGroup$1(supGroup, options3.havingStyle(style3.sup()), options3);
          sup2 = {
            elem,
            kern: Math.max(options3.fontMetrics().bigOpSpacing1, options3.fontMetrics().bigOpSpacing3 - elem.depth)
          };
        }
        if (subGroup) {
          var _elem = buildGroup$1(subGroup, options3.havingStyle(style3.sub()), options3);
          sub2 = {
            elem: _elem,
            kern: Math.max(options3.fontMetrics().bigOpSpacing2, options3.fontMetrics().bigOpSpacing4 - _elem.height)
          };
        }
        var finalGroup;
        if (sup2 && sub2) {
          var bottom2 = options3.fontMetrics().bigOpSpacing5 + sub2.elem.height + sub2.elem.depth + sub2.kern + base.depth + baseShift;
          finalGroup = buildCommon.makeVList({
            positionType: "bottom",
            positionData: bottom2,
            children: [{
              type: "kern",
              size: options3.fontMetrics().bigOpSpacing5
            }, {
              type: "elem",
              elem: sub2.elem,
              marginLeft: makeEm(-slant)
            }, {
              type: "kern",
              size: sub2.kern
            }, {
              type: "elem",
              elem: base
            }, {
              type: "kern",
              size: sup2.kern
            }, {
              type: "elem",
              elem: sup2.elem,
              marginLeft: makeEm(slant)
            }, {
              type: "kern",
              size: options3.fontMetrics().bigOpSpacing5
            }]
          }, options3);
        } else if (sub2) {
          var top2 = base.height - baseShift;
          finalGroup = buildCommon.makeVList({
            positionType: "top",
            positionData: top2,
            children: [{
              type: "kern",
              size: options3.fontMetrics().bigOpSpacing5
            }, {
              type: "elem",
              elem: sub2.elem,
              marginLeft: makeEm(-slant)
            }, {
              type: "kern",
              size: sub2.kern
            }, {
              type: "elem",
              elem: base
            }]
          }, options3);
        } else if (sup2) {
          var _bottom = base.depth + baseShift;
          finalGroup = buildCommon.makeVList({
            positionType: "bottom",
            positionData: _bottom,
            children: [{
              type: "elem",
              elem: base
            }, {
              type: "kern",
              size: sup2.kern
            }, {
              type: "elem",
              elem: sup2.elem,
              marginLeft: makeEm(slant)
            }, {
              type: "kern",
              size: options3.fontMetrics().bigOpSpacing5
            }]
          }, options3);
        } else {
          return base;
        }
        var parts = [finalGroup];
        if (sub2 && slant !== 0 && !subIsSingleCharacter) {
          var spacer = buildCommon.makeSpan(["mspace"], [], options3);
          spacer.style.marginRight = makeEm(slant);
          parts.unshift(spacer);
        }
        return buildCommon.makeSpan(["mop", "op-limits"], parts, options3);
      }, "assembleSupSub");
      noSuccessor = ["\\smallint"];
      htmlBuilder$2 = /* @__PURE__ */ __name((grp, options3) => {
        var supGroup;
        var subGroup;
        var hasLimits = false;
        var group2;
        if (grp.type === "supsub") {
          supGroup = grp.sup;
          subGroup = grp.sub;
          group2 = assertNodeType(grp.base, "op");
          hasLimits = true;
        } else {
          group2 = assertNodeType(grp, "op");
        }
        var style3 = options3.style;
        var large = false;
        if (style3.size === Style$1.DISPLAY.size && group2.symbol && !utils.contains(noSuccessor, group2.name)) {
          large = true;
        }
        var base;
        if (group2.symbol) {
          var fontName = large ? "Size2-Regular" : "Size1-Regular";
          var stash = "";
          if (group2.name === "\\oiint" || group2.name === "\\oiiint") {
            stash = group2.name.slice(1);
            group2.name = stash === "oiint" ? "\\iint" : "\\iiint";
          }
          base = buildCommon.makeSymbol(group2.name, fontName, "math", options3, ["mop", "op-symbol", large ? "large-op" : "small-op"]);
          if (stash.length > 0) {
            var italic = base.italic;
            var oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options3);
            base = buildCommon.makeVList({
              positionType: "individualShift",
              children: [{
                type: "elem",
                elem: base,
                shift: 0
              }, {
                type: "elem",
                elem: oval,
                shift: large ? 0.08 : 0
              }]
            }, options3);
            group2.name = "\\" + stash;
            base.classes.unshift("mop");
            base.italic = italic;
          }
        } else if (group2.body) {
          var inner2 = buildExpression$1(group2.body, options3, true);
          if (inner2.length === 1 && inner2[0] instanceof SymbolNode) {
            base = inner2[0];
            base.classes[0] = "mop";
          } else {
            base = buildCommon.makeSpan(["mop"], inner2, options3);
          }
        } else {
          var output2 = [];
          for (var i2 = 1; i2 < group2.name.length; i2++) {
            output2.push(buildCommon.mathsym(group2.name[i2], group2.mode, options3));
          }
          base = buildCommon.makeSpan(["mop"], output2, options3);
        }
        var baseShift = 0;
        var slant = 0;
        if ((base instanceof SymbolNode || group2.name === "\\oiint" || group2.name === "\\oiiint") && !group2.suppressBaseShift) {
          baseShift = (base.height - base.depth) / 2 - options3.fontMetrics().axisHeight;
          slant = base.italic;
        }
        if (hasLimits) {
          return assembleSupSub(base, supGroup, subGroup, options3, style3, slant, baseShift);
        } else {
          if (baseShift) {
            base.style.position = "relative";
            base.style.top = makeEm(baseShift);
          }
          return base;
        }
      }, "htmlBuilder$2");
      mathmlBuilder$1 = /* @__PURE__ */ __name((group2, options3) => {
        var node2;
        if (group2.symbol) {
          node2 = new MathNode("mo", [makeText(group2.name, group2.mode)]);
          if (utils.contains(noSuccessor, group2.name)) {
            node2.setAttribute("largeop", "false");
          }
        } else if (group2.body) {
          node2 = new MathNode("mo", buildExpression2(group2.body, options3));
        } else {
          node2 = new MathNode("mi", [new TextNode(group2.name.slice(1))]);
          var operator = new MathNode("mo", [makeText("\u2061", "text")]);
          if (group2.parentIsSupSub) {
            node2 = new MathNode("mrow", [node2, operator]);
          } else {
            node2 = newDocumentFragment([node2, operator]);
          }
        }
        return node2;
      }, "mathmlBuilder$1");
      singleCharBigOps = {
        "\u220F": "\\prod",
        "\u2210": "\\coprod",
        "\u2211": "\\sum",
        "\u22C0": "\\bigwedge",
        "\u22C1": "\\bigvee",
        "\u22C2": "\\bigcap",
        "\u22C3": "\\bigcup",
        "\u2A00": "\\bigodot",
        "\u2A01": "\\bigoplus",
        "\u2A02": "\\bigotimes",
        "\u2A04": "\\biguplus",
        "\u2A06": "\\bigsqcup"
      };
      defineFunction({
        type: "op",
        names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "\u220F", "\u2210", "\u2211", "\u22C0", "\u22C1", "\u22C2", "\u22C3", "\u2A00", "\u2A01", "\u2A02", "\u2A04", "\u2A06"],
        props: {
          numArgs: 0
        },
        handler: /* @__PURE__ */ __name((_ref, args) => {
          var {
            parser: parser23,
            funcName
          } = _ref;
          var fName = funcName;
          if (fName.length === 1) {
            fName = singleCharBigOps[fName];
          }
          return {
            type: "op",
            mode: parser23.mode,
            limits: true,
            parentIsSupSub: false,
            symbol: true,
            name: fName
          };
        }, "handler"),
        htmlBuilder: htmlBuilder$2,
        mathmlBuilder: mathmlBuilder$1
      });
      defineFunction({
        type: "op",
        names: ["\\mathop"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: /* @__PURE__ */ __name((_ref2, args) => {
          var {
            parser: parser23
          } = _ref2;
          var body = args[0];
          return {
            type: "op",
            mode: parser23.mode,
            limits: false,
            parentIsSupSub: false,
            symbol: false,
            body: ordargument(body)
          };
        }, "handler"),
        htmlBuilder: htmlBuilder$2,
        mathmlBuilder: mathmlBuilder$1
      });
      singleCharIntegrals = {
        "\u222B": "\\int",
        "\u222C": "\\iint",
        "\u222D": "\\iiint",
        "\u222E": "\\oint",
        "\u222F": "\\oiint",
        "\u2230": "\\oiiint"
      };
      defineFunction({
        type: "op",
        names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
        props: {
          numArgs: 0
        },
        handler(_ref3) {
          var {
            parser: parser23,
            funcName
          } = _ref3;
          return {
            type: "op",
            mode: parser23.mode,
            limits: false,
            parentIsSupSub: false,
            symbol: false,
            name: funcName
          };
        },
        htmlBuilder: htmlBuilder$2,
        mathmlBuilder: mathmlBuilder$1
      });
      defineFunction({
        type: "op",
        names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
        props: {
          numArgs: 0
        },
        handler(_ref4) {
          var {
            parser: parser23,
            funcName
          } = _ref4;
          return {
            type: "op",
            mode: parser23.mode,
            limits: true,
            parentIsSupSub: false,
            symbol: false,
            name: funcName
          };
        },
        htmlBuilder: htmlBuilder$2,
        mathmlBuilder: mathmlBuilder$1
      });
      defineFunction({
        type: "op",
        names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "\u222B", "\u222C", "\u222D", "\u222E", "\u222F", "\u2230"],
        props: {
          numArgs: 0
        },
        handler(_ref5) {
          var {
            parser: parser23,
            funcName
          } = _ref5;
          var fName = funcName;
          if (fName.length === 1) {
            fName = singleCharIntegrals[fName];
          }
          return {
            type: "op",
            mode: parser23.mode,
            limits: false,
            parentIsSupSub: false,
            symbol: true,
            name: fName
          };
        },
        htmlBuilder: htmlBuilder$2,
        mathmlBuilder: mathmlBuilder$1
      });
      htmlBuilder$1 = /* @__PURE__ */ __name((grp, options3) => {
        var supGroup;
        var subGroup;
        var hasLimits = false;
        var group2;
        if (grp.type === "supsub") {
          supGroup = grp.sup;
          subGroup = grp.sub;
          group2 = assertNodeType(grp.base, "operatorname");
          hasLimits = true;
        } else {
          group2 = assertNodeType(grp, "operatorname");
        }
        var base;
        if (group2.body.length > 0) {
          var body = group2.body.map((child2) => {
            var childText = child2.text;
            if (typeof childText === "string") {
              return {
                type: "textord",
                mode: child2.mode,
                text: childText
              };
            } else {
              return child2;
            }
          });
          var expression = buildExpression$1(body, options3.withFont("mathrm"), true);
          for (var i2 = 0; i2 < expression.length; i2++) {
            var child = expression[i2];
            if (child instanceof SymbolNode) {
              child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
            }
          }
          base = buildCommon.makeSpan(["mop"], expression, options3);
        } else {
          base = buildCommon.makeSpan(["mop"], [], options3);
        }
        if (hasLimits) {
          return assembleSupSub(base, supGroup, subGroup, options3, options3.style, 0, 0);
        } else {
          return base;
        }
      }, "htmlBuilder$1");
      mathmlBuilder2 = /* @__PURE__ */ __name((group2, options3) => {
        var expression = buildExpression2(group2.body, options3.withFont("mathrm"));
        var isAllString = true;
        for (var i2 = 0; i2 < expression.length; i2++) {
          var node2 = expression[i2];
          if (node2 instanceof mathMLTree.SpaceNode) ;
          else if (node2 instanceof mathMLTree.MathNode) {
            switch (node2.type) {
              case "mi":
              case "mn":
              case "ms":
              case "mspace":
              case "mtext":
                break;
              case "mo": {
                var child = node2.children[0];
                if (node2.children.length === 1 && child instanceof mathMLTree.TextNode) {
                  child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
                } else {
                  isAllString = false;
                }
                break;
              }
              default:
                isAllString = false;
            }
          } else {
            isAllString = false;
          }
        }
        if (isAllString) {
          var word = expression.map((node3) => node3.toText()).join("");
          expression = [new mathMLTree.TextNode(word)];
        }
        var identifier2 = new mathMLTree.MathNode("mi", expression);
        identifier2.setAttribute("mathvariant", "normal");
        var operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);
        if (group2.parentIsSupSub) {
          return new mathMLTree.MathNode("mrow", [identifier2, operator]);
        } else {
          return mathMLTree.newDocumentFragment([identifier2, operator]);
        }
      }, "mathmlBuilder");
      defineFunction({
        type: "operatorname",
        names: ["\\operatorname@", "\\operatornamewithlimits"],
        props: {
          numArgs: 1
        },
        handler: /* @__PURE__ */ __name((_ref, args) => {
          var {
            parser: parser23,
            funcName
          } = _ref;
          var body = args[0];
          return {
            type: "operatorname",
            mode: parser23.mode,
            body: ordargument(body),
            alwaysHandleSupSub: funcName === "\\operatornamewithlimits",
            limits: false,
            parentIsSupSub: false
          };
        }, "handler"),
        htmlBuilder: htmlBuilder$1,
        mathmlBuilder: mathmlBuilder2
      });
      defineMacro("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
      defineFunctionBuilders({
        type: "ordgroup",
        htmlBuilder(group2, options3) {
          if (group2.semisimple) {
            return buildCommon.makeFragment(buildExpression$1(group2.body, options3, false));
          }
          return buildCommon.makeSpan(["mord"], buildExpression$1(group2.body, options3, true), options3);
        },
        mathmlBuilder(group2, options3) {
          return buildExpressionRow(group2.body, options3, true);
        }
      });
      defineFunction({
        type: "overline",
        names: ["\\overline"],
        props: {
          numArgs: 1
        },
        handler(_ref, args) {
          var {
            parser: parser23
          } = _ref;
          var body = args[0];
          return {
            type: "overline",
            mode: parser23.mode,
            body
          };
        },
        htmlBuilder(group2, options3) {
          var innerGroup = buildGroup$1(group2.body, options3.havingCrampedStyle());
          var line2 = buildCommon.makeLineSpan("overline-line", options3);
          var defaultRuleThickness = options3.fontMetrics().defaultRuleThickness;
          var vlist = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: innerGroup
            }, {
              type: "kern",
              size: 3 * defaultRuleThickness
            }, {
              type: "elem",
              elem: line2
            }, {
              type: "kern",
              size: defaultRuleThickness
            }]
          }, options3);
          return buildCommon.makeSpan(["mord", "overline"], [vlist], options3);
        },
        mathmlBuilder(group2, options3) {
          var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
          operator.setAttribute("stretchy", "true");
          var node2 = new mathMLTree.MathNode("mover", [buildGroup2(group2.body, options3), operator]);
          node2.setAttribute("accent", "true");
          return node2;
        }
      });
      defineFunction({
        type: "phantom",
        names: ["\\phantom"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: /* @__PURE__ */ __name((_ref, args) => {
          var {
            parser: parser23
          } = _ref;
          var body = args[0];
          return {
            type: "phantom",
            mode: parser23.mode,
            body: ordargument(body)
          };
        }, "handler"),
        htmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          var elements4 = buildExpression$1(group2.body, options3.withPhantom(), false);
          return buildCommon.makeFragment(elements4);
        }, "htmlBuilder"),
        mathmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          var inner2 = buildExpression2(group2.body, options3);
          return new mathMLTree.MathNode("mphantom", inner2);
        }, "mathmlBuilder")
      });
      defineFunction({
        type: "hphantom",
        names: ["\\hphantom"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: /* @__PURE__ */ __name((_ref2, args) => {
          var {
            parser: parser23
          } = _ref2;
          var body = args[0];
          return {
            type: "hphantom",
            mode: parser23.mode,
            body
          };
        }, "handler"),
        htmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          var node2 = buildCommon.makeSpan([], [buildGroup$1(group2.body, options3.withPhantom())]);
          node2.height = 0;
          node2.depth = 0;
          if (node2.children) {
            for (var i2 = 0; i2 < node2.children.length; i2++) {
              node2.children[i2].height = 0;
              node2.children[i2].depth = 0;
            }
          }
          node2 = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: node2
            }]
          }, options3);
          return buildCommon.makeSpan(["mord"], [node2], options3);
        }, "htmlBuilder"),
        mathmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          var inner2 = buildExpression2(ordargument(group2.body), options3);
          var phantom = new mathMLTree.MathNode("mphantom", inner2);
          var node2 = new mathMLTree.MathNode("mpadded", [phantom]);
          node2.setAttribute("height", "0px");
          node2.setAttribute("depth", "0px");
          return node2;
        }, "mathmlBuilder")
      });
      defineFunction({
        type: "vphantom",
        names: ["\\vphantom"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: /* @__PURE__ */ __name((_ref3, args) => {
          var {
            parser: parser23
          } = _ref3;
          var body = args[0];
          return {
            type: "vphantom",
            mode: parser23.mode,
            body
          };
        }, "handler"),
        htmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          var inner2 = buildCommon.makeSpan(["inner"], [buildGroup$1(group2.body, options3.withPhantom())]);
          var fix = buildCommon.makeSpan(["fix"], []);
          return buildCommon.makeSpan(["mord", "rlap"], [inner2, fix], options3);
        }, "htmlBuilder"),
        mathmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          var inner2 = buildExpression2(ordargument(group2.body), options3);
          var phantom = new mathMLTree.MathNode("mphantom", inner2);
          var node2 = new mathMLTree.MathNode("mpadded", [phantom]);
          node2.setAttribute("width", "0px");
          return node2;
        }, "mathmlBuilder")
      });
      defineFunction({
        type: "raisebox",
        names: ["\\raisebox"],
        props: {
          numArgs: 2,
          argTypes: ["size", "hbox"],
          allowedInText: true
        },
        handler(_ref, args) {
          var {
            parser: parser23
          } = _ref;
          var amount = assertNodeType(args[0], "size").value;
          var body = args[1];
          return {
            type: "raisebox",
            mode: parser23.mode,
            dy: amount,
            body
          };
        },
        htmlBuilder(group2, options3) {
          var body = buildGroup$1(group2.body, options3);
          var dy = calculateSize2(group2.dy, options3);
          return buildCommon.makeVList({
            positionType: "shift",
            positionData: -dy,
            children: [{
              type: "elem",
              elem: body
            }]
          }, options3);
        },
        mathmlBuilder(group2, options3) {
          var node2 = new mathMLTree.MathNode("mpadded", [buildGroup2(group2.body, options3)]);
          var dy = group2.dy.number + group2.dy.unit;
          node2.setAttribute("voffset", dy);
          return node2;
        }
      });
      defineFunction({
        type: "internal",
        names: ["\\relax"],
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler(_ref) {
          var {
            parser: parser23
          } = _ref;
          return {
            type: "internal",
            mode: parser23.mode
          };
        }
      });
      defineFunction({
        type: "rule",
        names: ["\\rule"],
        props: {
          numArgs: 2,
          numOptionalArgs: 1,
          argTypes: ["size", "size", "size"]
        },
        handler(_ref, args, optArgs) {
          var {
            parser: parser23
          } = _ref;
          var shift2 = optArgs[0];
          var width3 = assertNodeType(args[0], "size");
          var height2 = assertNodeType(args[1], "size");
          return {
            type: "rule",
            mode: parser23.mode,
            shift: shift2 && assertNodeType(shift2, "size").value,
            width: width3.value,
            height: height2.value
          };
        },
        htmlBuilder(group2, options3) {
          var rule = buildCommon.makeSpan(["mord", "rule"], [], options3);
          var width3 = calculateSize2(group2.width, options3);
          var height2 = calculateSize2(group2.height, options3);
          var shift2 = group2.shift ? calculateSize2(group2.shift, options3) : 0;
          rule.style.borderRightWidth = makeEm(width3);
          rule.style.borderTopWidth = makeEm(height2);
          rule.style.bottom = makeEm(shift2);
          rule.width = width3;
          rule.height = height2 + shift2;
          rule.depth = -shift2;
          rule.maxFontSize = height2 * 1.125 * options3.sizeMultiplier;
          return rule;
        },
        mathmlBuilder(group2, options3) {
          var width3 = calculateSize2(group2.width, options3);
          var height2 = calculateSize2(group2.height, options3);
          var shift2 = group2.shift ? calculateSize2(group2.shift, options3) : 0;
          var color2 = options3.color && options3.getColor() || "black";
          var rule = new mathMLTree.MathNode("mspace");
          rule.setAttribute("mathbackground", color2);
          rule.setAttribute("width", makeEm(width3));
          rule.setAttribute("height", makeEm(height2));
          var wrapper = new mathMLTree.MathNode("mpadded", [rule]);
          if (shift2 >= 0) {
            wrapper.setAttribute("height", makeEm(shift2));
          } else {
            wrapper.setAttribute("height", makeEm(shift2));
            wrapper.setAttribute("depth", makeEm(-shift2));
          }
          wrapper.setAttribute("voffset", makeEm(shift2));
          return wrapper;
        }
      });
      __name(sizingGroup, "sizingGroup");
      sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
      htmlBuilder2 = /* @__PURE__ */ __name((group2, options3) => {
        var newOptions = options3.havingSize(group2.size);
        return sizingGroup(group2.body, newOptions, options3);
      }, "htmlBuilder");
      defineFunction({
        type: "sizing",
        names: sizeFuncs,
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler: /* @__PURE__ */ __name((_ref, args) => {
          var {
            breakOnTokenText,
            funcName,
            parser: parser23
          } = _ref;
          var body = parser23.parseExpression(false, breakOnTokenText);
          return {
            type: "sizing",
            mode: parser23.mode,
            // Figure out what size to use based on the list of functions above
            size: sizeFuncs.indexOf(funcName) + 1,
            body
          };
        }, "handler"),
        htmlBuilder: htmlBuilder2,
        mathmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          var newOptions = options3.havingSize(group2.size);
          var inner2 = buildExpression2(group2.body, newOptions);
          var node2 = new mathMLTree.MathNode("mstyle", inner2);
          node2.setAttribute("mathsize", makeEm(newOptions.sizeMultiplier));
          return node2;
        }, "mathmlBuilder")
      });
      defineFunction({
        type: "smash",
        names: ["\\smash"],
        props: {
          numArgs: 1,
          numOptionalArgs: 1,
          allowedInText: true
        },
        handler: /* @__PURE__ */ __name((_ref, args, optArgs) => {
          var {
            parser: parser23
          } = _ref;
          var smashHeight = false;
          var smashDepth = false;
          var tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
          if (tbArg) {
            var letter = "";
            for (var i2 = 0; i2 < tbArg.body.length; ++i2) {
              var node2 = tbArg.body[i2];
              letter = node2.text;
              if (letter === "t") {
                smashHeight = true;
              } else if (letter === "b") {
                smashDepth = true;
              } else {
                smashHeight = false;
                smashDepth = false;
                break;
              }
            }
          } else {
            smashHeight = true;
            smashDepth = true;
          }
          var body = args[0];
          return {
            type: "smash",
            mode: parser23.mode,
            body,
            smashHeight,
            smashDepth
          };
        }, "handler"),
        htmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          var node2 = buildCommon.makeSpan([], [buildGroup$1(group2.body, options3)]);
          if (!group2.smashHeight && !group2.smashDepth) {
            return node2;
          }
          if (group2.smashHeight) {
            node2.height = 0;
            if (node2.children) {
              for (var i2 = 0; i2 < node2.children.length; i2++) {
                node2.children[i2].height = 0;
              }
            }
          }
          if (group2.smashDepth) {
            node2.depth = 0;
            if (node2.children) {
              for (var _i = 0; _i < node2.children.length; _i++) {
                node2.children[_i].depth = 0;
              }
            }
          }
          var smashedNode = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: node2
            }]
          }, options3);
          return buildCommon.makeSpan(["mord"], [smashedNode], options3);
        }, "htmlBuilder"),
        mathmlBuilder: /* @__PURE__ */ __name((group2, options3) => {
          var node2 = new mathMLTree.MathNode("mpadded", [buildGroup2(group2.body, options3)]);
          if (group2.smashHeight) {
            node2.setAttribute("height", "0px");
          }
          if (group2.smashDepth) {
            node2.setAttribute("depth", "0px");
          }
          return node2;
        }, "mathmlBuilder")
      });
      defineFunction({
        type: "sqrt",
        names: ["\\sqrt"],
        props: {
          numArgs: 1,
          numOptionalArgs: 1
        },
        handler(_ref, args, optArgs) {
          var {
            parser: parser23
          } = _ref;
          var index = optArgs[0];
          var body = args[0];
          return {
            type: "sqrt",
            mode: parser23.mode,
            body,
            index
          };
        },
        htmlBuilder(group2, options3) {
          var inner2 = buildGroup$1(group2.body, options3.havingCrampedStyle());
          if (inner2.height === 0) {
            inner2.height = options3.fontMetrics().xHeight;
          }
          inner2 = buildCommon.wrapFragment(inner2, options3);
          var metrics = options3.fontMetrics();
          var theta = metrics.defaultRuleThickness;
          var phi = theta;
          if (options3.style.id < Style$1.TEXT.id) {
            phi = options3.fontMetrics().xHeight;
          }
          var lineClearance = theta + phi / 4;
          var minDelimiterHeight = inner2.height + inner2.depth + lineClearance + theta;
          var {
            span: img,
            ruleWidth,
            advanceWidth
          } = delimiter.sqrtImage(minDelimiterHeight, options3);
          var delimDepth = img.height - ruleWidth;
          if (delimDepth > inner2.height + inner2.depth + lineClearance) {
            lineClearance = (lineClearance + delimDepth - inner2.height - inner2.depth) / 2;
          }
          var imgShift = img.height - inner2.height - lineClearance - ruleWidth;
          inner2.style.paddingLeft = makeEm(advanceWidth);
          var body = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: inner2,
              wrapperClasses: ["svg-align"]
            }, {
              type: "kern",
              size: -(inner2.height + imgShift)
            }, {
              type: "elem",
              elem: img
            }, {
              type: "kern",
              size: ruleWidth
            }]
          }, options3);
          if (!group2.index) {
            return buildCommon.makeSpan(["mord", "sqrt"], [body], options3);
          } else {
            var newOptions = options3.havingStyle(Style$1.SCRIPTSCRIPT);
            var rootm = buildGroup$1(group2.index, newOptions, options3);
            var toShift = 0.6 * (body.height - body.depth);
            var rootVList = buildCommon.makeVList({
              positionType: "shift",
              positionData: -toShift,
              children: [{
                type: "elem",
                elem: rootm
              }]
            }, options3);
            var rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
            return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options3);
          }
        },
        mathmlBuilder(group2, options3) {
          var {
            body,
            index
          } = group2;
          return index ? new mathMLTree.MathNode("mroot", [buildGroup2(body, options3), buildGroup2(index, options3)]) : new mathMLTree.MathNode("msqrt", [buildGroup2(body, options3)]);
        }
      });
      styleMap = {
        "display": Style$1.DISPLAY,
        "text": Style$1.TEXT,
        "script": Style$1.SCRIPT,
        "scriptscript": Style$1.SCRIPTSCRIPT
      };
      defineFunction({
        type: "styling",
        names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler(_ref, args) {
          var {
            breakOnTokenText,
            funcName,
            parser: parser23
          } = _ref;
          var body = parser23.parseExpression(true, breakOnTokenText);
          var style3 = funcName.slice(1, funcName.length - 5);
          return {
            type: "styling",
            mode: parser23.mode,
            // Figure out what style to use by pulling out the style from
            // the function name
            style: style3,
            body
          };
        },
        htmlBuilder(group2, options3) {
          var newStyle = styleMap[group2.style];
          var newOptions = options3.havingStyle(newStyle).withFont("");
          return sizingGroup(group2.body, newOptions, options3);
        },
        mathmlBuilder(group2, options3) {
          var newStyle = styleMap[group2.style];
          var newOptions = options3.havingStyle(newStyle);
          var inner2 = buildExpression2(group2.body, newOptions);
          var node2 = new mathMLTree.MathNode("mstyle", inner2);
          var styleAttributes = {
            "display": ["0", "true"],
            "text": ["0", "false"],
            "script": ["1", "false"],
            "scriptscript": ["2", "false"]
          };
          var attr = styleAttributes[group2.style];
          node2.setAttribute("scriptlevel", attr[0]);
          node2.setAttribute("displaystyle", attr[1]);
          return node2;
        }
      });
      htmlBuilderDelegate = /* @__PURE__ */ __name(function htmlBuilderDelegate2(group2, options3) {
        var base = group2.base;
        if (!base) {
          return null;
        } else if (base.type === "op") {
          var delegate = base.limits && (options3.style.size === Style$1.DISPLAY.size || base.alwaysHandleSupSub);
          return delegate ? htmlBuilder$2 : null;
        } else if (base.type === "operatorname") {
          var _delegate = base.alwaysHandleSupSub && (options3.style.size === Style$1.DISPLAY.size || base.limits);
          return _delegate ? htmlBuilder$1 : null;
        } else if (base.type === "accent") {
          return utils.isCharacterBox(base.base) ? htmlBuilder$a : null;
        } else if (base.type === "horizBrace") {
          var isSup = !group2.sub;
          return isSup === base.isOver ? htmlBuilder$3 : null;
        } else {
          return null;
        }
      }, "htmlBuilderDelegate");
      defineFunctionBuilders({
        type: "supsub",
        htmlBuilder(group2, options3) {
          var builderDelegate = htmlBuilderDelegate(group2, options3);
          if (builderDelegate) {
            return builderDelegate(group2, options3);
          }
          var {
            base: valueBase,
            sup: valueSup,
            sub: valueSub
          } = group2;
          var base = buildGroup$1(valueBase, options3);
          var supm;
          var subm;
          var metrics = options3.fontMetrics();
          var supShift = 0;
          var subShift = 0;
          var isCharacterBox3 = valueBase && utils.isCharacterBox(valueBase);
          if (valueSup) {
            var newOptions = options3.havingStyle(options3.style.sup());
            supm = buildGroup$1(valueSup, newOptions, options3);
            if (!isCharacterBox3) {
              supShift = base.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options3.sizeMultiplier;
            }
          }
          if (valueSub) {
            var _newOptions = options3.havingStyle(options3.style.sub());
            subm = buildGroup$1(valueSub, _newOptions, options3);
            if (!isCharacterBox3) {
              subShift = base.depth + _newOptions.fontMetrics().subDrop * _newOptions.sizeMultiplier / options3.sizeMultiplier;
            }
          }
          var minSupShift;
          if (options3.style === Style$1.DISPLAY) {
            minSupShift = metrics.sup1;
          } else if (options3.style.cramped) {
            minSupShift = metrics.sup3;
          } else {
            minSupShift = metrics.sup2;
          }
          var multiplier = options3.sizeMultiplier;
          var marginRight = makeEm(0.5 / metrics.ptPerEm / multiplier);
          var marginLeft = null;
          if (subm) {
            var isOiint = group2.base && group2.base.type === "op" && group2.base.name && (group2.base.name === "\\oiint" || group2.base.name === "\\oiiint");
            if (base instanceof SymbolNode || isOiint) {
              marginLeft = makeEm(-base.italic);
            }
          }
          var supsub;
          if (supm && subm) {
            supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
            subShift = Math.max(subShift, metrics.sub2);
            var ruleWidth = metrics.defaultRuleThickness;
            var maxWidth = 4 * ruleWidth;
            if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
              subShift = maxWidth - (supShift - supm.depth) + subm.height;
              var psi = 0.8 * metrics.xHeight - (supShift - supm.depth);
              if (psi > 0) {
                supShift += psi;
                subShift -= psi;
              }
            }
            var vlistElem = [{
              type: "elem",
              elem: subm,
              shift: subShift,
              marginRight,
              marginLeft
            }, {
              type: "elem",
              elem: supm,
              shift: -supShift,
              marginRight
            }];
            supsub = buildCommon.makeVList({
              positionType: "individualShift",
              children: vlistElem
            }, options3);
          } else if (subm) {
            subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
            var _vlistElem = [{
              type: "elem",
              elem: subm,
              marginLeft,
              marginRight
            }];
            supsub = buildCommon.makeVList({
              positionType: "shift",
              positionData: subShift,
              children: _vlistElem
            }, options3);
          } else if (supm) {
            supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
            supsub = buildCommon.makeVList({
              positionType: "shift",
              positionData: -supShift,
              children: [{
                type: "elem",
                elem: supm,
                marginRight
              }]
            }, options3);
          } else {
            throw new Error("supsub must have either sup or sub.");
          }
          var mclass = getTypeOfDomTree(base, "right") || "mord";
          return buildCommon.makeSpan([mclass], [base, buildCommon.makeSpan(["msupsub"], [supsub])], options3);
        },
        mathmlBuilder(group2, options3) {
          var isBrace = false;
          var isOver;
          var isSup;
          if (group2.base && group2.base.type === "horizBrace") {
            isSup = !!group2.sup;
            if (isSup === group2.base.isOver) {
              isBrace = true;
              isOver = group2.base.isOver;
            }
          }
          if (group2.base && (group2.base.type === "op" || group2.base.type === "operatorname")) {
            group2.base.parentIsSupSub = true;
          }
          var children2 = [buildGroup2(group2.base, options3)];
          if (group2.sub) {
            children2.push(buildGroup2(group2.sub, options3));
          }
          if (group2.sup) {
            children2.push(buildGroup2(group2.sup, options3));
          }
          var nodeType3;
          if (isBrace) {
            nodeType3 = isOver ? "mover" : "munder";
          } else if (!group2.sub) {
            var base = group2.base;
            if (base && base.type === "op" && base.limits && (options3.style === Style$1.DISPLAY || base.alwaysHandleSupSub)) {
              nodeType3 = "mover";
            } else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (base.limits || options3.style === Style$1.DISPLAY)) {
              nodeType3 = "mover";
            } else {
              nodeType3 = "msup";
            }
          } else if (!group2.sup) {
            var _base = group2.base;
            if (_base && _base.type === "op" && _base.limits && (options3.style === Style$1.DISPLAY || _base.alwaysHandleSupSub)) {
              nodeType3 = "munder";
            } else if (_base && _base.type === "operatorname" && _base.alwaysHandleSupSub && (_base.limits || options3.style === Style$1.DISPLAY)) {
              nodeType3 = "munder";
            } else {
              nodeType3 = "msub";
            }
          } else {
            var _base2 = group2.base;
            if (_base2 && _base2.type === "op" && _base2.limits && options3.style === Style$1.DISPLAY) {
              nodeType3 = "munderover";
            } else if (_base2 && _base2.type === "operatorname" && _base2.alwaysHandleSupSub && (options3.style === Style$1.DISPLAY || _base2.limits)) {
              nodeType3 = "munderover";
            } else {
              nodeType3 = "msubsup";
            }
          }
          return new mathMLTree.MathNode(nodeType3, children2);
        }
      });
      defineFunctionBuilders({
        type: "atom",
        htmlBuilder(group2, options3) {
          return buildCommon.mathsym(group2.text, group2.mode, options3, ["m" + group2.family]);
        },
        mathmlBuilder(group2, options3) {
          var node2 = new mathMLTree.MathNode("mo", [makeText(group2.text, group2.mode)]);
          if (group2.family === "bin") {
            var variant = getVariant(group2, options3);
            if (variant === "bold-italic") {
              node2.setAttribute("mathvariant", variant);
            }
          } else if (group2.family === "punct") {
            node2.setAttribute("separator", "true");
          } else if (group2.family === "open" || group2.family === "close") {
            node2.setAttribute("stretchy", "false");
          }
          return node2;
        }
      });
      defaultVariant = {
        "mi": "italic",
        "mn": "normal",
        "mtext": "normal"
      };
      defineFunctionBuilders({
        type: "mathord",
        htmlBuilder(group2, options3) {
          return buildCommon.makeOrd(group2, options3, "mathord");
        },
        mathmlBuilder(group2, options3) {
          var node2 = new mathMLTree.MathNode("mi", [makeText(group2.text, group2.mode, options3)]);
          var variant = getVariant(group2, options3) || "italic";
          if (variant !== defaultVariant[node2.type]) {
            node2.setAttribute("mathvariant", variant);
          }
          return node2;
        }
      });
      defineFunctionBuilders({
        type: "textord",
        htmlBuilder(group2, options3) {
          return buildCommon.makeOrd(group2, options3, "textord");
        },
        mathmlBuilder(group2, options3) {
          var text4 = makeText(group2.text, group2.mode, options3);
          var variant = getVariant(group2, options3) || "normal";
          var node2;
          if (group2.mode === "text") {
            node2 = new mathMLTree.MathNode("mtext", [text4]);
          } else if (/[0-9]/.test(group2.text)) {
            node2 = new mathMLTree.MathNode("mn", [text4]);
          } else if (group2.text === "\\prime") {
            node2 = new mathMLTree.MathNode("mo", [text4]);
          } else {
            node2 = new mathMLTree.MathNode("mi", [text4]);
          }
          if (variant !== defaultVariant[node2.type]) {
            node2.setAttribute("mathvariant", variant);
          }
          return node2;
        }
      });
      cssSpace = {
        "\\nobreak": "nobreak",
        "\\allowbreak": "allowbreak"
      };
      regularSpace = {
        " ": {},
        "\\ ": {},
        "~": {
          className: "nobreak"
        },
        "\\space": {},
        "\\nobreakspace": {
          className: "nobreak"
        }
      };
      defineFunctionBuilders({
        type: "spacing",
        htmlBuilder(group2, options3) {
          if (regularSpace.hasOwnProperty(group2.text)) {
            var className = regularSpace[group2.text].className || "";
            if (group2.mode === "text") {
              var ord = buildCommon.makeOrd(group2, options3, "textord");
              ord.classes.push(className);
              return ord;
            } else {
              return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group2.text, group2.mode, options3)], options3);
            }
          } else if (cssSpace.hasOwnProperty(group2.text)) {
            return buildCommon.makeSpan(["mspace", cssSpace[group2.text]], [], options3);
          } else {
            throw new ParseError('Unknown type of space "' + group2.text + '"');
          }
        },
        mathmlBuilder(group2, options3) {
          var node2;
          if (regularSpace.hasOwnProperty(group2.text)) {
            node2 = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("\xA0")]);
          } else if (cssSpace.hasOwnProperty(group2.text)) {
            return new mathMLTree.MathNode("mspace");
          } else {
            throw new ParseError('Unknown type of space "' + group2.text + '"');
          }
          return node2;
        }
      });
      pad = /* @__PURE__ */ __name(() => {
        var padNode = new mathMLTree.MathNode("mtd", []);
        padNode.setAttribute("width", "50%");
        return padNode;
      }, "pad");
      defineFunctionBuilders({
        type: "tag",
        mathmlBuilder(group2, options3) {
          var table = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group2.body, options3)]), pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group2.tag, options3)])])]);
          table.setAttribute("width", "100%");
          return table;
        }
      });
      textFontFamilies = {
        "\\text": void 0,
        "\\textrm": "textrm",
        "\\textsf": "textsf",
        "\\texttt": "texttt",
        "\\textnormal": "textrm"
      };
      textFontWeights = {
        "\\textbf": "textbf",
        "\\textmd": "textmd"
      };
      textFontShapes = {
        "\\textit": "textit",
        "\\textup": "textup"
      };
      optionsWithFont = /* @__PURE__ */ __name((group2, options3) => {
        var font = group2.font;
        if (!font) {
          return options3;
        } else if (textFontFamilies[font]) {
          return options3.withTextFontFamily(textFontFamilies[font]);
        } else if (textFontWeights[font]) {
          return options3.withTextFontWeight(textFontWeights[font]);
        } else if (font === "\\emph") {
          return options3.fontShape === "textit" ? options3.withTextFontShape("textup") : options3.withTextFontShape("textit");
        }
        return options3.withTextFontShape(textFontShapes[font]);
      }, "optionsWithFont");
      defineFunction({
        type: "text",
        names: [
          // Font families
          "\\text",
          "\\textrm",
          "\\textsf",
          "\\texttt",
          "\\textnormal",
          // Font weights
          "\\textbf",
          "\\textmd",
          // Font Shapes
          "\\textit",
          "\\textup",
          "\\emph"
        ],
        props: {
          numArgs: 1,
          argTypes: ["text"],
          allowedInArgument: true,
          allowedInText: true
        },
        handler(_ref, args) {
          var {
            parser: parser23,
            funcName
          } = _ref;
          var body = args[0];
          return {
            type: "text",
            mode: parser23.mode,
            body: ordargument(body),
            font: funcName
          };
        },
        htmlBuilder(group2, options3) {
          var newOptions = optionsWithFont(group2, options3);
          var inner2 = buildExpression$1(group2.body, newOptions, true);
          return buildCommon.makeSpan(["mord", "text"], inner2, newOptions);
        },
        mathmlBuilder(group2, options3) {
          var newOptions = optionsWithFont(group2, options3);
          return buildExpressionRow(group2.body, newOptions);
        }
      });
      defineFunction({
        type: "underline",
        names: ["\\underline"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler(_ref, args) {
          var {
            parser: parser23
          } = _ref;
          return {
            type: "underline",
            mode: parser23.mode,
            body: args[0]
          };
        },
        htmlBuilder(group2, options3) {
          var innerGroup = buildGroup$1(group2.body, options3);
          var line2 = buildCommon.makeLineSpan("underline-line", options3);
          var defaultRuleThickness = options3.fontMetrics().defaultRuleThickness;
          var vlist = buildCommon.makeVList({
            positionType: "top",
            positionData: innerGroup.height,
            children: [{
              type: "kern",
              size: defaultRuleThickness
            }, {
              type: "elem",
              elem: line2
            }, {
              type: "kern",
              size: 3 * defaultRuleThickness
            }, {
              type: "elem",
              elem: innerGroup
            }]
          }, options3);
          return buildCommon.makeSpan(["mord", "underline"], [vlist], options3);
        },
        mathmlBuilder(group2, options3) {
          var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
          operator.setAttribute("stretchy", "true");
          var node2 = new mathMLTree.MathNode("munder", [buildGroup2(group2.body, options3), operator]);
          node2.setAttribute("accentunder", "true");
          return node2;
        }
      });
      defineFunction({
        type: "vcenter",
        names: ["\\vcenter"],
        props: {
          numArgs: 1,
          argTypes: ["original"],
          // In LaTeX, \vcenter can act only on a box.
          allowedInText: false
        },
        handler(_ref, args) {
          var {
            parser: parser23
          } = _ref;
          return {
            type: "vcenter",
            mode: parser23.mode,
            body: args[0]
          };
        },
        htmlBuilder(group2, options3) {
          var body = buildGroup$1(group2.body, options3);
          var axisHeight = options3.fontMetrics().axisHeight;
          var dy = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));
          return buildCommon.makeVList({
            positionType: "shift",
            positionData: dy,
            children: [{
              type: "elem",
              elem: body
            }]
          }, options3);
        },
        mathmlBuilder(group2, options3) {
          return new mathMLTree.MathNode("mpadded", [buildGroup2(group2.body, options3)], ["vcenter"]);
        }
      });
      defineFunction({
        type: "verb",
        names: ["\\verb"],
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler(context, args, optArgs) {
          throw new ParseError("\\verb ended by end of line instead of matching delimiter");
        },
        htmlBuilder(group2, options3) {
          var text4 = makeVerb(group2);
          var body = [];
          var newOptions = options3.havingStyle(options3.style.text());
          for (var i2 = 0; i2 < text4.length; i2++) {
            var c3 = text4[i2];
            if (c3 === "~") {
              c3 = "\\textasciitilde";
            }
            body.push(buildCommon.makeSymbol(c3, "Typewriter-Regular", group2.mode, newOptions, ["mord", "texttt"]));
          }
          return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options3)), buildCommon.tryCombineChars(body), newOptions);
        },
        mathmlBuilder(group2, options3) {
          var text4 = new mathMLTree.TextNode(makeVerb(group2));
          var node2 = new mathMLTree.MathNode("mtext", [text4]);
          node2.setAttribute("mathvariant", "monospace");
          return node2;
        }
      });
      makeVerb = /* @__PURE__ */ __name((group2) => group2.body.replace(/ /g, group2.star ? "\u2423" : "\xA0"), "makeVerb");
      functions = _functions;
      spaceRegexString = "[ \r\n	]";
      controlWordRegexString = "\\\\[a-zA-Z@]+";
      controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
      controlWordWhitespaceRegexString = "(" + controlWordRegexString + ")" + spaceRegexString + "*";
      controlSpaceRegexString = "\\\\(\n|[ \r	]+\n?)[ \r	]*";
      combiningDiacriticalMarkString = "[\u0300-\u036F]";
      combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$");
      tokenRegexString = "(" + spaceRegexString + "+)|" + // whitespace
      (controlSpaceRegexString + "|") + // \whitespace
      "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + // single codepoint
      (combiningDiacriticalMarkString + "*") + // ...plus accents
      "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
      (combiningDiacriticalMarkString + "*") + // ...plus accents
      "|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
      ("|" + controlWordWhitespaceRegexString) + // \macroName + spaces
      ("|" + controlSymbolRegexString + ")");
      Lexer = class {
        static {
          __name(this, "Lexer");
        }
        // Category codes. The lexer only supports comment characters (14) for now.
        // MacroExpander additionally distinguishes active (13).
        constructor(input, settings) {
          this.input = void 0;
          this.settings = void 0;
          this.tokenRegex = void 0;
          this.catcodes = void 0;
          this.input = input;
          this.settings = settings;
          this.tokenRegex = new RegExp(tokenRegexString, "g");
          this.catcodes = {
            "%": 14,
            // comment character
            "~": 13
            // active character
          };
        }
        setCatcode(char2, code) {
          this.catcodes[char2] = code;
        }
        /**
         * This function lexes a single token.
         */
        lex() {
          var input = this.input;
          var pos = this.tokenRegex.lastIndex;
          if (pos === input.length) {
            return new Token("EOF", new SourceLocation(this, pos, pos));
          }
          var match2 = this.tokenRegex.exec(input);
          if (match2 === null || match2.index !== pos) {
            throw new ParseError("Unexpected character: '" + input[pos] + "'", new Token(input[pos], new SourceLocation(this, pos, pos + 1)));
          }
          var text4 = match2[6] || match2[3] || (match2[2] ? "\\ " : " ");
          if (this.catcodes[text4] === 14) {
            var nlIndex = input.indexOf("\n", this.tokenRegex.lastIndex);
            if (nlIndex === -1) {
              this.tokenRegex.lastIndex = input.length;
              this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)");
            } else {
              this.tokenRegex.lastIndex = nlIndex + 1;
            }
            return this.lex();
          }
          return new Token(text4, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
        }
      };
      Namespace = class {
        static {
          __name(this, "Namespace");
        }
        /**
         * Both arguments are optional.  The first argument is an object of
         * built-in mappings which never change.  The second argument is an object
         * of initial (global-level) mappings, which will constantly change
         * according to any global/top-level `set`s done.
         */
        constructor(builtins, globalMacros) {
          if (builtins === void 0) {
            builtins = {};
          }
          if (globalMacros === void 0) {
            globalMacros = {};
          }
          this.current = void 0;
          this.builtins = void 0;
          this.undefStack = void 0;
          this.current = globalMacros;
          this.builtins = builtins;
          this.undefStack = [];
        }
        /**
         * Start a new nested group, affecting future local `set`s.
         */
        beginGroup() {
          this.undefStack.push({});
        }
        /**
         * End current nested group, restoring values before the group began.
         */
        endGroup() {
          if (this.undefStack.length === 0) {
            throw new ParseError("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
          }
          var undefs = this.undefStack.pop();
          for (var undef2 in undefs) {
            if (undefs.hasOwnProperty(undef2)) {
              if (undefs[undef2] == null) {
                delete this.current[undef2];
              } else {
                this.current[undef2] = undefs[undef2];
              }
            }
          }
        }
        /**
         * Ends all currently nested groups (if any), restoring values before the
         * groups began.  Useful in case of an error in the middle of parsing.
         */
        endGroups() {
          while (this.undefStack.length > 0) {
            this.endGroup();
          }
        }
        /**
         * Detect whether `name` has a definition.  Equivalent to
         * `get(name) != null`.
         */
        has(name) {
          return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);
        }
        /**
         * Get the current value of a name, or `undefined` if there is no value.
         *
         * Note: Do not use `if (namespace.get(...))` to detect whether a macro
         * is defined, as the definition may be the empty string which evaluates
         * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
         * `if (namespace.has(...))`.
         */
        get(name) {
          if (this.current.hasOwnProperty(name)) {
            return this.current[name];
          } else {
            return this.builtins[name];
          }
        }
        /**
         * Set the current value of a name, and optionally set it globally too.
         * Local set() sets the current value and (when appropriate) adds an undo
         * operation to the undo stack.  Global set() may change the undo
         * operation at every level, so takes time linear in their number.
         * A value of undefined means to delete existing definitions.
         */
        set(name, value2, global2) {
          if (global2 === void 0) {
            global2 = false;
          }
          if (global2) {
            for (var i2 = 0; i2 < this.undefStack.length; i2++) {
              delete this.undefStack[i2][name];
            }
            if (this.undefStack.length > 0) {
              this.undefStack[this.undefStack.length - 1][name] = value2;
            }
          } else {
            var top2 = this.undefStack[this.undefStack.length - 1];
            if (top2 && !top2.hasOwnProperty(name)) {
              top2[name] = this.current[name];
            }
          }
          if (value2 == null) {
            delete this.current[name];
          } else {
            this.current[name] = value2;
          }
        }
      };
      macros = _macros;
      defineMacro("\\noexpand", function(context) {
        var t4 = context.popToken();
        if (context.isExpandable(t4.text)) {
          t4.noexpand = true;
          t4.treatAsRelax = true;
        }
        return {
          tokens: [t4],
          numArgs: 0
        };
      });
      defineMacro("\\expandafter", function(context) {
        var t4 = context.popToken();
        context.expandOnce(true);
        return {
          tokens: [t4],
          numArgs: 0
        };
      });
      defineMacro("\\@firstoftwo", function(context) {
        var args = context.consumeArgs(2);
        return {
          tokens: args[0],
          numArgs: 0
        };
      });
      defineMacro("\\@secondoftwo", function(context) {
        var args = context.consumeArgs(2);
        return {
          tokens: args[1],
          numArgs: 0
        };
      });
      defineMacro("\\@ifnextchar", function(context) {
        var args = context.consumeArgs(3);
        context.consumeSpaces();
        var nextToken = context.future();
        if (args[0].length === 1 && args[0][0].text === nextToken.text) {
          return {
            tokens: args[1],
            numArgs: 0
          };
        } else {
          return {
            tokens: args[2],
            numArgs: 0
          };
        }
      });
      defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
      defineMacro("\\TextOrMath", function(context) {
        var args = context.consumeArgs(2);
        if (context.mode === "text") {
          return {
            tokens: args[0],
            numArgs: 0
          };
        } else {
          return {
            tokens: args[1],
            numArgs: 0
          };
        }
      });
      digitToNumber = {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7,
        "8": 8,
        "9": 9,
        "a": 10,
        "A": 10,
        "b": 11,
        "B": 11,
        "c": 12,
        "C": 12,
        "d": 13,
        "D": 13,
        "e": 14,
        "E": 14,
        "f": 15,
        "F": 15
      };
      defineMacro("\\char", function(context) {
        var token2 = context.popToken();
        var base;
        var number7 = "";
        if (token2.text === "'") {
          base = 8;
          token2 = context.popToken();
        } else if (token2.text === '"') {
          base = 16;
          token2 = context.popToken();
        } else if (token2.text === "`") {
          token2 = context.popToken();
          if (token2.text[0] === "\\") {
            number7 = token2.text.charCodeAt(1);
          } else if (token2.text === "EOF") {
            throw new ParseError("\\char` missing argument");
          } else {
            number7 = token2.text.charCodeAt(0);
          }
        } else {
          base = 10;
        }
        if (base) {
          number7 = digitToNumber[token2.text];
          if (number7 == null || number7 >= base) {
            throw new ParseError("Invalid base-" + base + " digit " + token2.text);
          }
          var digit;
          while ((digit = digitToNumber[context.future().text]) != null && digit < base) {
            number7 *= base;
            number7 += digit;
            context.popToken();
          }
        }
        return "\\@char{" + number7 + "}";
      });
      newcommand = /* @__PURE__ */ __name((context, existsOK, nonexistsOK) => {
        var arg = context.consumeArg().tokens;
        if (arg.length !== 1) {
          throw new ParseError("\\newcommand's first argument must be a macro name");
        }
        var name = arg[0].text;
        var exists2 = context.isDefined(name);
        if (exists2 && !existsOK) {
          throw new ParseError("\\newcommand{" + name + "} attempting to redefine " + (name + "; use \\renewcommand"));
        }
        if (!exists2 && !nonexistsOK) {
          throw new ParseError("\\renewcommand{" + name + "} when command " + name + " does not yet exist; use \\newcommand");
        }
        var numArgs = 0;
        arg = context.consumeArg().tokens;
        if (arg.length === 1 && arg[0].text === "[") {
          var argText = "";
          var token2 = context.expandNextToken();
          while (token2.text !== "]" && token2.text !== "EOF") {
            argText += token2.text;
            token2 = context.expandNextToken();
          }
          if (!argText.match(/^\s*[0-9]+\s*$/)) {
            throw new ParseError("Invalid number of arguments: " + argText);
          }
          numArgs = parseInt(argText);
          arg = context.consumeArg().tokens;
        }
        context.macros.set(name, {
          tokens: arg,
          numArgs
        });
        return "";
      }, "newcommand");
      defineMacro("\\newcommand", (context) => newcommand(context, false, true));
      defineMacro("\\renewcommand", (context) => newcommand(context, true, false));
      defineMacro("\\providecommand", (context) => newcommand(context, true, true));
      defineMacro("\\message", (context) => {
        var arg = context.consumeArgs(1)[0];
        console.log(arg.reverse().map((token2) => token2.text).join(""));
        return "";
      });
      defineMacro("\\errmessage", (context) => {
        var arg = context.consumeArgs(1)[0];
        console.error(arg.reverse().map((token2) => token2.text).join(""));
        return "";
      });
      defineMacro("\\show", (context) => {
        var tok = context.popToken();
        var name = tok.text;
        console.log(tok, context.macros.get(name), functions[name], symbols.math[name], symbols.text[name]);
        return "";
      });
      defineMacro("\\bgroup", "{");
      defineMacro("\\egroup", "}");
      defineMacro("~", "\\nobreakspace");
      defineMacro("\\lq", "`");
      defineMacro("\\rq", "'");
      defineMacro("\\aa", "\\r a");
      defineMacro("\\AA", "\\r A");
      defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`\xA9}");
      defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
      defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`\xAE}");
      defineMacro("\u212C", "\\mathscr{B}");
      defineMacro("\u2130", "\\mathscr{E}");
      defineMacro("\u2131", "\\mathscr{F}");
      defineMacro("\u210B", "\\mathscr{H}");
      defineMacro("\u2110", "\\mathscr{I}");
      defineMacro("\u2112", "\\mathscr{L}");
      defineMacro("\u2133", "\\mathscr{M}");
      defineMacro("\u211B", "\\mathscr{R}");
      defineMacro("\u212D", "\\mathfrak{C}");
      defineMacro("\u210C", "\\mathfrak{H}");
      defineMacro("\u2128", "\\mathfrak{Z}");
      defineMacro("\\Bbbk", "\\Bbb{k}");
      defineMacro("\xB7", "\\cdotp");
      defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
      defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
      defineMacro("\\clap", "\\mathclap{\\textrm{#1}}");
      defineMacro("\\mathstrut", "\\vphantom{(}");
      defineMacro("\\underbar", "\\underline{\\text{#1}}");
      defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
      defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`\u2260}}");
      defineMacro("\\ne", "\\neq");
      defineMacro("\u2260", "\\neq");
      defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`\u2209}}");
      defineMacro("\u2209", "\\notin");
      defineMacro("\u2258", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`\u2258}}");
      defineMacro("\u2259", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}");
      defineMacro("\u225A", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}");
      defineMacro("\u225B", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`\u225B}}");
      defineMacro("\u225D", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`\u225D}}");
      defineMacro("\u225E", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`\u225E}}");
      defineMacro("\u225F", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}");
      defineMacro("\u27C2", "\\perp");
      defineMacro("\u203C", "\\mathclose{!\\mkern-0.8mu!}");
      defineMacro("\u220C", "\\notni");
      defineMacro("\u231C", "\\ulcorner");
      defineMacro("\u231D", "\\urcorner");
      defineMacro("\u231E", "\\llcorner");
      defineMacro("\u231F", "\\lrcorner");
      defineMacro("\xA9", "\\copyright");
      defineMacro("\xAE", "\\textregistered");
      defineMacro("\uFE0F", "\\textregistered");
      defineMacro("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
      defineMacro("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
      defineMacro("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
      defineMacro("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
      defineMacro("\\vdots", "\\mathord{\\varvdots\\rule{0pt}{15pt}}");
      defineMacro("\u22EE", "\\vdots");
      defineMacro("\\varGamma", "\\mathit{\\Gamma}");
      defineMacro("\\varDelta", "\\mathit{\\Delta}");
      defineMacro("\\varTheta", "\\mathit{\\Theta}");
      defineMacro("\\varLambda", "\\mathit{\\Lambda}");
      defineMacro("\\varXi", "\\mathit{\\Xi}");
      defineMacro("\\varPi", "\\mathit{\\Pi}");
      defineMacro("\\varSigma", "\\mathit{\\Sigma}");
      defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
      defineMacro("\\varPhi", "\\mathit{\\Phi}");
      defineMacro("\\varPsi", "\\mathit{\\Psi}");
      defineMacro("\\varOmega", "\\mathit{\\Omega}");
      defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
      defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
      defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
      defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
      defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
      defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
      dotsByToken = {
        ",": "\\dotsc",
        "\\not": "\\dotsb",
        // \keybin@ checks for the following:
        "+": "\\dotsb",
        "=": "\\dotsb",
        "<": "\\dotsb",
        ">": "\\dotsb",
        "-": "\\dotsb",
        "*": "\\dotsb",
        ":": "\\dotsb",
        // Symbols whose definition starts with \DOTSB:
        "\\DOTSB": "\\dotsb",
        "\\coprod": "\\dotsb",
        "\\bigvee": "\\dotsb",
        "\\bigwedge": "\\dotsb",
        "\\biguplus": "\\dotsb",
        "\\bigcap": "\\dotsb",
        "\\bigcup": "\\dotsb",
        "\\prod": "\\dotsb",
        "\\sum": "\\dotsb",
        "\\bigotimes": "\\dotsb",
        "\\bigoplus": "\\dotsb",
        "\\bigodot": "\\dotsb",
        "\\bigsqcup": "\\dotsb",
        "\\And": "\\dotsb",
        "\\longrightarrow": "\\dotsb",
        "\\Longrightarrow": "\\dotsb",
        "\\longleftarrow": "\\dotsb",
        "\\Longleftarrow": "\\dotsb",
        "\\longleftrightarrow": "\\dotsb",
        "\\Longleftrightarrow": "\\dotsb",
        "\\mapsto": "\\dotsb",
        "\\longmapsto": "\\dotsb",
        "\\hookrightarrow": "\\dotsb",
        "\\doteq": "\\dotsb",
        // Symbols whose definition starts with \mathbin:
        "\\mathbin": "\\dotsb",
        // Symbols whose definition starts with \mathrel:
        "\\mathrel": "\\dotsb",
        "\\relbar": "\\dotsb",
        "\\Relbar": "\\dotsb",
        "\\xrightarrow": "\\dotsb",
        "\\xleftarrow": "\\dotsb",
        // Symbols whose definition starts with \DOTSI:
        "\\DOTSI": "\\dotsi",
        "\\int": "\\dotsi",
        "\\oint": "\\dotsi",
        "\\iint": "\\dotsi",
        "\\iiint": "\\dotsi",
        "\\iiiint": "\\dotsi",
        "\\idotsint": "\\dotsi",
        // Symbols whose definition starts with \DOTSX:
        "\\DOTSX": "\\dotsx"
      };
      defineMacro("\\dots", function(context) {
        var thedots = "\\dotso";
        var next3 = context.expandAfterFuture().text;
        if (next3 in dotsByToken) {
          thedots = dotsByToken[next3];
        } else if (next3.slice(0, 4) === "\\not") {
          thedots = "\\dotsb";
        } else if (next3 in symbols.math) {
          if (utils.contains(["bin", "rel"], symbols.math[next3].group)) {
            thedots = "\\dotsb";
          }
        }
        return thedots;
      });
      spaceAfterDots = {
        // \rightdelim@ checks for the following:
        ")": true,
        "]": true,
        "\\rbrack": true,
        "\\}": true,
        "\\rbrace": true,
        "\\rangle": true,
        "\\rceil": true,
        "\\rfloor": true,
        "\\rgroup": true,
        "\\rmoustache": true,
        "\\right": true,
        "\\bigr": true,
        "\\biggr": true,
        "\\Bigr": true,
        "\\Biggr": true,
        // \extra@ also tests for the following:
        "$": true,
        // \extrap@ checks for the following:
        ";": true,
        ".": true,
        ",": true
      };
      defineMacro("\\dotso", function(context) {
        var next3 = context.future().text;
        if (next3 in spaceAfterDots) {
          return "\\ldots\\,";
        } else {
          return "\\ldots";
        }
      });
      defineMacro("\\dotsc", function(context) {
        var next3 = context.future().text;
        if (next3 in spaceAfterDots && next3 !== ",") {
          return "\\ldots\\,";
        } else {
          return "\\ldots";
        }
      });
      defineMacro("\\cdots", function(context) {
        var next3 = context.future().text;
        if (next3 in spaceAfterDots) {
          return "\\@cdots\\,";
        } else {
          return "\\@cdots";
        }
      });
      defineMacro("\\dotsb", "\\cdots");
      defineMacro("\\dotsm", "\\cdots");
      defineMacro("\\dotsi", "\\!\\cdots");
      defineMacro("\\dotsx", "\\ldots\\,");
      defineMacro("\\DOTSI", "\\relax");
      defineMacro("\\DOTSB", "\\relax");
      defineMacro("\\DOTSX", "\\relax");
      defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
      defineMacro("\\,", "\\tmspace+{3mu}{.1667em}");
      defineMacro("\\thinspace", "\\,");
      defineMacro("\\>", "\\mskip{4mu}");
      defineMacro("\\:", "\\tmspace+{4mu}{.2222em}");
      defineMacro("\\medspace", "\\:");
      defineMacro("\\;", "\\tmspace+{5mu}{.2777em}");
      defineMacro("\\thickspace", "\\;");
      defineMacro("\\!", "\\tmspace-{3mu}{.1667em}");
      defineMacro("\\negthinspace", "\\!");
      defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
      defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}");
      defineMacro("\\enspace", "\\kern.5em ");
      defineMacro("\\enskip", "\\hskip.5em\\relax");
      defineMacro("\\quad", "\\hskip1em\\relax");
      defineMacro("\\qquad", "\\hskip2em\\relax");
      defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
      defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
      defineMacro("\\tag@literal", (context) => {
        if (context.macros.get("\\df@tag")) {
          throw new ParseError("Multiple \\tag");
        }
        return "\\gdef\\df@tag{\\text{#1}}";
      });
      defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
      defineMacro("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
      defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
      defineMacro("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
      defineMacro("\\newline", "\\\\\\relax");
      defineMacro("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
      latexRaiseA = makeEm(fontMetricsData["Main-Regular"]["T".charCodeAt(0)][1] - 0.7 * fontMetricsData["Main-Regular"]["A".charCodeAt(0)][1]);
      defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
      defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
      defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
      defineMacro("\\@hspace", "\\hskip #1\\relax");
      defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
      defineMacro("\\ordinarycolon", ":");
      defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
      defineMacro("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
      defineMacro("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
      defineMacro("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
      defineMacro("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
      defineMacro("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
      defineMacro("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
      defineMacro("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
      defineMacro("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
      defineMacro("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
      defineMacro("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
      defineMacro("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
      defineMacro("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
      defineMacro("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
      defineMacro("\u2237", "\\dblcolon");
      defineMacro("\u2239", "\\eqcolon");
      defineMacro("\u2254", "\\coloneqq");
      defineMacro("\u2255", "\\eqqcolon");
      defineMacro("\u2A74", "\\Coloneqq");
      defineMacro("\\ratio", "\\vcentcolon");
      defineMacro("\\coloncolon", "\\dblcolon");
      defineMacro("\\colonequals", "\\coloneqq");
      defineMacro("\\coloncolonequals", "\\Coloneqq");
      defineMacro("\\equalscolon", "\\eqqcolon");
      defineMacro("\\equalscoloncolon", "\\Eqqcolon");
      defineMacro("\\colonminus", "\\coloneq");
      defineMacro("\\coloncolonminus", "\\Coloneq");
      defineMacro("\\minuscolon", "\\eqcolon");
      defineMacro("\\minuscoloncolon", "\\Eqcolon");
      defineMacro("\\coloncolonapprox", "\\Colonapprox");
      defineMacro("\\coloncolonsim", "\\Colonsim");
      defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
      defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
      defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
      defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
      defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}");
      defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
      defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
      defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
      defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
      defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
      defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
      defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
      defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
      defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{\u2269}");
      defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{\u2268}");
      defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{\u2271}");
      defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{\u2271}");
      defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{\u2270}");
      defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{\u2270}");
      defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{\u2224}");
      defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{\u2226}");
      defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{\u2288}");
      defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{\u2289}");
      defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{\u228A}");
      defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{\u2ACB}");
      defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{\u228B}");
      defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{\u2ACC}");
      defineMacro("\\imath", "\\html@mathml{\\@imath}{\u0131}");
      defineMacro("\\jmath", "\\html@mathml{\\@jmath}{\u0237}");
      defineMacro("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`\u27E6}}");
      defineMacro("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`\u27E7}}");
      defineMacro("\u27E6", "\\llbracket");
      defineMacro("\u27E7", "\\rrbracket");
      defineMacro("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`\u2983}}");
      defineMacro("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`\u2984}}");
      defineMacro("\u2983", "\\lBrace");
      defineMacro("\u2984", "\\rBrace");
      defineMacro("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`\u29B5}}");
      defineMacro("\u29B5", "\\minuso");
      defineMacro("\\darr", "\\downarrow");
      defineMacro("\\dArr", "\\Downarrow");
      defineMacro("\\Darr", "\\Downarrow");
      defineMacro("\\lang", "\\langle");
      defineMacro("\\rang", "\\rangle");
      defineMacro("\\uarr", "\\uparrow");
      defineMacro("\\uArr", "\\Uparrow");
      defineMacro("\\Uarr", "\\Uparrow");
      defineMacro("\\N", "\\mathbb{N}");
      defineMacro("\\R", "\\mathbb{R}");
      defineMacro("\\Z", "\\mathbb{Z}");
      defineMacro("\\alef", "\\aleph");
      defineMacro("\\alefsym", "\\aleph");
      defineMacro("\\Alpha", "\\mathrm{A}");
      defineMacro("\\Beta", "\\mathrm{B}");
      defineMacro("\\bull", "\\bullet");
      defineMacro("\\Chi", "\\mathrm{X}");
      defineMacro("\\clubs", "\\clubsuit");
      defineMacro("\\cnums", "\\mathbb{C}");
      defineMacro("\\Complex", "\\mathbb{C}");
      defineMacro("\\Dagger", "\\ddagger");
      defineMacro("\\diamonds", "\\diamondsuit");
      defineMacro("\\empty", "\\emptyset");
      defineMacro("\\Epsilon", "\\mathrm{E}");
      defineMacro("\\Eta", "\\mathrm{H}");
      defineMacro("\\exist", "\\exists");
      defineMacro("\\harr", "\\leftrightarrow");
      defineMacro("\\hArr", "\\Leftrightarrow");
      defineMacro("\\Harr", "\\Leftrightarrow");
      defineMacro("\\hearts", "\\heartsuit");
      defineMacro("\\image", "\\Im");
      defineMacro("\\infin", "\\infty");
      defineMacro("\\Iota", "\\mathrm{I}");
      defineMacro("\\isin", "\\in");
      defineMacro("\\Kappa", "\\mathrm{K}");
      defineMacro("\\larr", "\\leftarrow");
      defineMacro("\\lArr", "\\Leftarrow");
      defineMacro("\\Larr", "\\Leftarrow");
      defineMacro("\\lrarr", "\\leftrightarrow");
      defineMacro("\\lrArr", "\\Leftrightarrow");
      defineMacro("\\Lrarr", "\\Leftrightarrow");
      defineMacro("\\Mu", "\\mathrm{M}");
      defineMacro("\\natnums", "\\mathbb{N}");
      defineMacro("\\Nu", "\\mathrm{N}");
      defineMacro("\\Omicron", "\\mathrm{O}");
      defineMacro("\\plusmn", "\\pm");
      defineMacro("\\rarr", "\\rightarrow");
      defineMacro("\\rArr", "\\Rightarrow");
      defineMacro("\\Rarr", "\\Rightarrow");
      defineMacro("\\real", "\\Re");
      defineMacro("\\reals", "\\mathbb{R}");
      defineMacro("\\Reals", "\\mathbb{R}");
      defineMacro("\\Rho", "\\mathrm{P}");
      defineMacro("\\sdot", "\\cdot");
      defineMacro("\\sect", "\\S");
      defineMacro("\\spades", "\\spadesuit");
      defineMacro("\\sub", "\\subset");
      defineMacro("\\sube", "\\subseteq");
      defineMacro("\\supe", "\\supseteq");
      defineMacro("\\Tau", "\\mathrm{T}");
      defineMacro("\\thetasym", "\\vartheta");
      defineMacro("\\weierp", "\\wp");
      defineMacro("\\Zeta", "\\mathrm{Z}");
      defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
      defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
      defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
      defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
      defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
      defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
      defineMacro("\\Bra", "\\left\\langle#1\\right|");
      defineMacro("\\Ket", "\\left|#1\\right\\rangle");
      braketHelper = /* @__PURE__ */ __name((one4) => (context) => {
        var left3 = context.consumeArg().tokens;
        var middle = context.consumeArg().tokens;
        var middleDouble = context.consumeArg().tokens;
        var right3 = context.consumeArg().tokens;
        var oldMiddle = context.macros.get("|");
        var oldMiddleDouble = context.macros.get("\\|");
        context.macros.beginGroup();
        var midMacro = /* @__PURE__ */ __name((double) => (context2) => {
          if (one4) {
            context2.macros.set("|", oldMiddle);
            if (middleDouble.length) {
              context2.macros.set("\\|", oldMiddleDouble);
            }
          }
          var doubled = double;
          if (!double && middleDouble.length) {
            var nextToken = context2.future();
            if (nextToken.text === "|") {
              context2.popToken();
              doubled = true;
            }
          }
          return {
            tokens: doubled ? middleDouble : middle,
            numArgs: 0
          };
        }, "midMacro");
        context.macros.set("|", midMacro(false));
        if (middleDouble.length) {
          context.macros.set("\\|", midMacro(true));
        }
        var arg = context.consumeArg().tokens;
        var expanded = context.expandTokens([
          ...right3,
          ...arg,
          ...left3
          // reversed
        ]);
        context.macros.endGroup();
        return {
          tokens: expanded.reverse(),
          numArgs: 0
        };
      }, "braketHelper");
      defineMacro("\\bra@ket", braketHelper(false));
      defineMacro("\\bra@set", braketHelper(true));
      defineMacro("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
      defineMacro("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
      defineMacro("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
      defineMacro("\\angln", "{\\angl n}");
      defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
      defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
      defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
      defineMacro("\\red", "\\textcolor{##df0030}{#1}");
      defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
      defineMacro("\\gray", "\\textcolor{gray}{#1}");
      defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
      defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
      defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
      defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
      defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
      defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
      defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
      defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
      defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
      defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
      defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
      defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
      defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
      defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
      defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
      defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
      defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
      defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
      defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
      defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
      defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
      defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
      defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
      defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
      defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
      defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
      defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
      defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
      defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
      defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
      defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
      defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
      defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
      defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
      defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
      defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
      defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
      defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
      defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
      defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
      defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
      defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
      defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
      defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
      defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
      defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
      defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
      defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
      defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
      defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
      implicitCommands = {
        "^": true,
        // Parser.js
        "_": true,
        // Parser.js
        "\\limits": true,
        // Parser.js
        "\\nolimits": true
        // Parser.js
      };
      MacroExpander = class {
        static {
          __name(this, "MacroExpander");
        }
        constructor(input, settings, mode) {
          this.settings = void 0;
          this.expansionCount = void 0;
          this.lexer = void 0;
          this.macros = void 0;
          this.stack = void 0;
          this.mode = void 0;
          this.settings = settings;
          this.expansionCount = 0;
          this.feed(input);
          this.macros = new Namespace(macros, settings.macros);
          this.mode = mode;
          this.stack = [];
        }
        /**
         * Feed a new input string to the same MacroExpander
         * (with existing macros etc.).
         */
        feed(input) {
          this.lexer = new Lexer(input, this.settings);
        }
        /**
         * Switches between "text" and "math" modes.
         */
        switchMode(newMode) {
          this.mode = newMode;
        }
        /**
         * Start a new group nesting within all namespaces.
         */
        beginGroup() {
          this.macros.beginGroup();
        }
        /**
         * End current group nesting within all namespaces.
         */
        endGroup() {
          this.macros.endGroup();
        }
        /**
         * Ends all currently nested groups (if any), restoring values before the
         * groups began.  Useful in case of an error in the middle of parsing.
         */
        endGroups() {
          this.macros.endGroups();
        }
        /**
         * Returns the topmost token on the stack, without expanding it.
         * Similar in behavior to TeX's `\futurelet`.
         */
        future() {
          if (this.stack.length === 0) {
            this.pushToken(this.lexer.lex());
          }
          return this.stack[this.stack.length - 1];
        }
        /**
         * Remove and return the next unexpanded token.
         */
        popToken() {
          this.future();
          return this.stack.pop();
        }
        /**
         * Add a given token to the token stack.  In particular, this get be used
         * to put back a token returned from one of the other methods.
         */
        pushToken(token2) {
          this.stack.push(token2);
        }
        /**
         * Append an array of tokens to the token stack.
         */
        pushTokens(tokens2) {
          this.stack.push(...tokens2);
        }
        /**
         * Find an macro argument without expanding tokens and append the array of
         * tokens to the token stack. Uses Token as a container for the result.
         */
        scanArgument(isOptional) {
          var start3;
          var end2;
          var tokens2;
          if (isOptional) {
            this.consumeSpaces();
            if (this.future().text !== "[") {
              return null;
            }
            start3 = this.popToken();
            ({
              tokens: tokens2,
              end: end2
            } = this.consumeArg(["]"]));
          } else {
            ({
              tokens: tokens2,
              start: start3,
              end: end2
            } = this.consumeArg());
          }
          this.pushToken(new Token("EOF", end2.loc));
          this.pushTokens(tokens2);
          return start3.range(end2, "");
        }
        /**
         * Consume all following space tokens, without expansion.
         */
        consumeSpaces() {
          for (; ; ) {
            var token2 = this.future();
            if (token2.text === " ") {
              this.stack.pop();
            } else {
              break;
            }
          }
        }
        /**
         * Consume an argument from the token stream, and return the resulting array
         * of tokens and start/end token.
         */
        consumeArg(delims) {
          var tokens2 = [];
          var isDelimited = delims && delims.length > 0;
          if (!isDelimited) {
            this.consumeSpaces();
          }
          var start3 = this.future();
          var tok;
          var depth = 0;
          var match2 = 0;
          do {
            tok = this.popToken();
            tokens2.push(tok);
            if (tok.text === "{") {
              ++depth;
            } else if (tok.text === "}") {
              --depth;
              if (depth === -1) {
                throw new ParseError("Extra }", tok);
              }
            } else if (tok.text === "EOF") {
              throw new ParseError("Unexpected end of input in a macro argument, expected '" + (delims && isDelimited ? delims[match2] : "}") + "'", tok);
            }
            if (delims && isDelimited) {
              if ((depth === 0 || depth === 1 && delims[match2] === "{") && tok.text === delims[match2]) {
                ++match2;
                if (match2 === delims.length) {
                  tokens2.splice(-match2, match2);
                  break;
                }
              } else {
                match2 = 0;
              }
            }
          } while (depth !== 0 || isDelimited);
          if (start3.text === "{" && tokens2[tokens2.length - 1].text === "}") {
            tokens2.pop();
            tokens2.shift();
          }
          tokens2.reverse();
          return {
            tokens: tokens2,
            start: start3,
            end: tok
          };
        }
        /**
         * Consume the specified number of (delimited) arguments from the token
         * stream and return the resulting array of arguments.
         */
        consumeArgs(numArgs, delimiters2) {
          if (delimiters2) {
            if (delimiters2.length !== numArgs + 1) {
              throw new ParseError("The length of delimiters doesn't match the number of args!");
            }
            var delims = delimiters2[0];
            for (var i2 = 0; i2 < delims.length; i2++) {
              var tok = this.popToken();
              if (delims[i2] !== tok.text) {
                throw new ParseError("Use of the macro doesn't match its definition", tok);
              }
            }
          }
          var args = [];
          for (var _i = 0; _i < numArgs; _i++) {
            args.push(this.consumeArg(delimiters2 && delimiters2[_i + 1]).tokens);
          }
          return args;
        }
        /**
         * Increment `expansionCount` by the specified amount.
         * Throw an error if it exceeds `maxExpand`.
         */
        countExpansion(amount) {
          this.expansionCount += amount;
          if (this.expansionCount > this.settings.maxExpand) {
            throw new ParseError("Too many expansions: infinite loop or need to increase maxExpand setting");
          }
        }
        /**
         * Expand the next token only once if possible.
         *
         * If the token is expanded, the resulting tokens will be pushed onto
         * the stack in reverse order, and the number of such tokens will be
         * returned.  This number might be zero or positive.
         *
         * If not, the return value is `false`, and the next token remains at the
         * top of the stack.
         *
         * In either case, the next token will be on the top of the stack,
         * or the stack will be empty (in case of empty expansion
         * and no other tokens).
         *
         * Used to implement `expandAfterFuture` and `expandNextToken`.
         *
         * If expandableOnly, only expandable tokens are expanded and
         * an undefined control sequence results in an error.
         */
        expandOnce(expandableOnly) {
          var topToken = this.popToken();
          var name = topToken.text;
          var expansion = !topToken.noexpand ? this._getExpansion(name) : null;
          if (expansion == null || expandableOnly && expansion.unexpandable) {
            if (expandableOnly && expansion == null && name[0] === "\\" && !this.isDefined(name)) {
              throw new ParseError("Undefined control sequence: " + name);
            }
            this.pushToken(topToken);
            return false;
          }
          this.countExpansion(1);
          var tokens2 = expansion.tokens;
          var args = this.consumeArgs(expansion.numArgs, expansion.delimiters);
          if (expansion.numArgs) {
            tokens2 = tokens2.slice();
            for (var i2 = tokens2.length - 1; i2 >= 0; --i2) {
              var tok = tokens2[i2];
              if (tok.text === "#") {
                if (i2 === 0) {
                  throw new ParseError("Incomplete placeholder at end of macro body", tok);
                }
                tok = tokens2[--i2];
                if (tok.text === "#") {
                  tokens2.splice(i2 + 1, 1);
                } else if (/^[1-9]$/.test(tok.text)) {
                  tokens2.splice(i2, 2, ...args[+tok.text - 1]);
                } else {
                  throw new ParseError("Not a valid argument number", tok);
                }
              }
            }
          }
          this.pushTokens(tokens2);
          return tokens2.length;
        }
        /**
         * Expand the next token only once (if possible), and return the resulting
         * top token on the stack (without removing anything from the stack).
         * Similar in behavior to TeX's `\expandafter\futurelet`.
         * Equivalent to expandOnce() followed by future().
         */
        expandAfterFuture() {
          this.expandOnce();
          return this.future();
        }
        /**
         * Recursively expand first token, then return first non-expandable token.
         */
        expandNextToken() {
          for (; ; ) {
            if (this.expandOnce() === false) {
              var token2 = this.stack.pop();
              if (token2.treatAsRelax) {
                token2.text = "\\relax";
              }
              return token2;
            }
          }
          throw new Error();
        }
        /**
         * Fully expand the given macro name and return the resulting list of
         * tokens, or return `undefined` if no such macro is defined.
         */
        expandMacro(name) {
          return this.macros.has(name) ? this.expandTokens([new Token(name)]) : void 0;
        }
        /**
         * Fully expand the given token stream and return the resulting list of
         * tokens.  Note that the input tokens are in reverse order, but the
         * output tokens are in forward order.
         */
        expandTokens(tokens2) {
          var output2 = [];
          var oldStackLength = this.stack.length;
          this.pushTokens(tokens2);
          while (this.stack.length > oldStackLength) {
            if (this.expandOnce(true) === false) {
              var token2 = this.stack.pop();
              if (token2.treatAsRelax) {
                token2.noexpand = false;
                token2.treatAsRelax = false;
              }
              output2.push(token2);
            }
          }
          this.countExpansion(output2.length);
          return output2;
        }
        /**
         * Fully expand the given macro name and return the result as a string,
         * or return `undefined` if no such macro is defined.
         */
        expandMacroAsText(name) {
          var tokens2 = this.expandMacro(name);
          if (tokens2) {
            return tokens2.map((token2) => token2.text).join("");
          } else {
            return tokens2;
          }
        }
        /**
         * Returns the expanded macro as a reversed array of tokens and a macro
         * argument count.  Or returns `null` if no such macro.
         */
        _getExpansion(name) {
          var definition = this.macros.get(name);
          if (definition == null) {
            return definition;
          }
          if (name.length === 1) {
            var catcode = this.lexer.catcodes[name];
            if (catcode != null && catcode !== 13) {
              return;
            }
          }
          var expansion = typeof definition === "function" ? definition(this) : definition;
          if (typeof expansion === "string") {
            var numArgs = 0;
            if (expansion.indexOf("#") !== -1) {
              var stripped = expansion.replace(/##/g, "");
              while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
                ++numArgs;
              }
            }
            var bodyLexer = new Lexer(expansion, this.settings);
            var tokens2 = [];
            var tok = bodyLexer.lex();
            while (tok.text !== "EOF") {
              tokens2.push(tok);
              tok = bodyLexer.lex();
            }
            tokens2.reverse();
            var expanded = {
              tokens: tokens2,
              numArgs
            };
            return expanded;
          }
          return expansion;
        }
        /**
         * Determine whether a command is currently "defined" (has some
         * functionality), meaning that it's a macro (in the current group),
         * a function, a symbol, or one of the special commands listed in
         * `implicitCommands`.
         */
        isDefined(name) {
          return this.macros.has(name) || functions.hasOwnProperty(name) || symbols.math.hasOwnProperty(name) || symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);
        }
        /**
         * Determine whether a command is expandable.
         */
        isExpandable(name) {
          var macro = this.macros.get(name);
          return macro != null ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable : functions.hasOwnProperty(name) && !functions[name].primitive;
        }
      };
      unicodeSubRegEx = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/;
      uSubsAndSups = Object.freeze({
        "\u208A": "+",
        "\u208B": "-",
        "\u208C": "=",
        "\u208D": "(",
        "\u208E": ")",
        "\u2080": "0",
        "\u2081": "1",
        "\u2082": "2",
        "\u2083": "3",
        "\u2084": "4",
        "\u2085": "5",
        "\u2086": "6",
        "\u2087": "7",
        "\u2088": "8",
        "\u2089": "9",
        "\u2090": "a",
        "\u2091": "e",
        "\u2095": "h",
        "\u1D62": "i",
        "\u2C7C": "j",
        "\u2096": "k",
        "\u2097": "l",
        "\u2098": "m",
        "\u2099": "n",
        "\u2092": "o",
        "\u209A": "p",
        "\u1D63": "r",
        "\u209B": "s",
        "\u209C": "t",
        "\u1D64": "u",
        "\u1D65": "v",
        "\u2093": "x",
        "\u1D66": "\u03B2",
        "\u1D67": "\u03B3",
        "\u1D68": "\u03C1",
        "\u1D69": "\u03D5",
        "\u1D6A": "\u03C7",
        "\u207A": "+",
        "\u207B": "-",
        "\u207C": "=",
        "\u207D": "(",
        "\u207E": ")",
        "\u2070": "0",
        "\xB9": "1",
        "\xB2": "2",
        "\xB3": "3",
        "\u2074": "4",
        "\u2075": "5",
        "\u2076": "6",
        "\u2077": "7",
        "\u2078": "8",
        "\u2079": "9",
        "\u1D2C": "A",
        "\u1D2E": "B",
        "\u1D30": "D",
        "\u1D31": "E",
        "\u1D33": "G",
        "\u1D34": "H",
        "\u1D35": "I",
        "\u1D36": "J",
        "\u1D37": "K",
        "\u1D38": "L",
        "\u1D39": "M",
        "\u1D3A": "N",
        "\u1D3C": "O",
        "\u1D3E": "P",
        "\u1D3F": "R",
        "\u1D40": "T",
        "\u1D41": "U",
        "\u2C7D": "V",
        "\u1D42": "W",
        "\u1D43": "a",
        "\u1D47": "b",
        "\u1D9C": "c",
        "\u1D48": "d",
        "\u1D49": "e",
        "\u1DA0": "f",
        "\u1D4D": "g",
        "\u02B0": "h",
        "\u2071": "i",
        "\u02B2": "j",
        "\u1D4F": "k",
        "\u02E1": "l",
        "\u1D50": "m",
        "\u207F": "n",
        "\u1D52": "o",
        "\u1D56": "p",
        "\u02B3": "r",
        "\u02E2": "s",
        "\u1D57": "t",
        "\u1D58": "u",
        "\u1D5B": "v",
        "\u02B7": "w",
        "\u02E3": "x",
        "\u02B8": "y",
        "\u1DBB": "z",
        "\u1D5D": "\u03B2",
        "\u1D5E": "\u03B3",
        "\u1D5F": "\u03B4",
        "\u1D60": "\u03D5",
        "\u1D61": "\u03C7",
        "\u1DBF": "\u03B8"
      });
      unicodeAccents = {
        "\u0301": {
          "text": "\\'",
          "math": "\\acute"
        },
        "\u0300": {
          "text": "\\`",
          "math": "\\grave"
        },
        "\u0308": {
          "text": '\\"',
          "math": "\\ddot"
        },
        "\u0303": {
          "text": "\\~",
          "math": "\\tilde"
        },
        "\u0304": {
          "text": "\\=",
          "math": "\\bar"
        },
        "\u0306": {
          "text": "\\u",
          "math": "\\breve"
        },
        "\u030C": {
          "text": "\\v",
          "math": "\\check"
        },
        "\u0302": {
          "text": "\\^",
          "math": "\\hat"
        },
        "\u0307": {
          "text": "\\.",
          "math": "\\dot"
        },
        "\u030A": {
          "text": "\\r",
          "math": "\\mathring"
        },
        "\u030B": {
          "text": "\\H"
        },
        "\u0327": {
          "text": "\\c"
        }
      };
      unicodeSymbols = {
        "\xE1": "a\u0301",
        "\xE0": "a\u0300",
        "\xE4": "a\u0308",
        "\u01DF": "a\u0308\u0304",
        "\xE3": "a\u0303",
        "\u0101": "a\u0304",
        "\u0103": "a\u0306",
        "\u1EAF": "a\u0306\u0301",
        "\u1EB1": "a\u0306\u0300",
        "\u1EB5": "a\u0306\u0303",
        "\u01CE": "a\u030C",
        "\xE2": "a\u0302",
        "\u1EA5": "a\u0302\u0301",
        "\u1EA7": "a\u0302\u0300",
        "\u1EAB": "a\u0302\u0303",
        "\u0227": "a\u0307",
        "\u01E1": "a\u0307\u0304",
        "\xE5": "a\u030A",
        "\u01FB": "a\u030A\u0301",
        "\u1E03": "b\u0307",
        "\u0107": "c\u0301",
        "\u1E09": "c\u0327\u0301",
        "\u010D": "c\u030C",
        "\u0109": "c\u0302",
        "\u010B": "c\u0307",
        "\xE7": "c\u0327",
        "\u010F": "d\u030C",
        "\u1E0B": "d\u0307",
        "\u1E11": "d\u0327",
        "\xE9": "e\u0301",
        "\xE8": "e\u0300",
        "\xEB": "e\u0308",
        "\u1EBD": "e\u0303",
        "\u0113": "e\u0304",
        "\u1E17": "e\u0304\u0301",
        "\u1E15": "e\u0304\u0300",
        "\u0115": "e\u0306",
        "\u1E1D": "e\u0327\u0306",
        "\u011B": "e\u030C",
        "\xEA": "e\u0302",
        "\u1EBF": "e\u0302\u0301",
        "\u1EC1": "e\u0302\u0300",
        "\u1EC5": "e\u0302\u0303",
        "\u0117": "e\u0307",
        "\u0229": "e\u0327",
        "\u1E1F": "f\u0307",
        "\u01F5": "g\u0301",
        "\u1E21": "g\u0304",
        "\u011F": "g\u0306",
        "\u01E7": "g\u030C",
        "\u011D": "g\u0302",
        "\u0121": "g\u0307",
        "\u0123": "g\u0327",
        "\u1E27": "h\u0308",
        "\u021F": "h\u030C",
        "\u0125": "h\u0302",
        "\u1E23": "h\u0307",
        "\u1E29": "h\u0327",
        "\xED": "i\u0301",
        "\xEC": "i\u0300",
        "\xEF": "i\u0308",
        "\u1E2F": "i\u0308\u0301",
        "\u0129": "i\u0303",
        "\u012B": "i\u0304",
        "\u012D": "i\u0306",
        "\u01D0": "i\u030C",
        "\xEE": "i\u0302",
        "\u01F0": "j\u030C",
        "\u0135": "j\u0302",
        "\u1E31": "k\u0301",
        "\u01E9": "k\u030C",
        "\u0137": "k\u0327",
        "\u013A": "l\u0301",
        "\u013E": "l\u030C",
        "\u013C": "l\u0327",
        "\u1E3F": "m\u0301",
        "\u1E41": "m\u0307",
        "\u0144": "n\u0301",
        "\u01F9": "n\u0300",
        "\xF1": "n\u0303",
        "\u0148": "n\u030C",
        "\u1E45": "n\u0307",
        "\u0146": "n\u0327",
        "\xF3": "o\u0301",
        "\xF2": "o\u0300",
        "\xF6": "o\u0308",
        "\u022B": "o\u0308\u0304",
        "\xF5": "o\u0303",
        "\u1E4D": "o\u0303\u0301",
        "\u1E4F": "o\u0303\u0308",
        "\u022D": "o\u0303\u0304",
        "\u014D": "o\u0304",
        "\u1E53": "o\u0304\u0301",
        "\u1E51": "o\u0304\u0300",
        "\u014F": "o\u0306",
        "\u01D2": "o\u030C",
        "\xF4": "o\u0302",
        "\u1ED1": "o\u0302\u0301",
        "\u1ED3": "o\u0302\u0300",
        "\u1ED7": "o\u0302\u0303",
        "\u022F": "o\u0307",
        "\u0231": "o\u0307\u0304",
        "\u0151": "o\u030B",
        "\u1E55": "p\u0301",
        "\u1E57": "p\u0307",
        "\u0155": "r\u0301",
        "\u0159": "r\u030C",
        "\u1E59": "r\u0307",
        "\u0157": "r\u0327",
        "\u015B": "s\u0301",
        "\u1E65": "s\u0301\u0307",
        "\u0161": "s\u030C",
        "\u1E67": "s\u030C\u0307",
        "\u015D": "s\u0302",
        "\u1E61": "s\u0307",
        "\u015F": "s\u0327",
        "\u1E97": "t\u0308",
        "\u0165": "t\u030C",
        "\u1E6B": "t\u0307",
        "\u0163": "t\u0327",
        "\xFA": "u\u0301",
        "\xF9": "u\u0300",
        "\xFC": "u\u0308",
        "\u01D8": "u\u0308\u0301",
        "\u01DC": "u\u0308\u0300",
        "\u01D6": "u\u0308\u0304",
        "\u01DA": "u\u0308\u030C",
        "\u0169": "u\u0303",
        "\u1E79": "u\u0303\u0301",
        "\u016B": "u\u0304",
        "\u1E7B": "u\u0304\u0308",
        "\u016D": "u\u0306",
        "\u01D4": "u\u030C",
        "\xFB": "u\u0302",
        "\u016F": "u\u030A",
        "\u0171": "u\u030B",
        "\u1E7D": "v\u0303",
        "\u1E83": "w\u0301",
        "\u1E81": "w\u0300",
        "\u1E85": "w\u0308",
        "\u0175": "w\u0302",
        "\u1E87": "w\u0307",
        "\u1E98": "w\u030A",
        "\u1E8D": "x\u0308",
        "\u1E8B": "x\u0307",
        "\xFD": "y\u0301",
        "\u1EF3": "y\u0300",
        "\xFF": "y\u0308",
        "\u1EF9": "y\u0303",
        "\u0233": "y\u0304",
        "\u0177": "y\u0302",
        "\u1E8F": "y\u0307",
        "\u1E99": "y\u030A",
        "\u017A": "z\u0301",
        "\u017E": "z\u030C",
        "\u1E91": "z\u0302",
        "\u017C": "z\u0307",
        "\xC1": "A\u0301",
        "\xC0": "A\u0300",
        "\xC4": "A\u0308",
        "\u01DE": "A\u0308\u0304",
        "\xC3": "A\u0303",
        "\u0100": "A\u0304",
        "\u0102": "A\u0306",
        "\u1EAE": "A\u0306\u0301",
        "\u1EB0": "A\u0306\u0300",
        "\u1EB4": "A\u0306\u0303",
        "\u01CD": "A\u030C",
        "\xC2": "A\u0302",
        "\u1EA4": "A\u0302\u0301",
        "\u1EA6": "A\u0302\u0300",
        "\u1EAA": "A\u0302\u0303",
        "\u0226": "A\u0307",
        "\u01E0": "A\u0307\u0304",
        "\xC5": "A\u030A",
        "\u01FA": "A\u030A\u0301",
        "\u1E02": "B\u0307",
        "\u0106": "C\u0301",
        "\u1E08": "C\u0327\u0301",
        "\u010C": "C\u030C",
        "\u0108": "C\u0302",
        "\u010A": "C\u0307",
        "\xC7": "C\u0327",
        "\u010E": "D\u030C",
        "\u1E0A": "D\u0307",
        "\u1E10": "D\u0327",
        "\xC9": "E\u0301",
        "\xC8": "E\u0300",
        "\xCB": "E\u0308",
        "\u1EBC": "E\u0303",
        "\u0112": "E\u0304",
        "\u1E16": "E\u0304\u0301",
        "\u1E14": "E\u0304\u0300",
        "\u0114": "E\u0306",
        "\u1E1C": "E\u0327\u0306",
        "\u011A": "E\u030C",
        "\xCA": "E\u0302",
        "\u1EBE": "E\u0302\u0301",
        "\u1EC0": "E\u0302\u0300",
        "\u1EC4": "E\u0302\u0303",
        "\u0116": "E\u0307",
        "\u0228": "E\u0327",
        "\u1E1E": "F\u0307",
        "\u01F4": "G\u0301",
        "\u1E20": "G\u0304",
        "\u011E": "G\u0306",
        "\u01E6": "G\u030C",
        "\u011C": "G\u0302",
        "\u0120": "G\u0307",
        "\u0122": "G\u0327",
        "\u1E26": "H\u0308",
        "\u021E": "H\u030C",
        "\u0124": "H\u0302",
        "\u1E22": "H\u0307",
        "\u1E28": "H\u0327",
        "\xCD": "I\u0301",
        "\xCC": "I\u0300",
        "\xCF": "I\u0308",
        "\u1E2E": "I\u0308\u0301",
        "\u0128": "I\u0303",
        "\u012A": "I\u0304",
        "\u012C": "I\u0306",
        "\u01CF": "I\u030C",
        "\xCE": "I\u0302",
        "\u0130": "I\u0307",
        "\u0134": "J\u0302",
        "\u1E30": "K\u0301",
        "\u01E8": "K\u030C",
        "\u0136": "K\u0327",
        "\u0139": "L\u0301",
        "\u013D": "L\u030C",
        "\u013B": "L\u0327",
        "\u1E3E": "M\u0301",
        "\u1E40": "M\u0307",
        "\u0143": "N\u0301",
        "\u01F8": "N\u0300",
        "\xD1": "N\u0303",
        "\u0147": "N\u030C",
        "\u1E44": "N\u0307",
        "\u0145": "N\u0327",
        "\xD3": "O\u0301",
        "\xD2": "O\u0300",
        "\xD6": "O\u0308",
        "\u022A": "O\u0308\u0304",
        "\xD5": "O\u0303",
        "\u1E4C": "O\u0303\u0301",
        "\u1E4E": "O\u0303\u0308",
        "\u022C": "O\u0303\u0304",
        "\u014C": "O\u0304",
        "\u1E52": "O\u0304\u0301",
        "\u1E50": "O\u0304\u0300",
        "\u014E": "O\u0306",
        "\u01D1": "O\u030C",
        "\xD4": "O\u0302",
        "\u1ED0": "O\u0302\u0301",
        "\u1ED2": "O\u0302\u0300",
        "\u1ED6": "O\u0302\u0303",
        "\u022E": "O\u0307",
        "\u0230": "O\u0307\u0304",
        "\u0150": "O\u030B",
        "\u1E54": "P\u0301",
        "\u1E56": "P\u0307",
        "\u0154": "R\u0301",
        "\u0158": "R\u030C",
        "\u1E58": "R\u0307",
        "\u0156": "R\u0327",
        "\u015A": "S\u0301",
        "\u1E64": "S\u0301\u0307",
        "\u0160": "S\u030C",
        "\u1E66": "S\u030C\u0307",
        "\u015C": "S\u0302",
        "\u1E60": "S\u0307",
        "\u015E": "S\u0327",
        "\u0164": "T\u030C",
        "\u1E6A": "T\u0307",
        "\u0162": "T\u0327",
        "\xDA": "U\u0301",
        "\xD9": "U\u0300",
        "\xDC": "U\u0308",
        "\u01D7": "U\u0308\u0301",
        "\u01DB": "U\u0308\u0300",
        "\u01D5": "U\u0308\u0304",
        "\u01D9": "U\u0308\u030C",
        "\u0168": "U\u0303",
        "\u1E78": "U\u0303\u0301",
        "\u016A": "U\u0304",
        "\u1E7A": "U\u0304\u0308",
        "\u016C": "U\u0306",
        "\u01D3": "U\u030C",
        "\xDB": "U\u0302",
        "\u016E": "U\u030A",
        "\u0170": "U\u030B",
        "\u1E7C": "V\u0303",
        "\u1E82": "W\u0301",
        "\u1E80": "W\u0300",
        "\u1E84": "W\u0308",
        "\u0174": "W\u0302",
        "\u1E86": "W\u0307",
        "\u1E8C": "X\u0308",
        "\u1E8A": "X\u0307",
        "\xDD": "Y\u0301",
        "\u1EF2": "Y\u0300",
        "\u0178": "Y\u0308",
        "\u1EF8": "Y\u0303",
        "\u0232": "Y\u0304",
        "\u0176": "Y\u0302",
        "\u1E8E": "Y\u0307",
        "\u0179": "Z\u0301",
        "\u017D": "Z\u030C",
        "\u1E90": "Z\u0302",
        "\u017B": "Z\u0307",
        "\u03AC": "\u03B1\u0301",
        "\u1F70": "\u03B1\u0300",
        "\u1FB1": "\u03B1\u0304",
        "\u1FB0": "\u03B1\u0306",
        "\u03AD": "\u03B5\u0301",
        "\u1F72": "\u03B5\u0300",
        "\u03AE": "\u03B7\u0301",
        "\u1F74": "\u03B7\u0300",
        "\u03AF": "\u03B9\u0301",
        "\u1F76": "\u03B9\u0300",
        "\u03CA": "\u03B9\u0308",
        "\u0390": "\u03B9\u0308\u0301",
        "\u1FD2": "\u03B9\u0308\u0300",
        "\u1FD1": "\u03B9\u0304",
        "\u1FD0": "\u03B9\u0306",
        "\u03CC": "\u03BF\u0301",
        "\u1F78": "\u03BF\u0300",
        "\u03CD": "\u03C5\u0301",
        "\u1F7A": "\u03C5\u0300",
        "\u03CB": "\u03C5\u0308",
        "\u03B0": "\u03C5\u0308\u0301",
        "\u1FE2": "\u03C5\u0308\u0300",
        "\u1FE1": "\u03C5\u0304",
        "\u1FE0": "\u03C5\u0306",
        "\u03CE": "\u03C9\u0301",
        "\u1F7C": "\u03C9\u0300",
        "\u038E": "\u03A5\u0301",
        "\u1FEA": "\u03A5\u0300",
        "\u03AB": "\u03A5\u0308",
        "\u1FE9": "\u03A5\u0304",
        "\u1FE8": "\u03A5\u0306",
        "\u038F": "\u03A9\u0301",
        "\u1FFA": "\u03A9\u0300"
      };
      Parser = class _Parser2 {
        static {
          __name(this, "Parser");
        }
        constructor(input, settings) {
          this.mode = void 0;
          this.gullet = void 0;
          this.settings = void 0;
          this.leftrightDepth = void 0;
          this.nextToken = void 0;
          this.mode = "math";
          this.gullet = new MacroExpander(input, settings, this.mode);
          this.settings = settings;
          this.leftrightDepth = 0;
        }
        /**
         * Checks a result to make sure it has the right type, and throws an
         * appropriate error otherwise.
         */
        expect(text4, consume) {
          if (consume === void 0) {
            consume = true;
          }
          if (this.fetch().text !== text4) {
            throw new ParseError("Expected '" + text4 + "', got '" + this.fetch().text + "'", this.fetch());
          }
          if (consume) {
            this.consume();
          }
        }
        /**
         * Discards the current lookahead token, considering it consumed.
         */
        consume() {
          this.nextToken = null;
        }
        /**
         * Return the current lookahead token, or if there isn't one (at the
         * beginning, or if the previous lookahead token was consume()d),
         * fetch the next token as the new lookahead token and return it.
         */
        fetch() {
          if (this.nextToken == null) {
            this.nextToken = this.gullet.expandNextToken();
          }
          return this.nextToken;
        }
        /**
         * Switches between "text" and "math" modes.
         */
        switchMode(newMode) {
          this.mode = newMode;
          this.gullet.switchMode(newMode);
        }
        /**
         * Main parsing function, which parses an entire input.
         */
        parse() {
          if (!this.settings.globalGroup) {
            this.gullet.beginGroup();
          }
          if (this.settings.colorIsTextColor) {
            this.gullet.macros.set("\\color", "\\textcolor");
          }
          try {
            var parse8 = this.parseExpression(false);
            this.expect("EOF");
            if (!this.settings.globalGroup) {
              this.gullet.endGroup();
            }
            return parse8;
          } finally {
            this.gullet.endGroups();
          }
        }
        /**
         * Fully parse a separate sequence of tokens as a separate job.
         * Tokens should be specified in reverse order, as in a MacroDefinition.
         */
        subparse(tokens2) {
          var oldToken = this.nextToken;
          this.consume();
          this.gullet.pushToken(new Token("}"));
          this.gullet.pushTokens(tokens2);
          var parse8 = this.parseExpression(false);
          this.expect("}");
          this.nextToken = oldToken;
          return parse8;
        }
        /**
         * Parses an "expression", which is a list of atoms.
         *
         * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
         *                 happens when functions have higher precedence han infix
         *                 nodes in implicit parses.
         *
         * `breakOnTokenText`: The text of the token that the expression should end
         *                     with, or `null` if something else should end the
         *                     expression.
         */
        parseExpression(breakOnInfix, breakOnTokenText) {
          var body = [];
          while (true) {
            if (this.mode === "math") {
              this.consumeSpaces();
            }
            var lex2 = this.fetch();
            if (_Parser2.endOfExpression.indexOf(lex2.text) !== -1) {
              break;
            }
            if (breakOnTokenText && lex2.text === breakOnTokenText) {
              break;
            }
            if (breakOnInfix && functions[lex2.text] && functions[lex2.text].infix) {
              break;
            }
            var atom2 = this.parseAtom(breakOnTokenText);
            if (!atom2) {
              break;
            } else if (atom2.type === "internal") {
              continue;
            }
            body.push(atom2);
          }
          if (this.mode === "text") {
            this.formLigatures(body);
          }
          return this.handleInfixNodes(body);
        }
        /**
         * Rewrites infix operators such as \over with corresponding commands such
         * as \frac.
         *
         * There can only be one infix operator per group.  If there's more than one
         * then the expression is ambiguous.  This can be resolved by adding {}.
         */
        handleInfixNodes(body) {
          var overIndex = -1;
          var funcName;
          for (var i2 = 0; i2 < body.length; i2++) {
            if (body[i2].type === "infix") {
              if (overIndex !== -1) {
                throw new ParseError("only one infix operator per group", body[i2].token);
              }
              overIndex = i2;
              funcName = body[i2].replaceWith;
            }
          }
          if (overIndex !== -1 && funcName) {
            var numerNode;
            var denomNode;
            var numerBody = body.slice(0, overIndex);
            var denomBody = body.slice(overIndex + 1);
            if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
              numerNode = numerBody[0];
            } else {
              numerNode = {
                type: "ordgroup",
                mode: this.mode,
                body: numerBody
              };
            }
            if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
              denomNode = denomBody[0];
            } else {
              denomNode = {
                type: "ordgroup",
                mode: this.mode,
                body: denomBody
              };
            }
            var node2;
            if (funcName === "\\\\abovefrac") {
              node2 = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
            } else {
              node2 = this.callFunction(funcName, [numerNode, denomNode], []);
            }
            return [node2];
          } else {
            return body;
          }
        }
        /**
         * Handle a subscript or superscript with nice errors.
         */
        handleSupSubscript(name) {
          var symbolToken = this.fetch();
          var symbol = symbolToken.text;
          this.consume();
          this.consumeSpaces();
          var group2 = this.parseGroup(name);
          if (!group2) {
            throw new ParseError("Expected group after '" + symbol + "'", symbolToken);
          }
          return group2;
        }
        /**
         * Converts the textual input of an unsupported command into a text node
         * contained within a color node whose color is determined by errorColor
         */
        formatUnsupportedCmd(text4) {
          var textordArray = [];
          for (var i2 = 0; i2 < text4.length; i2++) {
            textordArray.push({
              type: "textord",
              mode: "text",
              text: text4[i2]
            });
          }
          var textNode = {
            type: "text",
            mode: this.mode,
            body: textordArray
          };
          var colorNode = {
            type: "color",
            mode: this.mode,
            color: this.settings.errorColor,
            body: [textNode]
          };
          return colorNode;
        }
        /**
         * Parses a group with optional super/subscripts.
         */
        parseAtom(breakOnTokenText) {
          var base = this.parseGroup("atom", breakOnTokenText);
          if (this.mode === "text") {
            return base;
          }
          var superscript;
          var subscript;
          while (true) {
            this.consumeSpaces();
            var lex2 = this.fetch();
            if (lex2.text === "\\limits" || lex2.text === "\\nolimits") {
              if (base && base.type === "op") {
                var limits = lex2.text === "\\limits";
                base.limits = limits;
                base.alwaysHandleSupSub = true;
              } else if (base && base.type === "operatorname") {
                if (base.alwaysHandleSupSub) {
                  base.limits = lex2.text === "\\limits";
                }
              } else {
                throw new ParseError("Limit controls must follow a math operator", lex2);
              }
              this.consume();
            } else if (lex2.text === "^") {
              if (superscript) {
                throw new ParseError("Double superscript", lex2);
              }
              superscript = this.handleSupSubscript("superscript");
            } else if (lex2.text === "_") {
              if (subscript) {
                throw new ParseError("Double subscript", lex2);
              }
              subscript = this.handleSupSubscript("subscript");
            } else if (lex2.text === "'") {
              if (superscript) {
                throw new ParseError("Double superscript", lex2);
              }
              var prime = {
                type: "textord",
                mode: this.mode,
                text: "\\prime"
              };
              var primes = [prime];
              this.consume();
              while (this.fetch().text === "'") {
                primes.push(prime);
                this.consume();
              }
              if (this.fetch().text === "^") {
                primes.push(this.handleSupSubscript("superscript"));
              }
              superscript = {
                type: "ordgroup",
                mode: this.mode,
                body: primes
              };
            } else if (uSubsAndSups[lex2.text]) {
              var isSub = unicodeSubRegEx.test(lex2.text);
              var subsupTokens = [];
              subsupTokens.push(new Token(uSubsAndSups[lex2.text]));
              this.consume();
              while (true) {
                var token2 = this.fetch().text;
                if (!uSubsAndSups[token2]) {
                  break;
                }
                if (unicodeSubRegEx.test(token2) !== isSub) {
                  break;
                }
                subsupTokens.unshift(new Token(uSubsAndSups[token2]));
                this.consume();
              }
              var body = this.subparse(subsupTokens);
              if (isSub) {
                subscript = {
                  type: "ordgroup",
                  mode: "math",
                  body
                };
              } else {
                superscript = {
                  type: "ordgroup",
                  mode: "math",
                  body
                };
              }
            } else {
              break;
            }
          }
          if (superscript || subscript) {
            return {
              type: "supsub",
              mode: this.mode,
              base,
              sup: superscript,
              sub: subscript
            };
          } else {
            return base;
          }
        }
        /**
         * Parses an entire function, including its base and all of its arguments.
         */
        parseFunction(breakOnTokenText, name) {
          var token2 = this.fetch();
          var func = token2.text;
          var funcData = functions[func];
          if (!funcData) {
            return null;
          }
          this.consume();
          if (name && name !== "atom" && !funcData.allowedInArgument) {
            throw new ParseError("Got function '" + func + "' with no arguments" + (name ? " as " + name : ""), token2);
          } else if (this.mode === "text" && !funcData.allowedInText) {
            throw new ParseError("Can't use function '" + func + "' in text mode", token2);
          } else if (this.mode === "math" && funcData.allowedInMath === false) {
            throw new ParseError("Can't use function '" + func + "' in math mode", token2);
          }
          var {
            args,
            optArgs
          } = this.parseArguments(func, funcData);
          return this.callFunction(func, args, optArgs, token2, breakOnTokenText);
        }
        /**
         * Call a function handler with a suitable context and arguments.
         */
        callFunction(name, args, optArgs, token2, breakOnTokenText) {
          var context = {
            funcName: name,
            parser: this,
            token: token2,
            breakOnTokenText
          };
          var func = functions[name];
          if (func && func.handler) {
            return func.handler(context, args, optArgs);
          } else {
            throw new ParseError("No function handler for " + name);
          }
        }
        /**
         * Parses the arguments of a function or environment
         */
        parseArguments(func, funcData) {
          var totalArgs = funcData.numArgs + funcData.numOptionalArgs;
          if (totalArgs === 0) {
            return {
              args: [],
              optArgs: []
            };
          }
          var args = [];
          var optArgs = [];
          for (var i2 = 0; i2 < totalArgs; i2++) {
            var argType = funcData.argTypes && funcData.argTypes[i2];
            var isOptional = i2 < funcData.numOptionalArgs;
            if (funcData.primitive && argType == null || // \sqrt expands into primitive if optional argument doesn't exist
            funcData.type === "sqrt" && i2 === 1 && optArgs[0] == null) {
              argType = "primitive";
            }
            var arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional);
            if (isOptional) {
              optArgs.push(arg);
            } else if (arg != null) {
              args.push(arg);
            } else {
              throw new ParseError("Null argument, please report this as a bug");
            }
          }
          return {
            args,
            optArgs
          };
        }
        /**
         * Parses a group when the mode is changing.
         */
        parseGroupOfType(name, type3, optional2) {
          switch (type3) {
            case "color":
              return this.parseColorGroup(optional2);
            case "size":
              return this.parseSizeGroup(optional2);
            case "url":
              return this.parseUrlGroup(optional2);
            case "math":
            case "text":
              return this.parseArgumentGroup(optional2, type3);
            case "hbox": {
              var group2 = this.parseArgumentGroup(optional2, "text");
              return group2 != null ? {
                type: "styling",
                mode: group2.mode,
                body: [group2],
                style: "text"
                // simulate \textstyle
              } : null;
            }
            case "raw": {
              var token2 = this.parseStringGroup("raw", optional2);
              return token2 != null ? {
                type: "raw",
                mode: "text",
                string: token2.text
              } : null;
            }
            case "primitive": {
              if (optional2) {
                throw new ParseError("A primitive argument cannot be optional");
              }
              var _group = this.parseGroup(name);
              if (_group == null) {
                throw new ParseError("Expected group as " + name, this.fetch());
              }
              return _group;
            }
            case "original":
            case null:
            case void 0:
              return this.parseArgumentGroup(optional2);
            default:
              throw new ParseError("Unknown group type as " + name, this.fetch());
          }
        }
        /**
         * Discard any space tokens, fetching the next non-space token.
         */
        consumeSpaces() {
          while (this.fetch().text === " ") {
            this.consume();
          }
        }
        /**
         * Parses a group, essentially returning the string formed by the
         * brace-enclosed tokens plus some position information.
         */
        parseStringGroup(modeName, optional2) {
          var argToken = this.gullet.scanArgument(optional2);
          if (argToken == null) {
            return null;
          }
          var str2 = "";
          var nextToken;
          while ((nextToken = this.fetch()).text !== "EOF") {
            str2 += nextToken.text;
            this.consume();
          }
          this.consume();
          argToken.text = str2;
          return argToken;
        }
        /**
         * Parses a regex-delimited group: the largest sequence of tokens
         * whose concatenated strings match `regex`. Returns the string
         * formed by the tokens plus some position information.
         */
        parseRegexGroup(regex2, modeName) {
          var firstToken = this.fetch();
          var lastToken = firstToken;
          var str2 = "";
          var nextToken;
          while ((nextToken = this.fetch()).text !== "EOF" && regex2.test(str2 + nextToken.text)) {
            lastToken = nextToken;
            str2 += lastToken.text;
            this.consume();
          }
          if (str2 === "") {
            throw new ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
          }
          return firstToken.range(lastToken, str2);
        }
        /**
         * Parses a color description.
         */
        parseColorGroup(optional2) {
          var res = this.parseStringGroup("color", optional2);
          if (res == null) {
            return null;
          }
          var match2 = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);
          if (!match2) {
            throw new ParseError("Invalid color: '" + res.text + "'", res);
          }
          var color2 = match2[0];
          if (/^[0-9a-f]{6}$/i.test(color2)) {
            color2 = "#" + color2;
          }
          return {
            type: "color-token",
            mode: this.mode,
            color: color2
          };
        }
        /**
         * Parses a size specification, consisting of magnitude and unit.
         */
        parseSizeGroup(optional2) {
          var res;
          var isBlank = false;
          this.gullet.consumeSpaces();
          if (!optional2 && this.gullet.future().text !== "{") {
            res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
          } else {
            res = this.parseStringGroup("size", optional2);
          }
          if (!res) {
            return null;
          }
          if (!optional2 && res.text.length === 0) {
            res.text = "0pt";
            isBlank = true;
          }
          var match2 = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);
          if (!match2) {
            throw new ParseError("Invalid size: '" + res.text + "'", res);
          }
          var data5 = {
            number: +(match2[1] + match2[2]),
            // sign + magnitude, cast to number
            unit: match2[3]
          };
          if (!validUnit(data5)) {
            throw new ParseError("Invalid unit: '" + data5.unit + "'", res);
          }
          return {
            type: "size",
            mode: this.mode,
            value: data5,
            isBlank
          };
        }
        /**
         * Parses an URL, checking escaped letters and allowed protocols,
         * and setting the catcode of % as an active character (as in \hyperref).
         */
        parseUrlGroup(optional2) {
          this.gullet.lexer.setCatcode("%", 13);
          this.gullet.lexer.setCatcode("~", 12);
          var res = this.parseStringGroup("url", optional2);
          this.gullet.lexer.setCatcode("%", 14);
          this.gullet.lexer.setCatcode("~", 13);
          if (res == null) {
            return null;
          }
          var url = res.text.replace(/\\([#$%&~_^{}])/g, "$1");
          return {
            type: "url",
            mode: this.mode,
            url
          };
        }
        /**
         * Parses an argument with the mode specified.
         */
        parseArgumentGroup(optional2, mode) {
          var argToken = this.gullet.scanArgument(optional2);
          if (argToken == null) {
            return null;
          }
          var outerMode = this.mode;
          if (mode) {
            this.switchMode(mode);
          }
          this.gullet.beginGroup();
          var expression = this.parseExpression(false, "EOF");
          this.expect("EOF");
          this.gullet.endGroup();
          var result = {
            type: "ordgroup",
            mode: this.mode,
            loc: argToken.loc,
            body: expression
          };
          if (mode) {
            this.switchMode(outerMode);
          }
          return result;
        }
        /**
         * Parses an ordinary group, which is either a single nucleus (like "x")
         * or an expression in braces (like "{x+y}") or an implicit group, a group
         * that starts at the current position, and ends right before a higher explicit
         * group ends, or at EOF.
         */
        parseGroup(name, breakOnTokenText) {
          var firstToken = this.fetch();
          var text4 = firstToken.text;
          var result;
          if (text4 === "{" || text4 === "\\begingroup") {
            this.consume();
            var groupEnd = text4 === "{" ? "}" : "\\endgroup";
            this.gullet.beginGroup();
            var expression = this.parseExpression(false, groupEnd);
            var lastToken = this.fetch();
            this.expect(groupEnd);
            this.gullet.endGroup();
            result = {
              type: "ordgroup",
              mode: this.mode,
              loc: SourceLocation.range(firstToken, lastToken),
              body: expression,
              // A group formed by \begingroup...\endgroup is a semi-simple group
              // which doesn't affect spacing in math mode, i.e., is transparent.
              // https://tex.stackexchange.com/questions/1930/when-should-one-
              // use-begingroup-instead-of-bgroup
              semisimple: text4 === "\\begingroup" || void 0
            };
          } else {
            result = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();
            if (result == null && text4[0] === "\\" && !implicitCommands.hasOwnProperty(text4)) {
              if (this.settings.throwOnError) {
                throw new ParseError("Undefined control sequence: " + text4, firstToken);
              }
              result = this.formatUnsupportedCmd(text4);
              this.consume();
            }
          }
          return result;
        }
        /**
         * Form ligature-like combinations of characters for text mode.
         * This includes inputs like "--", "---", "``" and "''".
         * The result will simply replace multiple textord nodes with a single
         * character in each value by a single textord node having multiple
         * characters in its value.  The representation is still ASCII source.
         * The group will be modified in place.
         */
        formLigatures(group2) {
          var n2 = group2.length - 1;
          for (var i2 = 0; i2 < n2; ++i2) {
            var a2 = group2[i2];
            var v3 = a2.text;
            if (v3 === "-" && group2[i2 + 1].text === "-") {
              if (i2 + 1 < n2 && group2[i2 + 2].text === "-") {
                group2.splice(i2, 3, {
                  type: "textord",
                  mode: "text",
                  loc: SourceLocation.range(a2, group2[i2 + 2]),
                  text: "---"
                });
                n2 -= 2;
              } else {
                group2.splice(i2, 2, {
                  type: "textord",
                  mode: "text",
                  loc: SourceLocation.range(a2, group2[i2 + 1]),
                  text: "--"
                });
                n2 -= 1;
              }
            }
            if ((v3 === "'" || v3 === "`") && group2[i2 + 1].text === v3) {
              group2.splice(i2, 2, {
                type: "textord",
                mode: "text",
                loc: SourceLocation.range(a2, group2[i2 + 1]),
                text: v3 + v3
              });
              n2 -= 1;
            }
          }
        }
        /**
         * Parse a single symbol out of the string. Here, we handle single character
         * symbols and special functions like \verb.
         */
        parseSymbol() {
          var nucleus = this.fetch();
          var text4 = nucleus.text;
          if (/^\\verb[^a-zA-Z]/.test(text4)) {
            this.consume();
            var arg = text4.slice(5);
            var star2 = arg.charAt(0) === "*";
            if (star2) {
              arg = arg.slice(1);
            }
            if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
              throw new ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
            }
            arg = arg.slice(1, -1);
            return {
              type: "verb",
              mode: "text",
              body: arg,
              star: star2
            };
          }
          if (unicodeSymbols.hasOwnProperty(text4[0]) && !symbols[this.mode][text4[0]]) {
            if (this.settings.strict && this.mode === "math") {
              this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + text4[0] + '" used in math mode', nucleus);
            }
            text4 = unicodeSymbols[text4[0]] + text4.slice(1);
          }
          var match2 = combiningDiacriticalMarksEndRegex.exec(text4);
          if (match2) {
            text4 = text4.substring(0, match2.index);
            if (text4 === "i") {
              text4 = "\u0131";
            } else if (text4 === "j") {
              text4 = "\u0237";
            }
          }
          var symbol;
          if (symbols[this.mode][text4]) {
            if (this.settings.strict && this.mode === "math" && extraLatin.indexOf(text4) >= 0) {
              this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + text4[0] + '" used in math mode', nucleus);
            }
            var group2 = symbols[this.mode][text4].group;
            var loc = SourceLocation.range(nucleus);
            var s2;
            if (ATOMS.hasOwnProperty(group2)) {
              var family = group2;
              s2 = {
                type: "atom",
                mode: this.mode,
                family,
                loc,
                text: text4
              };
            } else {
              s2 = {
                type: group2,
                mode: this.mode,
                loc,
                text: text4
              };
            }
            symbol = s2;
          } else if (text4.charCodeAt(0) >= 128) {
            if (this.settings.strict) {
              if (!supportedCodepoint(text4.charCodeAt(0))) {
                this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + text4[0] + '"' + (" (" + text4.charCodeAt(0) + ")"), nucleus);
              } else if (this.mode === "math") {
                this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + text4[0] + '" used in math mode', nucleus);
              }
            }
            symbol = {
              type: "textord",
              mode: "text",
              loc: SourceLocation.range(nucleus),
              text: text4
            };
          } else {
            return null;
          }
          this.consume();
          if (match2) {
            for (var i2 = 0; i2 < match2[0].length; i2++) {
              var accent2 = match2[0][i2];
              if (!unicodeAccents[accent2]) {
                throw new ParseError("Unknown accent ' " + accent2 + "'", nucleus);
              }
              var command = unicodeAccents[accent2][this.mode] || unicodeAccents[accent2].text;
              if (!command) {
                throw new ParseError("Accent " + accent2 + " unsupported in " + this.mode + " mode", nucleus);
              }
              symbol = {
                type: "accent",
                mode: this.mode,
                loc: SourceLocation.range(nucleus),
                label: command,
                isStretchy: false,
                isShifty: true,
                // $FlowFixMe
                base: symbol
              };
            }
          }
          return symbol;
        }
      };
      Parser.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
      parseTree = /* @__PURE__ */ __name(function parseTree2(toParse, settings) {
        if (!(typeof toParse === "string" || toParse instanceof String)) {
          throw new TypeError("KaTeX can only parse string typed expression");
        }
        var parser23 = new Parser(toParse, settings);
        delete parser23.gullet.macros.current["\\df@tag"];
        var tree = parser23.parse();
        delete parser23.gullet.macros.current["\\current@color"];
        delete parser23.gullet.macros.current["\\color"];
        if (parser23.gullet.macros.get("\\df@tag")) {
          if (!settings.displayMode) {
            throw new ParseError("\\tag works only in display equations");
          }
          tree = [{
            type: "tag",
            mode: "text",
            body: tree,
            tag: parser23.subparse([new Token("\\df@tag")])
          }];
        }
        return tree;
      }, "parseTree");
      render = /* @__PURE__ */ __name(function render2(expression, baseNode, options3) {
        baseNode.textContent = "";
        var node2 = renderToDomTree(expression, options3).toNode();
        baseNode.appendChild(node2);
      }, "render");
      if (typeof document !== "undefined") {
        if (document.compatMode !== "CSS1Compat") {
          typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype.");
          render = /* @__PURE__ */ __name(function render7() {
            throw new ParseError("KaTeX doesn't work in quirks mode.");
          }, "render");
        }
      }
      renderToString = /* @__PURE__ */ __name(function renderToString2(expression, options3) {
        var markup = renderToDomTree(expression, options3).toMarkup();
        return markup;
      }, "renderToString");
      generateParseTree = /* @__PURE__ */ __name(function generateParseTree2(expression, options3) {
        var settings = new Settings(options3);
        return parseTree(expression, settings);
      }, "generateParseTree");
      renderError = /* @__PURE__ */ __name(function renderError2(error3, expression, options3) {
        if (options3.throwOnError || !(error3 instanceof ParseError)) {
          throw error3;
        }
        var node2 = buildCommon.makeSpan(["katex-error"], [new SymbolNode(expression)]);
        node2.setAttribute("title", error3.toString());
        node2.setAttribute("style", "color:" + options3.errorColor);
        return node2;
      }, "renderError");
      renderToDomTree = /* @__PURE__ */ __name(function renderToDomTree2(expression, options3) {
        var settings = new Settings(options3);
        try {
          var tree = parseTree(expression, settings);
          return buildTree(tree, expression, settings);
        } catch (error3) {
          return renderError(error3, expression, settings);
        }
      }, "renderToDomTree");
      renderToHTMLTree = /* @__PURE__ */ __name(function renderToHTMLTree2(expression, options3) {
        var settings = new Settings(options3);
        try {
          var tree = parseTree(expression, settings);
          return buildHTMLTree(tree, expression, settings);
        } catch (error3) {
          return renderError(error3, expression, settings);
        }
      }, "renderToHTMLTree");
      katex = {
        /**
         * Current KaTeX version
         */
        version: "0.16.11",
        /**
         * Renders the given LaTeX into an HTML+MathML combination, and adds
         * it as a child to the specified DOM node.
         */
        render,
        /**
         * Renders the given LaTeX into an HTML+MathML combination string,
         * for sending to the client.
         */
        renderToString,
        /**
         * KaTeX error, usually during parsing.
         */
        ParseError,
        /**
         * The shema of Settings
         */
        SETTINGS_SCHEMA,
        /**
         * Parses the given LaTeX into KaTeX's internal parse tree structure,
         * without rendering to HTML or MathML.
         *
         * NOTE: This method is not currently recommended for public use.
         * The internal tree representation is unstable and is very likely
         * to change. Use at your own risk.
         */
        __parse: generateParseTree,
        /**
         * Renders the given LaTeX into an HTML+MathML internal DOM tree
         * representation, without flattening that representation to a string.
         *
         * NOTE: This method is not currently recommended for public use.
         * The internal tree representation is unstable and is very likely
         * to change. Use at your own risk.
         */
        __renderToDomTree: renderToDomTree,
        /**
         * Renders the given LaTeX into an HTML internal DOM tree representation,
         * without MathML and without flattening that representation to a string.
         *
         * NOTE: This method is not currently recommended for public use.
         * The internal tree representation is unstable and is very likely
         * to change. Use at your own risk.
         */
        __renderToHTMLTree: renderToHTMLTree,
        /**
         * extends internal font metrics object with a new object
         * each key in the new object represents a font name
        */
        __setFontMetrics: setFontMetrics,
        /**
         * adds a new symbol to builtin symbols table
         */
        __defineSymbol: defineSymbol,
        /**
         * adds a new function to builtin function list,
         * which directly produce parse tree elements
         * and have their own html/mathml builders
         */
        __defineFunction: defineFunction,
        /**
         * adds a new macro to builtin macro list
         */
        __defineMacro: defineMacro,
        /**
         * Expose the dom tree node types, which can be useful for type checking nodes.
         *
         * NOTE: This method is not currently recommended for public use.
         * The internal tree representation is unstable and is very likely
         * to change. Use at your own risk.
         */
        __domTree: {
          Span,
          Anchor,
          SymbolNode,
          SvgNode,
          PathNode,
          LineNode
        }
      };
    }
  });

  // src/diagrams/common/common.ts
  function setupDompurifyHooks() {
    const TEMPORARY_ATTRIBUTE = "data-temp-href-target";
    purify.addHook("beforeSanitizeAttributes", (node2) => {
      if (node2 instanceof Element && node2.tagName === "A" && node2.hasAttribute("target")) {
        node2.setAttribute(TEMPORARY_ATTRIBUTE, node2.getAttribute("target") ?? "");
      }
    });
    purify.addHook("afterSanitizeAttributes", (node2) => {
      if (node2 instanceof Element && node2.tagName === "A" && node2.hasAttribute(TEMPORARY_ATTRIBUTE)) {
        node2.setAttribute("target", node2.getAttribute(TEMPORARY_ATTRIBUTE) ?? "");
        node2.removeAttribute(TEMPORARY_ATTRIBUTE);
        if (node2.getAttribute("target") === "_blank") {
          node2.setAttribute("rel", "noopener");
        }
      }
    });
  }
  var lineBreakRegex, getRows, setupDompurifyHooksIfNotSetup, removeScript, sanitizeMore, sanitizeText, sanitizeTextOrArray, hasBreaks, splitBreaks, placeholderToBreak, breakToPlaceholder, getUrl, evaluate, getMax, getMin, parseGenericTypes, countOccurrence, shouldCombineSets, processSet, isMathMLSupported, katexRegex, hasKatex, calculateMathMLDimensions, renderKatex, common_default;
  var init_common = __esm({
    "src/diagrams/common/common.ts"() {
      "use strict";
      init_purify_es();
      lineBreakRegex = /<br\s*\/?>/gi;
      getRows = /* @__PURE__ */ __name((s2) => {
        if (!s2) {
          return [""];
        }
        const str2 = breakToPlaceholder(s2).replace(/\\n/g, "#br#");
        return str2.split("#br#");
      }, "getRows");
      setupDompurifyHooksIfNotSetup = /* @__PURE__ */ (() => {
        let setup = false;
        return () => {
          if (!setup) {
            setupDompurifyHooks();
            setup = true;
          }
        };
      })();
      __name(setupDompurifyHooks, "setupDompurifyHooks");
      removeScript = /* @__PURE__ */ __name((txt) => {
        setupDompurifyHooksIfNotSetup();
        const sanitizedText = purify.sanitize(txt);
        return sanitizedText;
      }, "removeScript");
      sanitizeMore = /* @__PURE__ */ __name((text4, config6) => {
        if (config6.flowchart?.htmlLabels !== false) {
          const level = config6.securityLevel;
          if (level === "antiscript" || level === "strict") {
            text4 = removeScript(text4);
          } else if (level !== "loose") {
            text4 = breakToPlaceholder(text4);
            text4 = text4.replace(/</g, "&lt;").replace(/>/g, "&gt;");
            text4 = text4.replace(/=/g, "&equals;");
            text4 = placeholderToBreak(text4);
          }
        }
        return text4;
      }, "sanitizeMore");
      sanitizeText = /* @__PURE__ */ __name((text4, config6) => {
        if (!text4) {
          return text4;
        }
        if (config6.dompurifyConfig) {
          text4 = purify.sanitize(sanitizeMore(text4, config6), config6.dompurifyConfig).toString();
        } else {
          text4 = purify.sanitize(sanitizeMore(text4, config6), {
            FORBID_TAGS: ["style"]
          }).toString();
        }
        return text4;
      }, "sanitizeText");
      sanitizeTextOrArray = /* @__PURE__ */ __name((a2, config6) => {
        if (typeof a2 === "string") {
          return sanitizeText(a2, config6);
        }
        return a2.flat().map((x5) => sanitizeText(x5, config6));
      }, "sanitizeTextOrArray");
      hasBreaks = /* @__PURE__ */ __name((text4) => {
        return lineBreakRegex.test(text4);
      }, "hasBreaks");
      splitBreaks = /* @__PURE__ */ __name((text4) => {
        return text4.split(lineBreakRegex);
      }, "splitBreaks");
      placeholderToBreak = /* @__PURE__ */ __name((s2) => {
        return s2.replace(/#br#/g, "<br/>");
      }, "placeholderToBreak");
      breakToPlaceholder = /* @__PURE__ */ __name((s2) => {
        return s2.replace(lineBreakRegex, "#br#");
      }, "breakToPlaceholder");
      getUrl = /* @__PURE__ */ __name((useAbsolute) => {
        let url = "";
        if (useAbsolute) {
          url = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search;
          url = url.replaceAll(/\(/g, "\\(");
          url = url.replaceAll(/\)/g, "\\)");
        }
        return url;
      }, "getUrl");
      evaluate = /* @__PURE__ */ __name((val) => val === false || ["false", "null", "0"].includes(String(val).trim().toLowerCase()) ? false : true, "evaluate");
      getMax = /* @__PURE__ */ __name(function(...values2) {
        const newValues = values2.filter((value2) => {
          return !isNaN(value2);
        });
        return Math.max(...newValues);
      }, "getMax");
      getMin = /* @__PURE__ */ __name(function(...values2) {
        const newValues = values2.filter((value2) => {
          return !isNaN(value2);
        });
        return Math.min(...newValues);
      }, "getMin");
      parseGenericTypes = /* @__PURE__ */ __name(function(input) {
        const inputSets = input.split(/(,)/);
        const output2 = [];
        for (let i2 = 0; i2 < inputSets.length; i2++) {
          let thisSet = inputSets[i2];
          if (thisSet === "," && i2 > 0 && i2 + 1 < inputSets.length) {
            const previousSet = inputSets[i2 - 1];
            const nextSet = inputSets[i2 + 1];
            if (shouldCombineSets(previousSet, nextSet)) {
              thisSet = previousSet + "," + nextSet;
              i2++;
              output2.pop();
            }
          }
          output2.push(processSet(thisSet));
        }
        return output2.join("");
      }, "parseGenericTypes");
      countOccurrence = /* @__PURE__ */ __name((string3, substring) => {
        return Math.max(0, string3.split(substring).length - 1);
      }, "countOccurrence");
      shouldCombineSets = /* @__PURE__ */ __name((previousSet, nextSet) => {
        const prevCount = countOccurrence(previousSet, "~");
        const nextCount = countOccurrence(nextSet, "~");
        return prevCount === 1 && nextCount === 1;
      }, "shouldCombineSets");
      processSet = /* @__PURE__ */ __name((input) => {
        const tildeCount = countOccurrence(input, "~");
        let hasStartingTilde = false;
        if (tildeCount <= 1) {
          return input;
        }
        if (tildeCount % 2 !== 0 && input.startsWith("~")) {
          input = input.substring(1);
          hasStartingTilde = true;
        }
        const chars = [...input];
        let first3 = chars.indexOf("~");
        let last3 = chars.lastIndexOf("~");
        while (first3 !== -1 && last3 !== -1 && first3 !== last3) {
          chars[first3] = "<";
          chars[last3] = ">";
          first3 = chars.indexOf("~");
          last3 = chars.lastIndexOf("~");
        }
        if (hasStartingTilde) {
          chars.unshift("~");
        }
        return chars.join("");
      }, "processSet");
      isMathMLSupported = /* @__PURE__ */ __name(() => window.MathMLElement !== void 0, "isMathMLSupported");
      katexRegex = /\$\$(.*)\$\$/g;
      hasKatex = /* @__PURE__ */ __name((text4) => (text4.match(katexRegex)?.length ?? 0) > 0, "hasKatex");
      calculateMathMLDimensions = /* @__PURE__ */ __name(async (text4, config6) => {
        text4 = await renderKatex(text4, config6);
        const divElem = document.createElement("div");
        divElem.innerHTML = text4;
        divElem.id = "katex-temp";
        divElem.style.visibility = "hidden";
        divElem.style.position = "absolute";
        divElem.style.top = "0";
        const body = document.querySelector("body");
        body?.insertAdjacentElement("beforeend", divElem);
        const dim = { width: divElem.clientWidth, height: divElem.clientHeight };
        divElem.remove();
        return dim;
      }, "calculateMathMLDimensions");
      renderKatex = /* @__PURE__ */ __name(async (text4, config6) => {
        if (!hasKatex(text4)) {
          return text4;
        }
        if (!(isMathMLSupported() || config6.legacyMathML || config6.forceLegacyMathML)) {
          return text4.replace(katexRegex, "MathML is unsupported in this environment.");
        }
        const { default: katex2 } = await Promise.resolve().then(() => (init_katex(), katex_exports));
        const outputMode = config6.forceLegacyMathML || !isMathMLSupported() && config6.legacyMathML ? "htmlAndMathml" : "mathml";
        return text4.split(lineBreakRegex).map(
          (line2) => hasKatex(line2) ? `<div style="display: flex; align-items: center; justify-content: center; white-space: nowrap;">${line2}</div>` : `<div>${line2}</div>`
        ).join("").replace(
          katexRegex,
          (_2, c3) => katex2.renderToString(c3, {
            throwOnError: true,
            displayMode: true,
            output: outputMode
          }).replace(/\n/g, " ").replace(/<annotation.*<\/annotation>/g, "")
        );
      }, "renderKatex");
      common_default = {
        getRows,
        sanitizeText,
        sanitizeTextOrArray,
        hasBreaks,
        splitBreaks,
        lineBreakRegex,
        removeScript,
        getUrl,
        evaluate,
        getMax,
        getMin
      };
    }
  });

  // src/setupGraphViewbox.js
  var d3Attrs, calculateSvgSizeAttrs, configureSvgSize, setupGraphViewbox;
  var init_setupGraphViewbox = __esm({
    "src/setupGraphViewbox.js"() {
      "use strict";
      init_logger();
      d3Attrs = /* @__PURE__ */ __name(function(d3Elem, attrs) {
        for (let attr of attrs) {
          d3Elem.attr(attr[0], attr[1]);
        }
      }, "d3Attrs");
      calculateSvgSizeAttrs = /* @__PURE__ */ __name(function(height2, width3, useMaxWidth) {
        let attrs = /* @__PURE__ */ new Map();
        if (useMaxWidth) {
          attrs.set("width", "100%");
          attrs.set("style", `max-width: ${width3}px;`);
        } else {
          attrs.set("height", height2);
          attrs.set("width", width3);
        }
        return attrs;
      }, "calculateSvgSizeAttrs");
      configureSvgSize = /* @__PURE__ */ __name(function(svgElem, height2, width3, useMaxWidth) {
        const attrs = calculateSvgSizeAttrs(height2, width3, useMaxWidth);
        d3Attrs(svgElem, attrs);
      }, "configureSvgSize");
      setupGraphViewbox = /* @__PURE__ */ __name(function(graph, svgElem, padding2, useMaxWidth) {
        const svgBounds = svgElem.node().getBBox();
        const sWidth = svgBounds.width;
        const sHeight = svgBounds.height;
        log.info(`SVG bounds: ${sWidth}x${sHeight}`, svgBounds);
        let width3 = 0;
        let height2 = 0;
        log.info(`Graph bounds: ${width3}x${height2}`, graph);
        width3 = sWidth + padding2 * 2;
        height2 = sHeight + padding2 * 2;
        log.info(`Calculated bounds: ${width3}x${height2}`);
        configureSvgSize(svgElem, height2, width3, useMaxWidth);
        const vBox = `${svgBounds.x - padding2} ${svgBounds.y - padding2} ${svgBounds.width + 2 * padding2} ${svgBounds.height + 2 * padding2}`;
        svgElem.attr("viewBox", vBox);
      }, "setupGraphViewbox");
    }
  });

  // src/styles.ts
  var themes, getStyles, addStylesForDiagram, styles_default;
  var init_styles = __esm({
    "src/styles.ts"() {
      "use strict";
      init_logger();
      themes = {};
      getStyles = /* @__PURE__ */ __name((type3, userStyles, options3) => {
        let diagramStyles = "";
        if (type3 in themes && themes[type3]) {
          diagramStyles = themes[type3](options3);
        } else {
          log.warn(`No theme found for ${type3}`);
        }
        return ` & {
    font-family: ${options3.fontFamily};
    font-size: ${options3.fontSize};
    fill: ${options3.textColor}
  }

  /* Classes common for multiple diagrams */

  & .error-icon {
    fill: ${options3.errorBkgColor};
  }
  & .error-text {
    fill: ${options3.errorTextColor};
    stroke: ${options3.errorTextColor};
  }

  & .edge-thickness-normal {
    stroke-width: 1px;
  }
  & .edge-thickness-thick {
    stroke-width: 3.5px
  }
  & .edge-pattern-solid {
    stroke-dasharray: 0;
  }
  & .edge-thickness-invisible {
    stroke-width: 0;
    fill: none;
  }
  & .edge-pattern-dashed{
    stroke-dasharray: 3;
  }
  .edge-pattern-dotted {
    stroke-dasharray: 2;
  }

  & .marker {
    fill: ${options3.lineColor};
    stroke: ${options3.lineColor};
  }
  & .marker.cross {
    stroke: ${options3.lineColor};
  }

  & svg {
    font-family: ${options3.fontFamily};
    font-size: ${options3.fontSize};
  }
   & p {
    margin: 0
   }

  ${diagramStyles}

  ${userStyles}
`;
      }, "getStyles");
      addStylesForDiagram = /* @__PURE__ */ __name((type3, diagramTheme) => {
        if (diagramTheme !== void 0) {
          themes[type3] = diagramTheme;
        }
      }, "addStylesForDiagram");
      styles_default = getStyles;
    }
  });

  // src/diagrams/common/commonDb.ts
  var commonDb_exports = {};
  __export(commonDb_exports, {
    clear: () => clear,
    getAccDescription: () => getAccDescription,
    getAccTitle: () => getAccTitle,
    getDiagramTitle: () => getDiagramTitle,
    setAccDescription: () => setAccDescription,
    setAccTitle: () => setAccTitle,
    setDiagramTitle: () => setDiagramTitle
  });
  var accTitle, diagramTitle, accDescription, sanitizeText2, clear, setAccTitle, getAccTitle, setAccDescription, getAccDescription, setDiagramTitle, getDiagramTitle;
  var init_commonDb = __esm({
    "src/diagrams/common/commonDb.ts"() {
      "use strict";
      init_common();
      init_config();
      accTitle = "";
      diagramTitle = "";
      accDescription = "";
      sanitizeText2 = /* @__PURE__ */ __name((txt) => sanitizeText(txt, getConfig()), "sanitizeText");
      clear = /* @__PURE__ */ __name(() => {
        accTitle = "";
        accDescription = "";
        diagramTitle = "";
      }, "clear");
      setAccTitle = /* @__PURE__ */ __name((txt) => {
        accTitle = sanitizeText2(txt).replace(/^\s+/g, "");
      }, "setAccTitle");
      getAccTitle = /* @__PURE__ */ __name(() => accTitle, "getAccTitle");
      setAccDescription = /* @__PURE__ */ __name((txt) => {
        accDescription = sanitizeText2(txt).replace(/\n\s+/g, "\n");
      }, "setAccDescription");
      getAccDescription = /* @__PURE__ */ __name(() => accDescription, "getAccDescription");
      setDiagramTitle = /* @__PURE__ */ __name((txt) => {
        diagramTitle = sanitizeText2(txt);
      }, "setDiagramTitle");
      getDiagramTitle = /* @__PURE__ */ __name(() => diagramTitle, "getDiagramTitle");
    }
  });

  // src/diagram-api/diagramAPI.ts
  var log2, setLogLevel2, getConfig2, setConfig2, defaultConfig2, sanitizeText3, setupGraphViewbox2, getCommonDb, diagrams, registerDiagram, getDiagram, DiagramNotFoundError;
  var init_diagramAPI = __esm({
    "src/diagram-api/diagramAPI.ts"() {
      "use strict";
      init_detectType();
      init_logger();
      init_config();
      init_common();
      init_setupGraphViewbox();
      init_styles();
      init_commonDb();
      log2 = log;
      setLogLevel2 = setLogLevel;
      getConfig2 = getConfig;
      setConfig2 = setConfig;
      defaultConfig2 = defaultConfig;
      sanitizeText3 = /* @__PURE__ */ __name((text4) => sanitizeText(text4, getConfig2()), "sanitizeText");
      setupGraphViewbox2 = setupGraphViewbox;
      getCommonDb = /* @__PURE__ */ __name(() => {
        return commonDb_exports;
      }, "getCommonDb");
      diagrams = {};
      registerDiagram = /* @__PURE__ */ __name((id28, diagram25, detector26) => {
        if (diagrams[id28]) {
          log2.warn(`Diagram with id ${id28} already registered. Overwriting.`);
        }
        diagrams[id28] = diagram25;
        if (detector26) {
          addDetector(id28, detector26);
        }
        addStylesForDiagram(id28, diagram25.styles);
        diagram25.injectUtils?.(
          log2,
          setLogLevel2,
          getConfig2,
          sanitizeText3,
          setupGraphViewbox2,
          getCommonDb(),
          () => {
          }
        );
      }, "registerDiagram");
      getDiagram = /* @__PURE__ */ __name((name) => {
        if (name in diagrams) {
          return diagrams[name];
        }
        throw new DiagramNotFoundError(name);
      }, "getDiagram");
      DiagramNotFoundError = class extends Error {
        static {
          __name(this, "DiagramNotFoundError");
        }
        constructor(name) {
          super(`Diagram ${name} not found.`);
        }
      };
    }
  });

  // src/diagrams/c4/c4Db.js
  var c4ShapeArray, boundaryParseStack, currentBoundaryParse, parentBoundaryParse, boundaries, rels, title, wrapEnabled, c4ShapeInRow, c4BoundaryInRow, c4Type, getC4Type, setC4Type, addRel, addPersonOrSystem, addContainer, addComponent, addPersonOrSystemBoundary, addContainerBoundary, addDeploymentNode, popBoundaryParseStack, updateElStyle, updateRelStyle, updateLayoutConfig, getC4ShapeInRow, getC4BoundaryInRow, getCurrentBoundaryParse, getParentBoundaryParse, getC4ShapeArray, getC4Shape, getC4ShapeKeys, getBoundaries, getBoundarys, getRels, getTitle, setWrap, autoWrap, clear2, LINETYPE, ARROWTYPE, PLACEMENT, setTitle, c4Db_default;
  var init_c4Db = __esm({
    "src/diagrams/c4/c4Db.js"() {
      "use strict";
      init_diagramAPI();
      init_common();
      init_commonDb();
      c4ShapeArray = [];
      boundaryParseStack = [""];
      currentBoundaryParse = "global";
      parentBoundaryParse = "";
      boundaries = [
        {
          alias: "global",
          label: { text: "global" },
          type: { text: "global" },
          tags: null,
          link: null,
          parentBoundary: ""
        }
      ];
      rels = [];
      title = "";
      wrapEnabled = false;
      c4ShapeInRow = 4;
      c4BoundaryInRow = 2;
      getC4Type = /* @__PURE__ */ __name(function() {
        return c4Type;
      }, "getC4Type");
      setC4Type = /* @__PURE__ */ __name(function(c4TypeParam) {
        let sanitizedText = sanitizeText(c4TypeParam, getConfig2());
        c4Type = sanitizedText;
      }, "setC4Type");
      addRel = /* @__PURE__ */ __name(function(type3, from2, to, label, techn, descr, sprite, tags2, link3) {
        if (type3 === void 0 || type3 === null || from2 === void 0 || from2 === null || to === void 0 || to === null || label === void 0 || label === null) {
          return;
        }
        let rel2 = {};
        const old = rels.find((rel3) => rel3.from === from2 && rel3.to === to);
        if (old) {
          rel2 = old;
        } else {
          rels.push(rel2);
        }
        rel2.type = type3;
        rel2.from = from2;
        rel2.to = to;
        rel2.label = { text: label };
        if (techn === void 0 || techn === null) {
          rel2.techn = { text: "" };
        } else {
          if (typeof techn === "object") {
            let [key, value2] = Object.entries(techn)[0];
            rel2[key] = { text: value2 };
          } else {
            rel2.techn = { text: techn };
          }
        }
        if (descr === void 0 || descr === null) {
          rel2.descr = { text: "" };
        } else {
          if (typeof descr === "object") {
            let [key, value2] = Object.entries(descr)[0];
            rel2[key] = { text: value2 };
          } else {
            rel2.descr = { text: descr };
          }
        }
        if (typeof sprite === "object") {
          let [key, value2] = Object.entries(sprite)[0];
          rel2[key] = value2;
        } else {
          rel2.sprite = sprite;
        }
        if (typeof tags2 === "object") {
          let [key, value2] = Object.entries(tags2)[0];
          rel2[key] = value2;
        } else {
          rel2.tags = tags2;
        }
        if (typeof link3 === "object") {
          let [key, value2] = Object.entries(link3)[0];
          rel2[key] = value2;
        } else {
          rel2.link = link3;
        }
        rel2.wrap = autoWrap();
      }, "addRel");
      addPersonOrSystem = /* @__PURE__ */ __name(function(typeC4Shape, alias, label, descr, sprite, tags2, link3) {
        if (alias === null || label === null) {
          return;
        }
        let personOrSystem = {};
        const old = c4ShapeArray.find((personOrSystem2) => personOrSystem2.alias === alias);
        if (old && alias === old.alias) {
          personOrSystem = old;
        } else {
          personOrSystem.alias = alias;
          c4ShapeArray.push(personOrSystem);
        }
        if (label === void 0 || label === null) {
          personOrSystem.label = { text: "" };
        } else {
          personOrSystem.label = { text: label };
        }
        if (descr === void 0 || descr === null) {
          personOrSystem.descr = { text: "" };
        } else {
          if (typeof descr === "object") {
            let [key, value2] = Object.entries(descr)[0];
            personOrSystem[key] = { text: value2 };
          } else {
            personOrSystem.descr = { text: descr };
          }
        }
        if (typeof sprite === "object") {
          let [key, value2] = Object.entries(sprite)[0];
          personOrSystem[key] = value2;
        } else {
          personOrSystem.sprite = sprite;
        }
        if (typeof tags2 === "object") {
          let [key, value2] = Object.entries(tags2)[0];
          personOrSystem[key] = value2;
        } else {
          personOrSystem.tags = tags2;
        }
        if (typeof link3 === "object") {
          let [key, value2] = Object.entries(link3)[0];
          personOrSystem[key] = value2;
        } else {
          personOrSystem.link = link3;
        }
        personOrSystem.typeC4Shape = { text: typeC4Shape };
        personOrSystem.parentBoundary = currentBoundaryParse;
        personOrSystem.wrap = autoWrap();
      }, "addPersonOrSystem");
      addContainer = /* @__PURE__ */ __name(function(typeC4Shape, alias, label, techn, descr, sprite, tags2, link3) {
        if (alias === null || label === null) {
          return;
        }
        let container2 = {};
        const old = c4ShapeArray.find((container3) => container3.alias === alias);
        if (old && alias === old.alias) {
          container2 = old;
        } else {
          container2.alias = alias;
          c4ShapeArray.push(container2);
        }
        if (label === void 0 || label === null) {
          container2.label = { text: "" };
        } else {
          container2.label = { text: label };
        }
        if (techn === void 0 || techn === null) {
          container2.techn = { text: "" };
        } else {
          if (typeof techn === "object") {
            let [key, value2] = Object.entries(techn)[0];
            container2[key] = { text: value2 };
          } else {
            container2.techn = { text: techn };
          }
        }
        if (descr === void 0 || descr === null) {
          container2.descr = { text: "" };
        } else {
          if (typeof descr === "object") {
            let [key, value2] = Object.entries(descr)[0];
            container2[key] = { text: value2 };
          } else {
            container2.descr = { text: descr };
          }
        }
        if (typeof sprite === "object") {
          let [key, value2] = Object.entries(sprite)[0];
          container2[key] = value2;
        } else {
          container2.sprite = sprite;
        }
        if (typeof tags2 === "object") {
          let [key, value2] = Object.entries(tags2)[0];
          container2[key] = value2;
        } else {
          container2.tags = tags2;
        }
        if (typeof link3 === "object") {
          let [key, value2] = Object.entries(link3)[0];
          container2[key] = value2;
        } else {
          container2.link = link3;
        }
        container2.wrap = autoWrap();
        container2.typeC4Shape = { text: typeC4Shape };
        container2.parentBoundary = currentBoundaryParse;
      }, "addContainer");
      addComponent = /* @__PURE__ */ __name(function(typeC4Shape, alias, label, techn, descr, sprite, tags2, link3) {
        if (alias === null || label === null) {
          return;
        }
        let component2 = {};
        const old = c4ShapeArray.find((component3) => component3.alias === alias);
        if (old && alias === old.alias) {
          component2 = old;
        } else {
          component2.alias = alias;
          c4ShapeArray.push(component2);
        }
        if (label === void 0 || label === null) {
          component2.label = { text: "" };
        } else {
          component2.label = { text: label };
        }
        if (techn === void 0 || techn === null) {
          component2.techn = { text: "" };
        } else {
          if (typeof techn === "object") {
            let [key, value2] = Object.entries(techn)[0];
            component2[key] = { text: value2 };
          } else {
            component2.techn = { text: techn };
          }
        }
        if (descr === void 0 || descr === null) {
          component2.descr = { text: "" };
        } else {
          if (typeof descr === "object") {
            let [key, value2] = Object.entries(descr)[0];
            component2[key] = { text: value2 };
          } else {
            component2.descr = { text: descr };
          }
        }
        if (typeof sprite === "object") {
          let [key, value2] = Object.entries(sprite)[0];
          component2[key] = value2;
        } else {
          component2.sprite = sprite;
        }
        if (typeof tags2 === "object") {
          let [key, value2] = Object.entries(tags2)[0];
          component2[key] = value2;
        } else {
          component2.tags = tags2;
        }
        if (typeof link3 === "object") {
          let [key, value2] = Object.entries(link3)[0];
          component2[key] = value2;
        } else {
          component2.link = link3;
        }
        component2.wrap = autoWrap();
        component2.typeC4Shape = { text: typeC4Shape };
        component2.parentBoundary = currentBoundaryParse;
      }, "addComponent");
      addPersonOrSystemBoundary = /* @__PURE__ */ __name(function(alias, label, type3, tags2, link3) {
        if (alias === null || label === null) {
          return;
        }
        let boundary = {};
        const old = boundaries.find((boundary2) => boundary2.alias === alias);
        if (old && alias === old.alias) {
          boundary = old;
        } else {
          boundary.alias = alias;
          boundaries.push(boundary);
        }
        if (label === void 0 || label === null) {
          boundary.label = { text: "" };
        } else {
          boundary.label = { text: label };
        }
        if (type3 === void 0 || type3 === null) {
          boundary.type = { text: "system" };
        } else {
          if (typeof type3 === "object") {
            let [key, value2] = Object.entries(type3)[0];
            boundary[key] = { text: value2 };
          } else {
            boundary.type = { text: type3 };
          }
        }
        if (typeof tags2 === "object") {
          let [key, value2] = Object.entries(tags2)[0];
          boundary[key] = value2;
        } else {
          boundary.tags = tags2;
        }
        if (typeof link3 === "object") {
          let [key, value2] = Object.entries(link3)[0];
          boundary[key] = value2;
        } else {
          boundary.link = link3;
        }
        boundary.parentBoundary = currentBoundaryParse;
        boundary.wrap = autoWrap();
        parentBoundaryParse = currentBoundaryParse;
        currentBoundaryParse = alias;
        boundaryParseStack.push(parentBoundaryParse);
      }, "addPersonOrSystemBoundary");
      addContainerBoundary = /* @__PURE__ */ __name(function(alias, label, type3, tags2, link3) {
        if (alias === null || label === null) {
          return;
        }
        let boundary = {};
        const old = boundaries.find((boundary2) => boundary2.alias === alias);
        if (old && alias === old.alias) {
          boundary = old;
        } else {
          boundary.alias = alias;
          boundaries.push(boundary);
        }
        if (label === void 0 || label === null) {
          boundary.label = { text: "" };
        } else {
          boundary.label = { text: label };
        }
        if (type3 === void 0 || type3 === null) {
          boundary.type = { text: "container" };
        } else {
          if (typeof type3 === "object") {
            let [key, value2] = Object.entries(type3)[0];
            boundary[key] = { text: value2 };
          } else {
            boundary.type = { text: type3 };
          }
        }
        if (typeof tags2 === "object") {
          let [key, value2] = Object.entries(tags2)[0];
          boundary[key] = value2;
        } else {
          boundary.tags = tags2;
        }
        if (typeof link3 === "object") {
          let [key, value2] = Object.entries(link3)[0];
          boundary[key] = value2;
        } else {
          boundary.link = link3;
        }
        boundary.parentBoundary = currentBoundaryParse;
        boundary.wrap = autoWrap();
        parentBoundaryParse = currentBoundaryParse;
        currentBoundaryParse = alias;
        boundaryParseStack.push(parentBoundaryParse);
      }, "addContainerBoundary");
      addDeploymentNode = /* @__PURE__ */ __name(function(nodeType3, alias, label, type3, descr, sprite, tags2, link3) {
        if (alias === null || label === null) {
          return;
        }
        let boundary = {};
        const old = boundaries.find((boundary2) => boundary2.alias === alias);
        if (old && alias === old.alias) {
          boundary = old;
        } else {
          boundary.alias = alias;
          boundaries.push(boundary);
        }
        if (label === void 0 || label === null) {
          boundary.label = { text: "" };
        } else {
          boundary.label = { text: label };
        }
        if (type3 === void 0 || type3 === null) {
          boundary.type = { text: "node" };
        } else {
          if (typeof type3 === "object") {
            let [key, value2] = Object.entries(type3)[0];
            boundary[key] = { text: value2 };
          } else {
            boundary.type = { text: type3 };
          }
        }
        if (descr === void 0 || descr === null) {
          boundary.descr = { text: "" };
        } else {
          if (typeof descr === "object") {
            let [key, value2] = Object.entries(descr)[0];
            boundary[key] = { text: value2 };
          } else {
            boundary.descr = { text: descr };
          }
        }
        if (typeof tags2 === "object") {
          let [key, value2] = Object.entries(tags2)[0];
          boundary[key] = value2;
        } else {
          boundary.tags = tags2;
        }
        if (typeof link3 === "object") {
          let [key, value2] = Object.entries(link3)[0];
          boundary[key] = value2;
        } else {
          boundary.link = link3;
        }
        boundary.nodeType = nodeType3;
        boundary.parentBoundary = currentBoundaryParse;
        boundary.wrap = autoWrap();
        parentBoundaryParse = currentBoundaryParse;
        currentBoundaryParse = alias;
        boundaryParseStack.push(parentBoundaryParse);
      }, "addDeploymentNode");
      popBoundaryParseStack = /* @__PURE__ */ __name(function() {
        currentBoundaryParse = parentBoundaryParse;
        boundaryParseStack.pop();
        parentBoundaryParse = boundaryParseStack.pop();
        boundaryParseStack.push(parentBoundaryParse);
      }, "popBoundaryParseStack");
      updateElStyle = /* @__PURE__ */ __name(function(typeC4Shape, elementName, bgColor, fontColor, borderColor, shadowing, shape, sprite, techn, legendText, legendSprite) {
        let old = c4ShapeArray.find((element3) => element3.alias === elementName);
        if (old === void 0) {
          old = boundaries.find((element3) => element3.alias === elementName);
          if (old === void 0) {
            return;
          }
        }
        if (bgColor !== void 0 && bgColor !== null) {
          if (typeof bgColor === "object") {
            let [key, value2] = Object.entries(bgColor)[0];
            old[key] = value2;
          } else {
            old.bgColor = bgColor;
          }
        }
        if (fontColor !== void 0 && fontColor !== null) {
          if (typeof fontColor === "object") {
            let [key, value2] = Object.entries(fontColor)[0];
            old[key] = value2;
          } else {
            old.fontColor = fontColor;
          }
        }
        if (borderColor !== void 0 && borderColor !== null) {
          if (typeof borderColor === "object") {
            let [key, value2] = Object.entries(borderColor)[0];
            old[key] = value2;
          } else {
            old.borderColor = borderColor;
          }
        }
        if (shadowing !== void 0 && shadowing !== null) {
          if (typeof shadowing === "object") {
            let [key, value2] = Object.entries(shadowing)[0];
            old[key] = value2;
          } else {
            old.shadowing = shadowing;
          }
        }
        if (shape !== void 0 && shape !== null) {
          if (typeof shape === "object") {
            let [key, value2] = Object.entries(shape)[0];
            old[key] = value2;
          } else {
            old.shape = shape;
          }
        }
        if (sprite !== void 0 && sprite !== null) {
          if (typeof sprite === "object") {
            let [key, value2] = Object.entries(sprite)[0];
            old[key] = value2;
          } else {
            old.sprite = sprite;
          }
        }
        if (techn !== void 0 && techn !== null) {
          if (typeof techn === "object") {
            let [key, value2] = Object.entries(techn)[0];
            old[key] = value2;
          } else {
            old.techn = techn;
          }
        }
        if (legendText !== void 0 && legendText !== null) {
          if (typeof legendText === "object") {
            let [key, value2] = Object.entries(legendText)[0];
            old[key] = value2;
          } else {
            old.legendText = legendText;
          }
        }
        if (legendSprite !== void 0 && legendSprite !== null) {
          if (typeof legendSprite === "object") {
            let [key, value2] = Object.entries(legendSprite)[0];
            old[key] = value2;
          } else {
            old.legendSprite = legendSprite;
          }
        }
      }, "updateElStyle");
      updateRelStyle = /* @__PURE__ */ __name(function(typeC4Shape, from2, to, textColor, lineColor, offsetX, offsetY) {
        const old = rels.find((rel2) => rel2.from === from2 && rel2.to === to);
        if (old === void 0) {
          return;
        }
        if (textColor !== void 0 && textColor !== null) {
          if (typeof textColor === "object") {
            let [key, value2] = Object.entries(textColor)[0];
            old[key] = value2;
          } else {
            old.textColor = textColor;
          }
        }
        if (lineColor !== void 0 && lineColor !== null) {
          if (typeof lineColor === "object") {
            let [key, value2] = Object.entries(lineColor)[0];
            old[key] = value2;
          } else {
            old.lineColor = lineColor;
          }
        }
        if (offsetX !== void 0 && offsetX !== null) {
          if (typeof offsetX === "object") {
            let [key, value2] = Object.entries(offsetX)[0];
            old[key] = parseInt(value2);
          } else {
            old.offsetX = parseInt(offsetX);
          }
        }
        if (offsetY !== void 0 && offsetY !== null) {
          if (typeof offsetY === "object") {
            let [key, value2] = Object.entries(offsetY)[0];
            old[key] = parseInt(value2);
          } else {
            old.offsetY = parseInt(offsetY);
          }
        }
      }, "updateRelStyle");
      updateLayoutConfig = /* @__PURE__ */ __name(function(typeC4Shape, c4ShapeInRowParam, c4BoundaryInRowParam) {
        let c4ShapeInRowValue = c4ShapeInRow;
        let c4BoundaryInRowValue = c4BoundaryInRow;
        if (typeof c4ShapeInRowParam === "object") {
          const value2 = Object.values(c4ShapeInRowParam)[0];
          c4ShapeInRowValue = parseInt(value2);
        } else {
          c4ShapeInRowValue = parseInt(c4ShapeInRowParam);
        }
        if (typeof c4BoundaryInRowParam === "object") {
          const value2 = Object.values(c4BoundaryInRowParam)[0];
          c4BoundaryInRowValue = parseInt(value2);
        } else {
          c4BoundaryInRowValue = parseInt(c4BoundaryInRowParam);
        }
        if (c4ShapeInRowValue >= 1) {
          c4ShapeInRow = c4ShapeInRowValue;
        }
        if (c4BoundaryInRowValue >= 1) {
          c4BoundaryInRow = c4BoundaryInRowValue;
        }
      }, "updateLayoutConfig");
      getC4ShapeInRow = /* @__PURE__ */ __name(function() {
        return c4ShapeInRow;
      }, "getC4ShapeInRow");
      getC4BoundaryInRow = /* @__PURE__ */ __name(function() {
        return c4BoundaryInRow;
      }, "getC4BoundaryInRow");
      getCurrentBoundaryParse = /* @__PURE__ */ __name(function() {
        return currentBoundaryParse;
      }, "getCurrentBoundaryParse");
      getParentBoundaryParse = /* @__PURE__ */ __name(function() {
        return parentBoundaryParse;
      }, "getParentBoundaryParse");
      getC4ShapeArray = /* @__PURE__ */ __name(function(parentBoundary) {
        if (parentBoundary === void 0 || parentBoundary === null) {
          return c4ShapeArray;
        } else {
          return c4ShapeArray.filter((personOrSystem) => {
            return personOrSystem.parentBoundary === parentBoundary;
          });
        }
      }, "getC4ShapeArray");
      getC4Shape = /* @__PURE__ */ __name(function(alias) {
        return c4ShapeArray.find((personOrSystem) => personOrSystem.alias === alias);
      }, "getC4Shape");
      getC4ShapeKeys = /* @__PURE__ */ __name(function(parentBoundary) {
        return Object.keys(getC4ShapeArray(parentBoundary));
      }, "getC4ShapeKeys");
      getBoundaries = /* @__PURE__ */ __name(function(parentBoundary) {
        if (parentBoundary === void 0 || parentBoundary === null) {
          return boundaries;
        } else {
          return boundaries.filter((boundary) => boundary.parentBoundary === parentBoundary);
        }
      }, "getBoundaries");
      getBoundarys = getBoundaries;
      getRels = /* @__PURE__ */ __name(function() {
        return rels;
      }, "getRels");
      getTitle = /* @__PURE__ */ __name(function() {
        return title;
      }, "getTitle");
      setWrap = /* @__PURE__ */ __name(function(wrapSetting) {
        wrapEnabled = wrapSetting;
      }, "setWrap");
      autoWrap = /* @__PURE__ */ __name(function() {
        return wrapEnabled;
      }, "autoWrap");
      clear2 = /* @__PURE__ */ __name(function() {
        c4ShapeArray = [];
        boundaries = [
          {
            alias: "global",
            label: { text: "global" },
            type: { text: "global" },
            tags: null,
            link: null,
            parentBoundary: ""
          }
        ];
        parentBoundaryParse = "";
        currentBoundaryParse = "global";
        boundaryParseStack = [""];
        rels = [];
        boundaryParseStack = [""];
        title = "";
        wrapEnabled = false;
        c4ShapeInRow = 4;
        c4BoundaryInRow = 2;
      }, "clear");
      LINETYPE = {
        SOLID: 0,
        DOTTED: 1,
        NOTE: 2,
        SOLID_CROSS: 3,
        DOTTED_CROSS: 4,
        SOLID_OPEN: 5,
        DOTTED_OPEN: 6,
        LOOP_START: 10,
        LOOP_END: 11,
        ALT_START: 12,
        ALT_ELSE: 13,
        ALT_END: 14,
        OPT_START: 15,
        OPT_END: 16,
        ACTIVE_START: 17,
        ACTIVE_END: 18,
        PAR_START: 19,
        PAR_AND: 20,
        PAR_END: 21,
        RECT_START: 22,
        RECT_END: 23,
        SOLID_POINT: 24,
        DOTTED_POINT: 25
      };
      ARROWTYPE = {
        FILLED: 0,
        OPEN: 1
      };
      PLACEMENT = {
        LEFTOF: 0,
        RIGHTOF: 1,
        OVER: 2
      };
      setTitle = /* @__PURE__ */ __name(function(txt) {
        let sanitizedText = sanitizeText(txt, getConfig2());
        title = sanitizedText;
      }, "setTitle");
      c4Db_default = {
        addPersonOrSystem,
        addPersonOrSystemBoundary,
        addContainer,
        addContainerBoundary,
        addComponent,
        addDeploymentNode,
        popBoundaryParseStack,
        addRel,
        updateElStyle,
        updateRelStyle,
        updateLayoutConfig,
        autoWrap,
        setWrap,
        getC4ShapeArray,
        getC4Shape,
        getC4ShapeKeys,
        getBoundaries,
        getBoundarys,
        getCurrentBoundaryParse,
        getParentBoundaryParse,
        getRels,
        getTitle,
        getC4Type,
        getC4ShapeInRow,
        getC4BoundaryInRow,
        setAccTitle,
        getAccTitle,
        getAccDescription,
        setAccDescription,
        getConfig: /* @__PURE__ */ __name(() => getConfig2().c4, "getConfig"),
        clear: clear2,
        LINETYPE,
        ARROWTYPE,
        PLACEMENT,
        setTitle,
        setC4Type
        // apply,
      };
    }
  });

  // ../../node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/ascending.js
  function ascending(a2, b2) {
    return a2 == null || b2 == null ? NaN : a2 < b2 ? -1 : a2 > b2 ? 1 : a2 >= b2 ? 0 : NaN;
  }
  var init_ascending = __esm({
    "../../node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/ascending.js"() {
      "use strict";
      __name(ascending, "ascending");
    }
  });

  // ../../node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/descending.js
  function descending(a2, b2) {
    return a2 == null || b2 == null ? NaN : b2 < a2 ? -1 : b2 > a2 ? 1 : b2 >= a2 ? 0 : NaN;
  }
  var init_descending = __esm({
    "../../node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/descending.js"() {
      "use strict";
      __name(descending, "descending");
    }
  });

  // ../../node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/bisector.js
  function bisector(f3) {
    let compare1, compare2, delta;
    if (f3.length !== 2) {
      compare1 = ascending;
      compare2 = /* @__PURE__ */ __name((d2, x5) => ascending(f3(d2), x5), "compare2");
      delta = /* @__PURE__ */ __name((d2, x5) => f3(d2) - x5, "delta");
    } else {
      compare1 = f3 === ascending || f3 === descending ? f3 : zero;
      compare2 = f3;
      delta = f3;
    }
    function left3(a2, x5, lo = 0, hi = a2.length) {
      if (lo < hi) {
        if (compare1(x5, x5) !== 0) return hi;
        do {
          const mid = lo + hi >>> 1;
          if (compare2(a2[mid], x5) < 0) lo = mid + 1;
          else hi = mid;
        } while (lo < hi);
      }
      return lo;
    }
    __name(left3, "left");
    function right3(a2, x5, lo = 0, hi = a2.length) {
      if (lo < hi) {
        if (compare1(x5, x5) !== 0) return hi;
        do {
          const mid = lo + hi >>> 1;
          if (compare2(a2[mid], x5) <= 0) lo = mid + 1;
          else hi = mid;
        } while (lo < hi);
      }
      return lo;
    }
    __name(right3, "right");
    function center4(a2, x5, lo = 0, hi = a2.length) {
      const i2 = left3(a2, x5, lo, hi - 1);
      return i2 > lo && delta(a2[i2 - 1], x5) > -delta(a2[i2], x5) ? i2 - 1 : i2;
    }
    __name(center4, "center");
    return { left: left3, center: center4, right: right3 };
  }
  function zero() {
    return 0;
  }
  var init_bisector = __esm({
    "../../node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/bisector.js"() {
      "use strict";
      init_ascending();
      init_descending();
      __name(bisector, "bisector");
      __name(zero, "zero");
    }
  });

  // ../../node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/number.js
  function number(x5) {
    return x5 === null ? NaN : +x5;
  }
  var init_number = __esm({
    "../../node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/number.js"() {
      "use strict";
      __name(number, "number");
    }
  });

  // ../../node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/bisect.js
  var ascendingBisect, bisectRight, bisectLeft, bisectCenter, bisect_default;
  var init_bisect = __esm({
    "../../node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/bisect.js"() {
      "use strict";
      init_ascending();
      init_bisector();
      init_number();
      ascendingBisect = bisector(ascending);
      bisectRight = ascendingBisect.right;
      bisectLeft = ascendingBisect.left;
      bisectCenter = bisector(number).center;
      bisect_default = bisectRight;
    }
  });

  // ../../node_modules/.pnpm/internmap@2.0.3/node_modules/internmap/src/index.js
  function intern_get({ _intern, _key }, value2) {
    const key = _key(value2);
    return _intern.has(key) ? _intern.get(key) : value2;
  }
  function intern_set({ _intern, _key }, value2) {
    const key = _key(value2);
    if (_intern.has(key)) return _intern.get(key);
    _intern.set(key, value2);
    return value2;
  }
  function intern_delete({ _intern, _key }, value2) {
    const key = _key(value2);
    if (_intern.has(key)) {
      value2 = _intern.get(key);
      _intern.delete(key);
    }
    return value2;
  }
  function keyof(value2) {
    return value2 !== null && typeof value2 === "object" ? value2.valueOf() : value2;
  }
  var InternMap;
  var init_src = __esm({
    "../../node_modules/.pnpm/internmap@2.0.3/node_modules/internmap/src/index.js"() {
      "use strict";
      InternMap = class extends Map {
        static {
          __name(this, "InternMap");
        }
        constructor(entries2, key = keyof) {
          super();
          Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
          if (entries2 != null) for (const [key2, value2] of entries2) this.set(key2, value2);
        }
        get(key) {
          return super.get(intern_get(this, key));
        }
        has(key) {
          return super.has(intern_get(this, key));
        }
        set(key, value2) {
          return super.set(intern_set(this, key), value2);
        }
        delete(key) {
          return super.delete(intern_delete(this, key));
        }
      };
      __name(intern_get, "intern_get");
      __name(intern_set, "intern_set");
      __name(intern_delete, "intern_delete");
      __name(keyof, "keyof");
    }
  });

  // ../../node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/ticks.js
  function tickSpec(start3, stop5, count) {
    const step3 = (stop5 - start3) / Math.max(0, count), power = Math.floor(Math.log10(step3)), error3 = step3 / Math.pow(10, power), factor = error3 >= e10 ? 10 : error3 >= e5 ? 5 : error3 >= e2 ? 2 : 1;
    let i1, i2, inc;
    if (power < 0) {
      inc = Math.pow(10, -power) / factor;
      i1 = Math.round(start3 * inc);
      i2 = Math.round(stop5 * inc);
      if (i1 / inc < start3) ++i1;
      if (i2 / inc > stop5) --i2;
      inc = -inc;
    } else {
      inc = Math.pow(10, power) * factor;
      i1 = Math.round(start3 / inc);
      i2 = Math.round(stop5 / inc);
      if (i1 * inc < start3) ++i1;
      if (i2 * inc > stop5) --i2;
    }
    if (i2 < i1 && 0.5 <= count && count < 2) return tickSpec(start3, stop5, count * 2);
    return [i1, i2, inc];
  }
  function ticks(start3, stop5, count) {
    stop5 = +stop5, start3 = +start3, count = +count;
    if (!(count > 0)) return [];
    if (start3 === stop5) return [start3];
    const reverse2 = stop5 < start3, [i1, i2, inc] = reverse2 ? tickSpec(stop5, start3, count) : tickSpec(start3, stop5, count);
    if (!(i2 >= i1)) return [];
    const n2 = i2 - i1 + 1, ticks2 = new Array(n2);
    if (reverse2) {
      if (inc < 0) for (let i3 = 0; i3 < n2; ++i3) ticks2[i3] = (i2 - i3) / -inc;
      else for (let i3 = 0; i3 < n2; ++i3) ticks2[i3] = (i2 - i3) * inc;
    } else {
      if (inc < 0) for (let i3 = 0; i3 < n2; ++i3) ticks2[i3] = (i1 + i3) / -inc;
      else for (let i3 = 0; i3 < n2; ++i3) ticks2[i3] = (i1 + i3) * inc;
    }
    return ticks2;
  }
  function tickIncrement(start3, stop5, count) {
    stop5 = +stop5, start3 = +start3, count = +count;
    return tickSpec(start3, stop5, count)[2];
  }
  function tickStep(start3, stop5, count) {
    stop5 = +stop5, start3 = +start3, count = +count;
    const reverse2 = stop5 < start3, inc = reverse2 ? tickIncrement(stop5, start3, count) : tickIncrement(start3, stop5, count);
    return (reverse2 ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
  }
  var e10, e5, e2;
  var init_ticks = __esm({
    "../../node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/ticks.js"() {
      "use strict";
      e10 = Math.sqrt(50);
      e5 = Math.sqrt(10);
      e2 = Math.sqrt(2);
      __name(tickSpec, "tickSpec");
      __name(ticks, "ticks");
      __name(tickIncrement, "tickIncrement");
      __name(tickStep, "tickStep");
    }
  });

  // ../../node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/max.js
  function max(values2, valueof) {
    let max10;
    if (valueof === void 0) {
      for (const value2 of values2) {
        if (value2 != null && (max10 < value2 || max10 === void 0 && value2 >= value2)) {
          max10 = value2;
        }
      }
    } else {
      let index = -1;
      for (let value2 of values2) {
        if ((value2 = valueof(value2, ++index, values2)) != null && (max10 < value2 || max10 === void 0 && value2 >= value2)) {
          max10 = value2;
        }
      }
    }
    return max10;
  }
  var init_max = __esm({
    "../../node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/max.js"() {
      "use strict";
      __name(max, "max");
    }
  });

  // ../../node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/min.js
  function min(values2, valueof) {
    let min9;
    if (valueof === void 0) {
      for (const value2 of values2) {
        if (value2 != null && (min9 > value2 || min9 === void 0 && value2 >= value2)) {
          min9 = value2;
        }
      }
    } else {
      let index = -1;
      for (let value2 of values2) {
        if ((value2 = valueof(value2, ++index, values2)) != null && (min9 > value2 || min9 === void 0 && value2 >= value2)) {
          min9 = value2;
        }
      }
    }
    return min9;
  }
  var init_min = __esm({
    "../../node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/min.js"() {
      "use strict";
      __name(min, "min");
    }
  });

  // ../../node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/range.js
  function range(start3, stop5, step3) {
    start3 = +start3, stop5 = +stop5, step3 = (n2 = arguments.length) < 2 ? (stop5 = start3, start3 = 0, 1) : n2 < 3 ? 1 : +step3;
    var i2 = -1, n2 = Math.max(0, Math.ceil((stop5 - start3) / step3)) | 0, range3 = new Array(n2);
    while (++i2 < n2) {
      range3[i2] = start3 + i2 * step3;
    }
    return range3;
  }
  var init_range = __esm({
    "../../node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/range.js"() {
      "use strict";
      __name(range, "range");
    }
  });

  // ../../node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/index.js
  var init_src2 = __esm({
    "../../node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/index.js"() {
      "use strict";
      init_bisect();
      init_bisector();
      init_max();
      init_min();
      init_range();
      init_ticks();
      init_src();
    }
  });

  // ../../node_modules/.pnpm/d3-axis@3.0.0/node_modules/d3-axis/src/identity.js
  function identity_default(x5) {
    return x5;
  }
  var init_identity = __esm({
    "../../node_modules/.pnpm/d3-axis@3.0.0/node_modules/d3-axis/src/identity.js"() {
      "use strict";
      __name(identity_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-axis@3.0.0/node_modules/d3-axis/src/axis.js
  function translateX(x5) {
    return "translate(" + x5 + ",0)";
  }
  function translateY(y5) {
    return "translate(0," + y5 + ")";
  }
  function number2(scale) {
    return (d2) => +scale(d2);
  }
  function center(scale, offset) {
    offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
    if (scale.round()) offset = Math.round(offset);
    return (d2) => +scale(d2) + offset;
  }
  function entering() {
    return !this.__axis;
  }
  function axis(orient, scale) {
    var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k2 = orient === top || orient === left ? -1 : 1, x5 = orient === left || orient === right ? "x" : "y", transform8 = orient === top || orient === bottom ? translateX : translateY;
    function axis2(context) {
      var values2 = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues, format3 = tickFormat2 == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity_default : tickFormat2, spacing2 = Math.max(tickSizeInner, 0) + tickPadding, range3 = scale.range(), range0 = +range3[0] + offset, range1 = +range3[range3.length - 1] + offset, position5 = (scale.bandwidth ? center : number2)(scale.copy(), offset), selection2 = context.selection ? context.selection() : context, path4 = selection2.selectAll(".domain").data([null]), tick = selection2.selectAll(".tick").data(values2, scale).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line2 = tick.select("line"), text4 = tick.select("text");
      path4 = path4.merge(path4.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
      tick = tick.merge(tickEnter);
      line2 = line2.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x5 + "2", k2 * tickSizeInner));
      text4 = text4.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x5, k2 * spacing2).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
      if (context !== selection2) {
        path4 = path4.transition(context);
        tick = tick.transition(context);
        line2 = line2.transition(context);
        text4 = text4.transition(context);
        tickExit = tickExit.transition(context).attr("opacity", epsilon).attr("transform", function(d2) {
          return isFinite(d2 = position5(d2)) ? transform8(d2 + offset) : this.getAttribute("transform");
        });
        tickEnter.attr("opacity", epsilon).attr("transform", function(d2) {
          var p3 = this.parentNode.__axis;
          return transform8((p3 && isFinite(p3 = p3(d2)) ? p3 : position5(d2)) + offset);
        });
      }
      tickExit.remove();
      path4.attr("d", orient === left || orient === right ? tickSizeOuter ? "M" + k2 * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k2 * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k2 * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k2 * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1);
      tick.attr("opacity", 1).attr("transform", function(d2) {
        return transform8(position5(d2) + offset);
      });
      line2.attr(x5 + "2", k2 * tickSizeInner);
      text4.attr(x5, k2 * spacing2).text(format3);
      selection2.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
      selection2.each(function() {
        this.__axis = position5;
      });
    }
    __name(axis2, "axis");
    axis2.scale = function(_2) {
      return arguments.length ? (scale = _2, axis2) : scale;
    };
    axis2.ticks = function() {
      return tickArguments = Array.from(arguments), axis2;
    };
    axis2.tickArguments = function(_2) {
      return arguments.length ? (tickArguments = _2 == null ? [] : Array.from(_2), axis2) : tickArguments.slice();
    };
    axis2.tickValues = function(_2) {
      return arguments.length ? (tickValues = _2 == null ? null : Array.from(_2), axis2) : tickValues && tickValues.slice();
    };
    axis2.tickFormat = function(_2) {
      return arguments.length ? (tickFormat2 = _2, axis2) : tickFormat2;
    };
    axis2.tickSize = function(_2) {
      return arguments.length ? (tickSizeInner = tickSizeOuter = +_2, axis2) : tickSizeInner;
    };
    axis2.tickSizeInner = function(_2) {
      return arguments.length ? (tickSizeInner = +_2, axis2) : tickSizeInner;
    };
    axis2.tickSizeOuter = function(_2) {
      return arguments.length ? (tickSizeOuter = +_2, axis2) : tickSizeOuter;
    };
    axis2.tickPadding = function(_2) {
      return arguments.length ? (tickPadding = +_2, axis2) : tickPadding;
    };
    axis2.offset = function(_2) {
      return arguments.length ? (offset = +_2, axis2) : offset;
    };
    return axis2;
  }
  function axisTop(scale) {
    return axis(top, scale);
  }
  function axisBottom(scale) {
    return axis(bottom, scale);
  }
  var top, right, bottom, left, epsilon;
  var init_axis = __esm({
    "../../node_modules/.pnpm/d3-axis@3.0.0/node_modules/d3-axis/src/axis.js"() {
      "use strict";
      init_identity();
      top = 1;
      right = 2;
      bottom = 3;
      left = 4;
      epsilon = 1e-6;
      __name(translateX, "translateX");
      __name(translateY, "translateY");
      __name(number2, "number");
      __name(center, "center");
      __name(entering, "entering");
      __name(axis, "axis");
      __name(axisTop, "axisTop");
      __name(axisBottom, "axisBottom");
    }
  });

  // ../../node_modules/.pnpm/d3-axis@3.0.0/node_modules/d3-axis/src/index.js
  var init_src3 = __esm({
    "../../node_modules/.pnpm/d3-axis@3.0.0/node_modules/d3-axis/src/index.js"() {
      "use strict";
      init_axis();
    }
  });

  // ../../node_modules/.pnpm/d3-dispatch@3.0.1/node_modules/d3-dispatch/src/dispatch.js
  function dispatch() {
    for (var i2 = 0, n2 = arguments.length, _2 = {}, t4; i2 < n2; ++i2) {
      if (!(t4 = arguments[i2] + "") || t4 in _2 || /[\s.]/.test(t4)) throw new Error("illegal type: " + t4);
      _2[t4] = [];
    }
    return new Dispatch(_2);
  }
  function Dispatch(_2) {
    this._ = _2;
  }
  function parseTypenames(typenames, types) {
    return typenames.trim().split(/^|\s+/).map(function(t4) {
      var name = "", i2 = t4.indexOf(".");
      if (i2 >= 0) name = t4.slice(i2 + 1), t4 = t4.slice(0, i2);
      if (t4 && !types.hasOwnProperty(t4)) throw new Error("unknown type: " + t4);
      return { type: t4, name };
    });
  }
  function get(type3, name) {
    for (var i2 = 0, n2 = type3.length, c3; i2 < n2; ++i2) {
      if ((c3 = type3[i2]).name === name) {
        return c3.value;
      }
    }
  }
  function set(type3, name, callback) {
    for (var i2 = 0, n2 = type3.length; i2 < n2; ++i2) {
      if (type3[i2].name === name) {
        type3[i2] = noop, type3 = type3.slice(0, i2).concat(type3.slice(i2 + 1));
        break;
      }
    }
    if (callback != null) type3.push({ name, value: callback });
    return type3;
  }
  var noop, dispatch_default;
  var init_dispatch = __esm({
    "../../node_modules/.pnpm/d3-dispatch@3.0.1/node_modules/d3-dispatch/src/dispatch.js"() {
      "use strict";
      noop = { value: /* @__PURE__ */ __name(() => {
      }, "value") };
      __name(dispatch, "dispatch");
      __name(Dispatch, "Dispatch");
      __name(parseTypenames, "parseTypenames");
      Dispatch.prototype = dispatch.prototype = {
        constructor: Dispatch,
        on: /* @__PURE__ */ __name(function(typename, callback) {
          var _2 = this._, T3 = parseTypenames(typename + "", _2), t4, i2 = -1, n2 = T3.length;
          if (arguments.length < 2) {
            while (++i2 < n2) if ((t4 = (typename = T3[i2]).type) && (t4 = get(_2[t4], typename.name))) return t4;
            return;
          }
          if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
          while (++i2 < n2) {
            if (t4 = (typename = T3[i2]).type) _2[t4] = set(_2[t4], typename.name, callback);
            else if (callback == null) for (t4 in _2) _2[t4] = set(_2[t4], typename.name, null);
          }
          return this;
        }, "on"),
        copy: /* @__PURE__ */ __name(function() {
          var copy5 = {}, _2 = this._;
          for (var t4 in _2) copy5[t4] = _2[t4].slice();
          return new Dispatch(copy5);
        }, "copy"),
        call: /* @__PURE__ */ __name(function(type3, that) {
          if ((n2 = arguments.length - 2) > 0) for (var args = new Array(n2), i2 = 0, n2, t4; i2 < n2; ++i2) args[i2] = arguments[i2 + 2];
          if (!this._.hasOwnProperty(type3)) throw new Error("unknown type: " + type3);
          for (t4 = this._[type3], i2 = 0, n2 = t4.length; i2 < n2; ++i2) t4[i2].value.apply(that, args);
        }, "call"),
        apply: /* @__PURE__ */ __name(function(type3, that, args) {
          if (!this._.hasOwnProperty(type3)) throw new Error("unknown type: " + type3);
          for (var t4 = this._[type3], i2 = 0, n2 = t4.length; i2 < n2; ++i2) t4[i2].value.apply(that, args);
        }, "apply")
      };
      __name(get, "get");
      __name(set, "set");
      dispatch_default = dispatch;
    }
  });

  // ../../node_modules/.pnpm/d3-dispatch@3.0.1/node_modules/d3-dispatch/src/index.js
  var init_src4 = __esm({
    "../../node_modules/.pnpm/d3-dispatch@3.0.1/node_modules/d3-dispatch/src/index.js"() {
      "use strict";
      init_dispatch();
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/namespaces.js
  var xhtml, namespaces_default;
  var init_namespaces = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/namespaces.js"() {
      "use strict";
      xhtml = "http://www.w3.org/1999/xhtml";
      namespaces_default = {
        svg: "http://www.w3.org/2000/svg",
        xhtml,
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
      };
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/namespace.js
  function namespace_default(name) {
    var prefix = name += "", i2 = prefix.indexOf(":");
    if (i2 >= 0 && (prefix = name.slice(0, i2)) !== "xmlns") name = name.slice(i2 + 1);
    return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
  }
  var init_namespace = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/namespace.js"() {
      "use strict";
      init_namespaces();
      __name(namespace_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/creator.js
  function creatorInherit(name) {
    return function() {
      var document2 = this.ownerDocument, uri = this.namespaceURI;
      return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
    };
  }
  function creatorFixed(fullname) {
    return function() {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }
  function creator_default(name) {
    var fullname = namespace_default(name);
    return (fullname.local ? creatorFixed : creatorInherit)(fullname);
  }
  var init_creator = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/creator.js"() {
      "use strict";
      init_namespace();
      init_namespaces();
      __name(creatorInherit, "creatorInherit");
      __name(creatorFixed, "creatorFixed");
      __name(creator_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selector.js
  function none() {
  }
  function selector_default(selector) {
    return selector == null ? none : function() {
      return this.querySelector(selector);
    };
  }
  var init_selector = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selector.js"() {
      "use strict";
      __name(none, "none");
      __name(selector_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/select.js
  function select_default(select) {
    if (typeof select !== "function") select = selector_default(select);
    for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
      for (var group2 = groups[j2], n2 = group2.length, subgroup = subgroups[j2] = new Array(n2), node2, subnode, i2 = 0; i2 < n2; ++i2) {
        if ((node2 = group2[i2]) && (subnode = select.call(node2, node2.__data__, i2, group2))) {
          if ("__data__" in node2) subnode.__data__ = node2.__data__;
          subgroup[i2] = subnode;
        }
      }
    }
    return new Selection(subgroups, this._parents);
  }
  var init_select = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/select.js"() {
      "use strict";
      init_selection();
      init_selector();
      __name(select_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/array.js
  function array(x5) {
    return x5 == null ? [] : Array.isArray(x5) ? x5 : Array.from(x5);
  }
  var init_array = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/array.js"() {
      "use strict";
      __name(array, "array");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selectorAll.js
  function empty() {
    return [];
  }
  function selectorAll_default(selector) {
    return selector == null ? empty : function() {
      return this.querySelectorAll(selector);
    };
  }
  var init_selectorAll = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selectorAll.js"() {
      "use strict";
      __name(empty, "empty");
      __name(selectorAll_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/selectAll.js
  function arrayAll(select) {
    return function() {
      return array(select.apply(this, arguments));
    };
  }
  function selectAll_default(select) {
    if (typeof select === "function") select = arrayAll(select);
    else select = selectorAll_default(select);
    for (var groups = this._groups, m2 = groups.length, subgroups = [], parents3 = [], j2 = 0; j2 < m2; ++j2) {
      for (var group2 = groups[j2], n2 = group2.length, node2, i2 = 0; i2 < n2; ++i2) {
        if (node2 = group2[i2]) {
          subgroups.push(select.call(node2, node2.__data__, i2, group2));
          parents3.push(node2);
        }
      }
    }
    return new Selection(subgroups, parents3);
  }
  var init_selectAll = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/selectAll.js"() {
      "use strict";
      init_selection();
      init_array();
      init_selectorAll();
      __name(arrayAll, "arrayAll");
      __name(selectAll_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/matcher.js
  function matcher_default(selector) {
    return function() {
      return this.matches(selector);
    };
  }
  function childMatcher(selector) {
    return function(node2) {
      return node2.matches(selector);
    };
  }
  var init_matcher = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/matcher.js"() {
      "use strict";
      __name(matcher_default, "default");
      __name(childMatcher, "childMatcher");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/selectChild.js
  function childFind(match2) {
    return function() {
      return find.call(this.children, match2);
    };
  }
  function childFirst() {
    return this.firstElementChild;
  }
  function selectChild_default(match2) {
    return this.select(match2 == null ? childFirst : childFind(typeof match2 === "function" ? match2 : childMatcher(match2)));
  }
  var find;
  var init_selectChild = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/selectChild.js"() {
      "use strict";
      init_matcher();
      find = Array.prototype.find;
      __name(childFind, "childFind");
      __name(childFirst, "childFirst");
      __name(selectChild_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/selectChildren.js
  function children() {
    return Array.from(this.children);
  }
  function childrenFilter(match2) {
    return function() {
      return filter.call(this.children, match2);
    };
  }
  function selectChildren_default(match2) {
    return this.selectAll(match2 == null ? children : childrenFilter(typeof match2 === "function" ? match2 : childMatcher(match2)));
  }
  var filter;
  var init_selectChildren = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/selectChildren.js"() {
      "use strict";
      init_matcher();
      filter = Array.prototype.filter;
      __name(children, "children");
      __name(childrenFilter, "childrenFilter");
      __name(selectChildren_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/filter.js
  function filter_default(match2) {
    if (typeof match2 !== "function") match2 = matcher_default(match2);
    for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
      for (var group2 = groups[j2], n2 = group2.length, subgroup = subgroups[j2] = [], node2, i2 = 0; i2 < n2; ++i2) {
        if ((node2 = group2[i2]) && match2.call(node2, node2.__data__, i2, group2)) {
          subgroup.push(node2);
        }
      }
    }
    return new Selection(subgroups, this._parents);
  }
  var init_filter = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/filter.js"() {
      "use strict";
      init_selection();
      init_matcher();
      __name(filter_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/sparse.js
  function sparse_default(update2) {
    return new Array(update2.length);
  }
  var init_sparse = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/sparse.js"() {
      "use strict";
      __name(sparse_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/enter.js
  function enter_default() {
    return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
  }
  function EnterNode(parent4, datum2) {
    this.ownerDocument = parent4.ownerDocument;
    this.namespaceURI = parent4.namespaceURI;
    this._next = null;
    this._parent = parent4;
    this.__data__ = datum2;
  }
  var init_enter = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/enter.js"() {
      "use strict";
      init_sparse();
      init_selection();
      __name(enter_default, "default");
      __name(EnterNode, "EnterNode");
      EnterNode.prototype = {
        constructor: EnterNode,
        appendChild: /* @__PURE__ */ __name(function(child) {
          return this._parent.insertBefore(child, this._next);
        }, "appendChild"),
        insertBefore: /* @__PURE__ */ __name(function(child, next3) {
          return this._parent.insertBefore(child, next3);
        }, "insertBefore"),
        querySelector: /* @__PURE__ */ __name(function(selector) {
          return this._parent.querySelector(selector);
        }, "querySelector"),
        querySelectorAll: /* @__PURE__ */ __name(function(selector) {
          return this._parent.querySelectorAll(selector);
        }, "querySelectorAll")
      };
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/constant.js
  function constant_default(x5) {
    return function() {
      return x5;
    };
  }
  var init_constant = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/constant.js"() {
      "use strict";
      __name(constant_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/data.js
  function bindIndex(parent4, group2, enter, update2, exit, data5) {
    var i2 = 0, node2, groupLength3 = group2.length, dataLength = data5.length;
    for (; i2 < dataLength; ++i2) {
      if (node2 = group2[i2]) {
        node2.__data__ = data5[i2];
        update2[i2] = node2;
      } else {
        enter[i2] = new EnterNode(parent4, data5[i2]);
      }
    }
    for (; i2 < groupLength3; ++i2) {
      if (node2 = group2[i2]) {
        exit[i2] = node2;
      }
    }
  }
  function bindKey(parent4, group2, enter, update2, exit, data5, key) {
    var i2, node2, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength3 = group2.length, dataLength = data5.length, keyValues = new Array(groupLength3), keyValue;
    for (i2 = 0; i2 < groupLength3; ++i2) {
      if (node2 = group2[i2]) {
        keyValues[i2] = keyValue = key.call(node2, node2.__data__, i2, group2) + "";
        if (nodeByKeyValue.has(keyValue)) {
          exit[i2] = node2;
        } else {
          nodeByKeyValue.set(keyValue, node2);
        }
      }
    }
    for (i2 = 0; i2 < dataLength; ++i2) {
      keyValue = key.call(parent4, data5[i2], i2, data5) + "";
      if (node2 = nodeByKeyValue.get(keyValue)) {
        update2[i2] = node2;
        node2.__data__ = data5[i2];
        nodeByKeyValue.delete(keyValue);
      } else {
        enter[i2] = new EnterNode(parent4, data5[i2]);
      }
    }
    for (i2 = 0; i2 < groupLength3; ++i2) {
      if ((node2 = group2[i2]) && nodeByKeyValue.get(keyValues[i2]) === node2) {
        exit[i2] = node2;
      }
    }
  }
  function datum(node2) {
    return node2.__data__;
  }
  function data_default(value2, key) {
    if (!arguments.length) return Array.from(this, datum);
    var bind = key ? bindKey : bindIndex, parents3 = this._parents, groups = this._groups;
    if (typeof value2 !== "function") value2 = constant_default(value2);
    for (var m2 = groups.length, update2 = new Array(m2), enter = new Array(m2), exit = new Array(m2), j2 = 0; j2 < m2; ++j2) {
      var parent4 = parents3[j2], group2 = groups[j2], groupLength3 = group2.length, data5 = arraylike(value2.call(parent4, parent4 && parent4.__data__, j2, parents3)), dataLength = data5.length, enterGroup = enter[j2] = new Array(dataLength), updateGroup = update2[j2] = new Array(dataLength), exitGroup = exit[j2] = new Array(groupLength3);
      bind(parent4, group2, enterGroup, updateGroup, exitGroup, data5, key);
      for (var i0 = 0, i1 = 0, previous, next3; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i1) i1 = i0 + 1;
          while (!(next3 = updateGroup[i1]) && ++i1 < dataLength) ;
          previous._next = next3 || null;
        }
      }
    }
    update2 = new Selection(update2, parents3);
    update2._enter = enter;
    update2._exit = exit;
    return update2;
  }
  function arraylike(data5) {
    return typeof data5 === "object" && "length" in data5 ? data5 : Array.from(data5);
  }
  var init_data = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/data.js"() {
      "use strict";
      init_selection();
      init_enter();
      init_constant();
      __name(bindIndex, "bindIndex");
      __name(bindKey, "bindKey");
      __name(datum, "datum");
      __name(data_default, "default");
      __name(arraylike, "arraylike");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/exit.js
  function exit_default() {
    return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
  }
  var init_exit = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/exit.js"() {
      "use strict";
      init_sparse();
      init_selection();
      __name(exit_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/join.js
  function join_default(onenter, onupdate, onexit) {
    var enter = this.enter(), update2 = this, exit = this.exit();
    if (typeof onenter === "function") {
      enter = onenter(enter);
      if (enter) enter = enter.selection();
    } else {
      enter = enter.append(onenter + "");
    }
    if (onupdate != null) {
      update2 = onupdate(update2);
      if (update2) update2 = update2.selection();
    }
    if (onexit == null) exit.remove();
    else onexit(exit);
    return enter && update2 ? enter.merge(update2).order() : update2;
  }
  var init_join = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/join.js"() {
      "use strict";
      __name(join_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/merge.js
  function merge_default(context) {
    var selection2 = context.selection ? context.selection() : context;
    for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m2; ++j2) {
      for (var group0 = groups0[j2], group1 = groups1[j2], n2 = group0.length, merge5 = merges[j2] = new Array(n2), node2, i2 = 0; i2 < n2; ++i2) {
        if (node2 = group0[i2] || group1[i2]) {
          merge5[i2] = node2;
        }
      }
    }
    for (; j2 < m0; ++j2) {
      merges[j2] = groups0[j2];
    }
    return new Selection(merges, this._parents);
  }
  var init_merge2 = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/merge.js"() {
      "use strict";
      init_selection();
      __name(merge_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/order.js
  function order_default() {
    for (var groups = this._groups, j2 = -1, m2 = groups.length; ++j2 < m2; ) {
      for (var group2 = groups[j2], i2 = group2.length - 1, next3 = group2[i2], node2; --i2 >= 0; ) {
        if (node2 = group2[i2]) {
          if (next3 && node2.compareDocumentPosition(next3) ^ 4) next3.parentNode.insertBefore(node2, next3);
          next3 = node2;
        }
      }
    }
    return this;
  }
  var init_order = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/order.js"() {
      "use strict";
      __name(order_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/sort.js
  function sort_default(compare) {
    if (!compare) compare = ascending2;
    function compareNode(a2, b2) {
      return a2 && b2 ? compare(a2.__data__, b2.__data__) : !a2 - !b2;
    }
    __name(compareNode, "compareNode");
    for (var groups = this._groups, m2 = groups.length, sortgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
      for (var group2 = groups[j2], n2 = group2.length, sortgroup = sortgroups[j2] = new Array(n2), node2, i2 = 0; i2 < n2; ++i2) {
        if (node2 = group2[i2]) {
          sortgroup[i2] = node2;
        }
      }
      sortgroup.sort(compareNode);
    }
    return new Selection(sortgroups, this._parents).order();
  }
  function ascending2(a2, b2) {
    return a2 < b2 ? -1 : a2 > b2 ? 1 : a2 >= b2 ? 0 : NaN;
  }
  var init_sort = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/sort.js"() {
      "use strict";
      init_selection();
      __name(sort_default, "default");
      __name(ascending2, "ascending");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/call.js
  function call_default() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  }
  var init_call = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/call.js"() {
      "use strict";
      __name(call_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/nodes.js
  function nodes_default() {
    return Array.from(this);
  }
  var init_nodes = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/nodes.js"() {
      "use strict";
      __name(nodes_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/node.js
  function node_default() {
    for (var groups = this._groups, j2 = 0, m2 = groups.length; j2 < m2; ++j2) {
      for (var group2 = groups[j2], i2 = 0, n2 = group2.length; i2 < n2; ++i2) {
        var node2 = group2[i2];
        if (node2) return node2;
      }
    }
    return null;
  }
  var init_node = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/node.js"() {
      "use strict";
      __name(node_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/size.js
  function size_default() {
    let size5 = 0;
    for (const node2 of this) ++size5;
    return size5;
  }
  var init_size2 = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/size.js"() {
      "use strict";
      __name(size_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/empty.js
  function empty_default() {
    return !this.node();
  }
  var init_empty = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/empty.js"() {
      "use strict";
      __name(empty_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/each.js
  function each_default(callback) {
    for (var groups = this._groups, j2 = 0, m2 = groups.length; j2 < m2; ++j2) {
      for (var group2 = groups[j2], i2 = 0, n2 = group2.length, node2; i2 < n2; ++i2) {
        if (node2 = group2[i2]) callback.call(node2, node2.__data__, i2, group2);
      }
    }
    return this;
  }
  var init_each = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/each.js"() {
      "use strict";
      __name(each_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/attr.js
  function attrRemove(name) {
    return function() {
      this.removeAttribute(name);
    };
  }
  function attrRemoveNS(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }
  function attrConstant(name, value2) {
    return function() {
      this.setAttribute(name, value2);
    };
  }
  function attrConstantNS(fullname, value2) {
    return function() {
      this.setAttributeNS(fullname.space, fullname.local, value2);
    };
  }
  function attrFunction(name, value2) {
    return function() {
      var v3 = value2.apply(this, arguments);
      if (v3 == null) this.removeAttribute(name);
      else this.setAttribute(name, v3);
    };
  }
  function attrFunctionNS(fullname, value2) {
    return function() {
      var v3 = value2.apply(this, arguments);
      if (v3 == null) this.removeAttributeNS(fullname.space, fullname.local);
      else this.setAttributeNS(fullname.space, fullname.local, v3);
    };
  }
  function attr_default(name, value2) {
    var fullname = namespace_default(name);
    if (arguments.length < 2) {
      var node2 = this.node();
      return fullname.local ? node2.getAttributeNS(fullname.space, fullname.local) : node2.getAttribute(fullname);
    }
    return this.each((value2 == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value2 === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value2));
  }
  var init_attr = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/attr.js"() {
      "use strict";
      init_namespace();
      __name(attrRemove, "attrRemove");
      __name(attrRemoveNS, "attrRemoveNS");
      __name(attrConstant, "attrConstant");
      __name(attrConstantNS, "attrConstantNS");
      __name(attrFunction, "attrFunction");
      __name(attrFunctionNS, "attrFunctionNS");
      __name(attr_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/window.js
  function window_default(node2) {
    return node2.ownerDocument && node2.ownerDocument.defaultView || node2.document && node2 || node2.defaultView;
  }
  var init_window = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/window.js"() {
      "use strict";
      __name(window_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/style.js
  function styleRemove(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }
  function styleConstant(name, value2, priority3) {
    return function() {
      this.style.setProperty(name, value2, priority3);
    };
  }
  function styleFunction(name, value2, priority3) {
    return function() {
      var v3 = value2.apply(this, arguments);
      if (v3 == null) this.style.removeProperty(name);
      else this.style.setProperty(name, v3, priority3);
    };
  }
  function style_default(name, value2, priority3) {
    return arguments.length > 1 ? this.each((value2 == null ? styleRemove : typeof value2 === "function" ? styleFunction : styleConstant)(name, value2, priority3 == null ? "" : priority3)) : styleValue(this.node(), name);
  }
  function styleValue(node2, name) {
    return node2.style.getPropertyValue(name) || window_default(node2).getComputedStyle(node2, null).getPropertyValue(name);
  }
  var init_style = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/style.js"() {
      "use strict";
      init_window();
      __name(styleRemove, "styleRemove");
      __name(styleConstant, "styleConstant");
      __name(styleFunction, "styleFunction");
      __name(style_default, "default");
      __name(styleValue, "styleValue");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/property.js
  function propertyRemove(name) {
    return function() {
      delete this[name];
    };
  }
  function propertyConstant(name, value2) {
    return function() {
      this[name] = value2;
    };
  }
  function propertyFunction(name, value2) {
    return function() {
      var v3 = value2.apply(this, arguments);
      if (v3 == null) delete this[name];
      else this[name] = v3;
    };
  }
  function property_default(name, value2) {
    return arguments.length > 1 ? this.each((value2 == null ? propertyRemove : typeof value2 === "function" ? propertyFunction : propertyConstant)(name, value2)) : this.node()[name];
  }
  var init_property = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/property.js"() {
      "use strict";
      __name(propertyRemove, "propertyRemove");
      __name(propertyConstant, "propertyConstant");
      __name(propertyFunction, "propertyFunction");
      __name(property_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/classed.js
  function classArray(string3) {
    return string3.trim().split(/^|\s+/);
  }
  function classList(node2) {
    return node2.classList || new ClassList(node2);
  }
  function ClassList(node2) {
    this._node = node2;
    this._names = classArray(node2.getAttribute("class") || "");
  }
  function classedAdd(node2, names) {
    var list2 = classList(node2), i2 = -1, n2 = names.length;
    while (++i2 < n2) list2.add(names[i2]);
  }
  function classedRemove(node2, names) {
    var list2 = classList(node2), i2 = -1, n2 = names.length;
    while (++i2 < n2) list2.remove(names[i2]);
  }
  function classedTrue(names) {
    return function() {
      classedAdd(this, names);
    };
  }
  function classedFalse(names) {
    return function() {
      classedRemove(this, names);
    };
  }
  function classedFunction(names, value2) {
    return function() {
      (value2.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
    };
  }
  function classed_default(name, value2) {
    var names = classArray(name + "");
    if (arguments.length < 2) {
      var list2 = classList(this.node()), i2 = -1, n2 = names.length;
      while (++i2 < n2) if (!list2.contains(names[i2])) return false;
      return true;
    }
    return this.each((typeof value2 === "function" ? classedFunction : value2 ? classedTrue : classedFalse)(names, value2));
  }
  var init_classed = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/classed.js"() {
      "use strict";
      __name(classArray, "classArray");
      __name(classList, "classList");
      __name(ClassList, "ClassList");
      ClassList.prototype = {
        add: /* @__PURE__ */ __name(function(name) {
          var i2 = this._names.indexOf(name);
          if (i2 < 0) {
            this._names.push(name);
            this._node.setAttribute("class", this._names.join(" "));
          }
        }, "add"),
        remove: /* @__PURE__ */ __name(function(name) {
          var i2 = this._names.indexOf(name);
          if (i2 >= 0) {
            this._names.splice(i2, 1);
            this._node.setAttribute("class", this._names.join(" "));
          }
        }, "remove"),
        contains: /* @__PURE__ */ __name(function(name) {
          return this._names.indexOf(name) >= 0;
        }, "contains")
      };
      __name(classedAdd, "classedAdd");
      __name(classedRemove, "classedRemove");
      __name(classedTrue, "classedTrue");
      __name(classedFalse, "classedFalse");
      __name(classedFunction, "classedFunction");
      __name(classed_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/text.js
  function textRemove() {
    this.textContent = "";
  }
  function textConstant(value2) {
    return function() {
      this.textContent = value2;
    };
  }
  function textFunction(value2) {
    return function() {
      var v3 = value2.apply(this, arguments);
      this.textContent = v3 == null ? "" : v3;
    };
  }
  function text_default(value2) {
    return arguments.length ? this.each(value2 == null ? textRemove : (typeof value2 === "function" ? textFunction : textConstant)(value2)) : this.node().textContent;
  }
  var init_text = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/text.js"() {
      "use strict";
      __name(textRemove, "textRemove");
      __name(textConstant, "textConstant");
      __name(textFunction, "textFunction");
      __name(text_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/html.js
  function htmlRemove() {
    this.innerHTML = "";
  }
  function htmlConstant(value2) {
    return function() {
      this.innerHTML = value2;
    };
  }
  function htmlFunction(value2) {
    return function() {
      var v3 = value2.apply(this, arguments);
      this.innerHTML = v3 == null ? "" : v3;
    };
  }
  function html_default(value2) {
    return arguments.length ? this.each(value2 == null ? htmlRemove : (typeof value2 === "function" ? htmlFunction : htmlConstant)(value2)) : this.node().innerHTML;
  }
  var init_html2 = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/html.js"() {
      "use strict";
      __name(htmlRemove, "htmlRemove");
      __name(htmlConstant, "htmlConstant");
      __name(htmlFunction, "htmlFunction");
      __name(html_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/raise.js
  function raise() {
    if (this.nextSibling) this.parentNode.appendChild(this);
  }
  function raise_default() {
    return this.each(raise);
  }
  var init_raise = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/raise.js"() {
      "use strict";
      __name(raise, "raise");
      __name(raise_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/lower.js
  function lower() {
    if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }
  function lower_default() {
    return this.each(lower);
  }
  var init_lower = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/lower.js"() {
      "use strict";
      __name(lower, "lower");
      __name(lower_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/append.js
  function append_default(name) {
    var create3 = typeof name === "function" ? name : creator_default(name);
    return this.select(function() {
      return this.appendChild(create3.apply(this, arguments));
    });
  }
  var init_append = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/append.js"() {
      "use strict";
      init_creator();
      __name(append_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/insert.js
  function constantNull() {
    return null;
  }
  function insert_default(name, before) {
    var create3 = typeof name === "function" ? name : creator_default(name), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
    return this.select(function() {
      return this.insertBefore(create3.apply(this, arguments), select.apply(this, arguments) || null);
    });
  }
  var init_insert = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/insert.js"() {
      "use strict";
      init_creator();
      init_selector();
      __name(constantNull, "constantNull");
      __name(insert_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/remove.js
  function remove() {
    var parent4 = this.parentNode;
    if (parent4) parent4.removeChild(this);
  }
  function remove_default() {
    return this.each(remove);
  }
  var init_remove = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/remove.js"() {
      "use strict";
      __name(remove, "remove");
      __name(remove_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/clone.js
  function selection_cloneShallow() {
    var clone6 = this.cloneNode(false), parent4 = this.parentNode;
    return parent4 ? parent4.insertBefore(clone6, this.nextSibling) : clone6;
  }
  function selection_cloneDeep() {
    var clone6 = this.cloneNode(true), parent4 = this.parentNode;
    return parent4 ? parent4.insertBefore(clone6, this.nextSibling) : clone6;
  }
  function clone_default(deep) {
    return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
  }
  var init_clone = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/clone.js"() {
      "use strict";
      __name(selection_cloneShallow, "selection_cloneShallow");
      __name(selection_cloneDeep, "selection_cloneDeep");
      __name(clone_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/datum.js
  function datum_default(value2) {
    return arguments.length ? this.property("__data__", value2) : this.node().__data__;
  }
  var init_datum = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/datum.js"() {
      "use strict";
      __name(datum_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/on.js
  function contextListener(listener) {
    return function(event3) {
      listener.call(this, event3, this.__data__);
    };
  }
  function parseTypenames2(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t4) {
      var name = "", i2 = t4.indexOf(".");
      if (i2 >= 0) name = t4.slice(i2 + 1), t4 = t4.slice(0, i2);
      return { type: t4, name };
    });
  }
  function onRemove(typename) {
    return function() {
      var on3 = this.__on;
      if (!on3) return;
      for (var j2 = 0, i2 = -1, m2 = on3.length, o2; j2 < m2; ++j2) {
        if (o2 = on3[j2], (!typename.type || o2.type === typename.type) && o2.name === typename.name) {
          this.removeEventListener(o2.type, o2.listener, o2.options);
        } else {
          on3[++i2] = o2;
        }
      }
      if (++i2) on3.length = i2;
      else delete this.__on;
    };
  }
  function onAdd(typename, value2, options3) {
    return function() {
      var on3 = this.__on, o2, listener = contextListener(value2);
      if (on3) for (var j2 = 0, m2 = on3.length; j2 < m2; ++j2) {
        if ((o2 = on3[j2]).type === typename.type && o2.name === typename.name) {
          this.removeEventListener(o2.type, o2.listener, o2.options);
          this.addEventListener(o2.type, o2.listener = listener, o2.options = options3);
          o2.value = value2;
          return;
        }
      }
      this.addEventListener(typename.type, listener, options3);
      o2 = { type: typename.type, name: typename.name, value: value2, listener, options: options3 };
      if (!on3) this.__on = [o2];
      else on3.push(o2);
    };
  }
  function on_default(typename, value2, options3) {
    var typenames = parseTypenames2(typename + ""), i2, n2 = typenames.length, t4;
    if (arguments.length < 2) {
      var on3 = this.node().__on;
      if (on3) for (var j2 = 0, m2 = on3.length, o2; j2 < m2; ++j2) {
        for (i2 = 0, o2 = on3[j2]; i2 < n2; ++i2) {
          if ((t4 = typenames[i2]).type === o2.type && t4.name === o2.name) {
            return o2.value;
          }
        }
      }
      return;
    }
    on3 = value2 ? onAdd : onRemove;
    for (i2 = 0; i2 < n2; ++i2) this.each(on3(typenames[i2], value2, options3));
    return this;
  }
  var init_on = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/on.js"() {
      "use strict";
      __name(contextListener, "contextListener");
      __name(parseTypenames2, "parseTypenames");
      __name(onRemove, "onRemove");
      __name(onAdd, "onAdd");
      __name(on_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/dispatch.js
  function dispatchEvent(node2, type3, params) {
    var window3 = window_default(node2), event3 = window3.CustomEvent;
    if (typeof event3 === "function") {
      event3 = new event3(type3, params);
    } else {
      event3 = window3.document.createEvent("Event");
      if (params) event3.initEvent(type3, params.bubbles, params.cancelable), event3.detail = params.detail;
      else event3.initEvent(type3, false, false);
    }
    node2.dispatchEvent(event3);
  }
  function dispatchConstant(type3, params) {
    return function() {
      return dispatchEvent(this, type3, params);
    };
  }
  function dispatchFunction(type3, params) {
    return function() {
      return dispatchEvent(this, type3, params.apply(this, arguments));
    };
  }
  function dispatch_default2(type3, params) {
    return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type3, params));
  }
  var init_dispatch2 = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/dispatch.js"() {
      "use strict";
      init_window();
      __name(dispatchEvent, "dispatchEvent");
      __name(dispatchConstant, "dispatchConstant");
      __name(dispatchFunction, "dispatchFunction");
      __name(dispatch_default2, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/iterator.js
  function* iterator_default() {
    for (var groups = this._groups, j2 = 0, m2 = groups.length; j2 < m2; ++j2) {
      for (var group2 = groups[j2], i2 = 0, n2 = group2.length, node2; i2 < n2; ++i2) {
        if (node2 = group2[i2]) yield node2;
      }
    }
  }
  var init_iterator = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/iterator.js"() {
      "use strict";
      __name(iterator_default, "default");
    }
  });

  // ../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/index.js
  function Selection(groups, parents3) {
    this._groups = groups;
    this._parents = parents3;
  }
  function selection() {
    return new Selection([[document.documentElement]], root);
  }
  function selection_selection() {
    return this;
  }
  var root, selection_default;
  var init_selection = __esm({
    "../../node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/index.js"() {
      "use strict";
      init_select();
      init_selectAll();
      init_selectChild();
      init_selectChildren();
      init_filter();
      init_data();
      init_enter();
      init_exit();
      init_join();
      init_merge2();
      init_order();
      init_sort();
      init_call();
      init_nodes();
      init_node();
      init_size2();
      init_empty();
      init_each();
      init_attr();
      init_style();
      init_property();
      init_classed();
      init_text();
      init_html2();
      init_raise();
      init_lower();
      init_append();
      init_insert();
      init_remove();
      init_clone();
      init_datum();
      init_on();
      init_dispatch2();
      init_iterator();
      root = [null];
      __name(Selection, "Selection");
      __name(selection, "selection");
      __name(selection_selection, "selection_selection");
      Selection.prototype = selection.prototype = {
        constructor: Selection,
        select: select_default,
        selectAll: selectAll_default,
        selectChild: selectChild_default,
        selectChildren: selectChildren_default,
        filter: filter_default,
        data: data_default,
        enter: enter_default,
        exit: exit_default,
        join: join_default,
        merge: merge_default,
        selection: selection_selection,
        order: order_default,
        sort: sort_default,
        call: call_default,
        nodes: nodes_default,
        node: node_default,
        size: size_default,
        empty: empty_default,
        each: each_default,
        attr: attr_default,
        style: style_default,
        property: property_default,
        classed: classed_default,
        text: text_default,
        html: html_default,
        raise: raise_default,
        lower: lower_default,
        append: append_def
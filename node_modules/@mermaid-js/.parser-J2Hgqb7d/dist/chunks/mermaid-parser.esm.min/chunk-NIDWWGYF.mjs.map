{
  "version": 3,
  "sources": ["../../../../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/ral.js", "../../../../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/is.js", "../../../../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/events.js", "../../../../../node_modules/.pnpm/vscode-jsonrpc@8.2.0/node_modules/vscode-jsonrpc/lib/common/cancellation.js", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/index.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/utils/cst-utils.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/syntax-tree.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/utils/stream.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/utils/grammar-utils.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/utils/errors.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/languages/generated/ast.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/utils/ast-utils.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/utils/regexp-utils.ts", "../../../../../node_modules/.pnpm/@chevrotain+regexp-to-ast@11.0.3/node_modules/@chevrotain/regexp-to-ast/src/utils.ts", "../../../../../node_modules/.pnpm/@chevrotain+regexp-to-ast@11.0.3/node_modules/@chevrotain/regexp-to-ast/src/character-classes.ts", "../../../../../node_modules/.pnpm/@chevrotain+regexp-to-ast@11.0.3/node_modules/@chevrotain/regexp-to-ast/src/regexp-parser.ts", "../../../../../node_modules/.pnpm/@chevrotain+regexp-to-ast@11.0.3/node_modules/@chevrotain/regexp-to-ast/src/base-regexp-visitor.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/languages/grammar-config.ts", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_freeGlobal.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_root.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Symbol.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getRawTag.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_objectToString.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseGetTag.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isObjectLike.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isSymbol.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayMap.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArray.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseToString.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_trimmedEndIndex.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseTrim.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isObject.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toNumber.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toFinite.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toInteger.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/identity.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isFunction.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_coreJsData.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isMasked.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_toSource.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsNative.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getValue.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getNative.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_WeakMap.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseCreate.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_apply.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/noop.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_copyArray.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_shortOut.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/constant.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_defineProperty.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseSetToString.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setToString.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayEach.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseFindIndex.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsNaN.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_strictIndexOf.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIndexOf.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayIncludes.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isIndex.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseAssignValue.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/eq.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_assignValue.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_copyObject.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_overRest.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseRest.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isLength.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArrayLike.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isIterateeCall.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createAssigner.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isPrototype.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseTimes.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsArguments.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArguments.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/stubFalse.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isBuffer.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsTypedArray.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseUnary.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nodeUtil.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isTypedArray.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayLikeKeys.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_overArg.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nativeKeys.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseKeys.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/keys.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/assign.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nativeKeysIn.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseKeysIn.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/keysIn.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isKey.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nativeCreate.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashClear.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashDelete.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashGet.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashHas.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashSet.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Hash.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheClear.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_assocIndexOf.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheDelete.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheGet.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheHas.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheSet.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_ListCache.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Map.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheClear.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isKeyable.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getMapData.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheDelete.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheGet.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheHas.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheSet.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_MapCache.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/memoize.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_memoizeCapped.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stringToPath.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toString.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_castPath.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_toKey.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseGet.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/get.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayPush.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isFlattenable.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseFlatten.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/flatten.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getPrototype.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseSlice.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayReduce.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackClear.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackDelete.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackGet.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackHas.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackSet.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Stack.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseAssign.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseAssignIn.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cloneBuffer.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayFilter.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/stubArray.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getSymbols.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_copySymbols.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getSymbolsIn.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_copySymbolsIn.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseGetAllKeys.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getAllKeys.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getAllKeysIn.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_DataView.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Promise.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Set.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getTag.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_initCloneArray.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Uint8Array.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cloneArrayBuffer.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cloneDataView.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cloneRegExp.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cloneSymbol.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cloneTypedArray.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_initCloneByTag.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_initCloneObject.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsMap.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isMap.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsSet.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isSet.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseClone.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/clone.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/compact.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setCacheAdd.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setCacheHas.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_SetCache.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arraySome.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cacheHas.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_equalArrays.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapToArray.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setToArray.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_equalByTag.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_equalObjects.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsEqualDeep.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsEqual.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsMatch.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isStrictComparable.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getMatchData.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_matchesStrictComparable.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseMatches.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseHasIn.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hasPath.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/hasIn.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseMatchesProperty.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseProperty.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_basePropertyDeep.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/property.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIteratee.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayAggregator.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createBaseFor.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseFor.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseForOwn.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createBaseEach.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseEach.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseAggregator.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createAggregator.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/defaults.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArrayLikeObject.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayIncludesWith.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseDifference.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/difference.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/last.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/drop.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/dropRight.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_castFunction.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/forEach.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayEvery.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseEvery.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/every.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseFilter.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/filter.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createFind.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/findIndex.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/find.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/head.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseMap.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/map.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/flatMap.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/groupBy.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseHas.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/has.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isString.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseValues.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/values.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/includes.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/indexOf.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isEmpty.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsRegExp.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isRegExp.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isUndefined.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseLt.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseExtremum.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/min.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/negate.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseSet.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_basePickBy.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/pickBy.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseReduce.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/reduce.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/reject.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseSome.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/some.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createSet.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseUniq.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/uniq.js", "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/uniqBy.js", "../../../../../node_modules/.pnpm/@chevrotain+utils@11.0.3/node_modules/@chevrotain/utils/src/print.ts", "../../../../../node_modules/.pnpm/@chevrotain+utils@11.0.3/node_modules/@chevrotain/utils/src/timer.ts", "../../../../../node_modules/.pnpm/@chevrotain+utils@11.0.3/node_modules/@chevrotain/utils/src/to-fast-properties.ts", "../../../../../node_modules/.pnpm/@chevrotain+gast@11.0.3/node_modules/@chevrotain/gast/src/model.ts", "../../../../../node_modules/.pnpm/@chevrotain+gast@11.0.3/node_modules/@chevrotain/gast/src/visitor.ts", "../../../../../node_modules/.pnpm/@chevrotain+gast@11.0.3/node_modules/@chevrotain/gast/src/helpers.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/parse/grammar/rest.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/parse/grammar/first.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/parse/constants.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/parse/grammar/follow.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/scan/reg_exp_parser.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/scan/reg_exp.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/scan/lexer.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/scan/tokens.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/scan/lexer_errors_public.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/scan/lexer_public.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/scan/tokens_public.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/parse/errors_public.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/parse/grammar/resolver.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/parse/grammar/interpreter.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/parse/grammar/lookahead.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/parse/grammar/checks.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/parse/grammar/gast/gast_resolver_public.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/parse/exceptions_public.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/parse/parser/traits/recoverable.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/parse/grammar/keys.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/parse/grammar/llk_lookahead.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/parse/parser/traits/looksahead.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/parse/cst/cst.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/lang/lang_extensions.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/parse/cst/cst_visitor.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/parse/parser/traits/tree_builder.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/parse/parser/traits/lexer_adapter.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/parse/parser/traits/recognizer_api.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/parse/parser/traits/recognizer_engine.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/parse/parser/traits/error_handler.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/parse/parser/traits/context_assist.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/parse/parser/traits/gast_recorder.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/parse/parser/traits/perf_tracer.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/parse/parser/utils/apply_mixins.ts", "../../../../../node_modules/.pnpm/chevrotain@11.0.3/node_modules/chevrotain/src/parse/parser/parser.ts", "../../../../../node_modules/.pnpm/chevrotain-allstar@0.3.1_chevrotain@11.0.3/node_modules/chevrotain-allstar/src/atn.ts", "../../../../../node_modules/.pnpm/chevrotain-allstar@0.3.1_chevrotain@11.0.3/node_modules/chevrotain-allstar/src/dfa.ts", "../../../../../node_modules/.pnpm/chevrotain-allstar@0.3.1_chevrotain@11.0.3/node_modules/chevrotain-allstar/src/all-star-lookahead.ts", "../../../../../node_modules/.pnpm/vscode-languageserver-types@3.17.5/node_modules/vscode-languageserver-types/lib/esm/main.js", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/parser/cst-node-builder.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/parser/langium-parser.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/parser/parser-builder-base.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/parser/completion-parser-builder.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/parser/langium-parser-builder.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/parser/token-builder.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/parser/value-converter.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/utils/cancellation.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/utils/promise-utils.ts", "../../../../../node_modules/.pnpm/vscode-languageserver-textdocument@1.0.12/node_modules/vscode-languageserver-textdocument/lib/esm/main.js", "../../../../../node_modules/.pnpm/vscode-uri@3.0.8/node_modules/vscode-uri/lib/esm/webpack:/LIB/node_modules/path-browserify/index.js", "../../../../../node_modules/.pnpm/vscode-uri@3.0.8/node_modules/vscode-uri/lib/esm/webpack:/LIB/webpack/bootstrap", "../../../../../node_modules/.pnpm/vscode-uri@3.0.8/node_modules/vscode-uri/lib/esm/webpack:/LIB/webpack/runtime/define property getters", "../../../../../node_modules/.pnpm/vscode-uri@3.0.8/node_modules/vscode-uri/lib/esm/webpack:/LIB/webpack/runtime/hasOwnProperty shorthand", "../../../../../node_modules/.pnpm/vscode-uri@3.0.8/node_modules/vscode-uri/lib/esm/webpack:/LIB/webpack/runtime/make namespace object", "../../../../../node_modules/.pnpm/vscode-uri@3.0.8/node_modules/vscode-uri/lib/esm/webpack:/LIB/src/platform.ts", "../../../../../node_modules/.pnpm/vscode-uri@3.0.8/node_modules/vscode-uri/lib/esm/webpack:/LIB/src/uri.ts", "../../../../../node_modules/.pnpm/vscode-uri@3.0.8/node_modules/vscode-uri/lib/esm/webpack:/LIB/src/utils.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/utils/uri-utils.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/workspace/documents.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/references/linker.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/references/name-provider.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/references/references.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/utils/collections.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/references/scope-computation.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/references/scope.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/utils/caching.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/references/scope-provider.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/serializer/json-serializer.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/service-registry.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/validation/validation-registry.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/validation/document-validator.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/workspace/ast-descriptions.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/workspace/ast-node-locator.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/workspace/configuration.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/utils/disposable.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/workspace/document-builder.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/workspace/index-manager.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/workspace/workspace-manager.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/parser/lexer.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/documentation/jsdoc.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/documentation/documentation-provider.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/documentation/comment-provider.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/utils/event.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/parser/async-parser.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/workspace/workspace-lock.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/serializer/hydrator.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/default-module.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/dependency-injection.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/utils/index.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/workspace/file-system-provider.ts", "../../../../../node_modules/.pnpm/langium@3.0.0/node_modules/langium/src/utils/grammar-loader.ts", "../../../src/language/generated/ast.ts", "../../../src/language/generated/grammar.ts", "../../../src/language/generated/module.ts", "../../../src/language/common/matcher.ts", "../../../src/language/common/valueConverter.ts", "../../../src/language/common/tokenBuilder.ts"],
  "sourcesContent": ["\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nlet _ral;\nfunction RAL() {\n    if (_ral === undefined) {\n        throw new Error(`No runtime abstraction layer installed`);\n    }\n    return _ral;\n}\n(function (RAL) {\n    function install(ral) {\n        if (ral === undefined) {\n            throw new Error(`No runtime abstraction layer provided`);\n        }\n        _ral = ral;\n    }\n    RAL.install = install;\n})(RAL || (RAL = {}));\nexports.default = RAL;\n", "\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;\nfunction boolean(value) {\n    return value === true || value === false;\n}\nexports.boolean = boolean;\nfunction string(value) {\n    return typeof value === 'string' || value instanceof String;\n}\nexports.string = string;\nfunction number(value) {\n    return typeof value === 'number' || value instanceof Number;\n}\nexports.number = number;\nfunction error(value) {\n    return value instanceof Error;\n}\nexports.error = error;\nfunction func(value) {\n    return typeof value === 'function';\n}\nexports.func = func;\nfunction array(value) {\n    return Array.isArray(value);\n}\nexports.array = array;\nfunction stringArray(value) {\n    return array(value) && value.every(elem => string(elem));\n}\nexports.stringArray = stringArray;\n", "\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Emitter = exports.Event = void 0;\nconst ral_1 = require(\"./ral\");\nvar Event;\n(function (Event) {\n    const _disposable = { dispose() { } };\n    Event.None = function () { return _disposable; };\n})(Event || (exports.Event = Event = {}));\nclass CallbackList {\n    add(callback, context = null, bucket) {\n        if (!this._callbacks) {\n            this._callbacks = [];\n            this._contexts = [];\n        }\n        this._callbacks.push(callback);\n        this._contexts.push(context);\n        if (Array.isArray(bucket)) {\n            bucket.push({ dispose: () => this.remove(callback, context) });\n        }\n    }\n    remove(callback, context = null) {\n        if (!this._callbacks) {\n            return;\n        }\n        let foundCallbackWithDifferentContext = false;\n        for (let i = 0, len = this._callbacks.length; i < len; i++) {\n            if (this._callbacks[i] === callback) {\n                if (this._contexts[i] === context) {\n                    // callback & context match => remove it\n                    this._callbacks.splice(i, 1);\n                    this._contexts.splice(i, 1);\n                    return;\n                }\n                else {\n                    foundCallbackWithDifferentContext = true;\n                }\n            }\n        }\n        if (foundCallbackWithDifferentContext) {\n            throw new Error('When adding a listener with a context, you should remove it with the same context');\n        }\n    }\n    invoke(...args) {\n        if (!this._callbacks) {\n            return [];\n        }\n        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);\n        for (let i = 0, len = callbacks.length; i < len; i++) {\n            try {\n                ret.push(callbacks[i].apply(contexts[i], args));\n            }\n            catch (e) {\n                // eslint-disable-next-line no-console\n                (0, ral_1.default)().console.error(e);\n            }\n        }\n        return ret;\n    }\n    isEmpty() {\n        return !this._callbacks || this._callbacks.length === 0;\n    }\n    dispose() {\n        this._callbacks = undefined;\n        this._contexts = undefined;\n    }\n}\nclass Emitter {\n    constructor(_options) {\n        this._options = _options;\n    }\n    /**\n     * For the public to allow to subscribe\n     * to events from this Emitter\n     */\n    get event() {\n        if (!this._event) {\n            this._event = (listener, thisArgs, disposables) => {\n                if (!this._callbacks) {\n                    this._callbacks = new CallbackList();\n                }\n                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {\n                    this._options.onFirstListenerAdd(this);\n                }\n                this._callbacks.add(listener, thisArgs);\n                const result = {\n                    dispose: () => {\n                        if (!this._callbacks) {\n                            // disposable is disposed after emitter is disposed.\n                            return;\n                        }\n                        this._callbacks.remove(listener, thisArgs);\n                        result.dispose = Emitter._noop;\n                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {\n                            this._options.onLastListenerRemove(this);\n                        }\n                    }\n                };\n                if (Array.isArray(disposables)) {\n                    disposables.push(result);\n                }\n                return result;\n            };\n        }\n        return this._event;\n    }\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n    fire(event) {\n        if (this._callbacks) {\n            this._callbacks.invoke.call(this._callbacks, event);\n        }\n    }\n    dispose() {\n        if (this._callbacks) {\n            this._callbacks.dispose();\n            this._callbacks = undefined;\n        }\n    }\n}\nexports.Emitter = Emitter;\nEmitter._noop = function () { };\n", "\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CancellationTokenSource = exports.CancellationToken = void 0;\nconst ral_1 = require(\"./ral\");\nconst Is = require(\"./is\");\nconst events_1 = require(\"./events\");\nvar CancellationToken;\n(function (CancellationToken) {\n    CancellationToken.None = Object.freeze({\n        isCancellationRequested: false,\n        onCancellationRequested: events_1.Event.None\n    });\n    CancellationToken.Cancelled = Object.freeze({\n        isCancellationRequested: true,\n        onCancellationRequested: events_1.Event.None\n    });\n    function is(value) {\n        const candidate = value;\n        return candidate && (candidate === CancellationToken.None\n            || candidate === CancellationToken.Cancelled\n            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));\n    }\n    CancellationToken.is = is;\n})(CancellationToken || (exports.CancellationToken = CancellationToken = {}));\nconst shortcutEvent = Object.freeze(function (callback, context) {\n    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);\n    return { dispose() { handle.dispose(); } };\n});\nclass MutableToken {\n    constructor() {\n        this._isCancelled = false;\n    }\n    cancel() {\n        if (!this._isCancelled) {\n            this._isCancelled = true;\n            if (this._emitter) {\n                this._emitter.fire(undefined);\n                this.dispose();\n            }\n        }\n    }\n    get isCancellationRequested() {\n        return this._isCancelled;\n    }\n    get onCancellationRequested() {\n        if (this._isCancelled) {\n            return shortcutEvent;\n        }\n        if (!this._emitter) {\n            this._emitter = new events_1.Emitter();\n        }\n        return this._emitter.event;\n    }\n    dispose() {\n        if (this._emitter) {\n            this._emitter.dispose();\n            this._emitter = undefined;\n        }\n    }\n}\nclass CancellationTokenSource {\n    get token() {\n        if (!this._token) {\n            // be lazy and create the token only when\n            // actually needed\n            this._token = new MutableToken();\n        }\n        return this._token;\n    }\n    cancel() {\n        if (!this._token) {\n            // save an object by returning the default\n            // cancelled token when cancellation happens\n            // before someone asks for the token\n            this._token = CancellationToken.Cancelled;\n        }\n        else {\n            this._token.cancel();\n        }\n    }\n    dispose() {\n        if (!this._token) {\n            // ensure to initialize with an empty token if we had none\n            this._token = CancellationToken.None;\n        }\n        else if (this._token instanceof MutableToken) {\n            // actually dispose\n            this._token.dispose();\n        }\n    }\n}\nexports.CancellationTokenSource = CancellationTokenSource;\n", "/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nexport * from './default-module.js';\nexport * from './dependency-injection.js';\nexport * from './service-registry.js';\nexport * from './services.js';\nexport * from './syntax-tree.js';\nexport * from './documentation/index.js';\nexport * from './languages/index.js';\nexport * from './parser/index.js';\nexport * from './references/index.js';\nexport * from './serializer/index.js';\nexport * from './utils/index.js';\nexport * from './validation/index.js';\nexport * from './workspace/index.js';\n\n// Export the Langium Grammar AST definitions in the `GrammarAST` namespace\nimport * as GrammarAST from './languages/generated/ast.js';\nimport type { Grammar } from './languages/generated/ast.js';\nexport { Grammar, GrammarAST };\n", "/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { IToken } from '@chevrotain/types';\nimport type { Range } from 'vscode-languageserver-types';\nimport type { CstNode, CompositeCstNode, LeafCstNode } from '../syntax-tree.js';\nimport type { DocumentSegment } from '../workspace/documents.js';\nimport type { Stream, TreeStream } from './stream.js';\nimport { isCompositeCstNode, isLeafCstNode, isRootCstNode } from '../syntax-tree.js';\nimport { TreeStreamImpl } from './stream.js';\n\n/**\n * Create a stream of all CST nodes that are directly and indirectly contained in the given root node,\n * including the root node itself.\n */\nexport function streamCst(node: CstNode): TreeStream<CstNode> {\n    return new TreeStreamImpl(node, element => {\n        if (isCompositeCstNode(element)) {\n            return element.content;\n        } else {\n            return [];\n        }\n    }, { includeRoot: true });\n}\n\n/**\n * Create a stream of all leaf nodes that are directly and indirectly contained in the given root node.\n */\nexport function flattenCst(node: CstNode): Stream<LeafCstNode> {\n    return streamCst(node).filter(isLeafCstNode);\n}\n\n/**\n * Determines whether the specified cst node is a child of the specified parent node.\n */\nexport function isChildNode(child: CstNode, parent: CstNode): boolean {\n    while (child.container) {\n        child = child.container;\n        if (child === parent) {\n            return true;\n        }\n    }\n    return false;\n}\n\nexport function tokenToRange(token: IToken): Range {\n    // Chevrotain uses 1-based indices everywhere\n    // So we subtract 1 from every value to align with the LSP\n    return {\n        start: {\n            character: token.startColumn! - 1,\n            line: token.startLine! - 1\n        },\n        end: {\n            character: token.endColumn!, // endColumn uses the correct index\n            line: token.endLine! - 1\n        }\n    };\n}\n\nexport function toDocumentSegment(node: CstNode): DocumentSegment;\nexport function toDocumentSegment(node?: CstNode): DocumentSegment | undefined;\nexport function toDocumentSegment(node?: CstNode): DocumentSegment | undefined {\n    if (!node) {\n        return undefined;\n    }\n    const { offset, end, range } = node;\n    return {\n        range,\n        offset,\n        end,\n        length: end - offset\n    };\n}\n\nexport enum RangeComparison {\n    Before = 0,\n    After = 1,\n    OverlapFront = 2,\n    OverlapBack = 3,\n    Inside = 4\n}\n\nexport function compareRange(range: Range, to: Range): RangeComparison {\n    if (range.end.line < to.start.line || (range.end.line === to.start.line && range.end.character < range.start.character)) {\n        return RangeComparison.Before;\n    } else if (range.start.line > to.end.line || (range.start.line === to.end.line && range.start.character > to.end.character)) {\n        return RangeComparison.After;\n    }\n    const startInside = range.start.line > to.start.line || (range.start.line === to.start.line && range.start.character >= to.start.character);\n    const endInside = range.end.line < to.end.line || (range.end.line === to.end.line && range.end.character <= to.end.character);\n    if (startInside && endInside) {\n        return RangeComparison.Inside;\n    } else if (startInside) {\n        return RangeComparison.OverlapBack;\n    } else {\n        return RangeComparison.OverlapFront;\n    }\n}\n\nexport function inRange(range: Range, to: Range): boolean {\n    const comparison = compareRange(range, to);\n    return comparison > RangeComparison.After;\n}\n\n// The \\p{L} regex matches any unicode letter character, i.e. characters from non-english alphabets\n// Together with \\w it matches any kind of character which can commonly appear in IDs\nexport const DefaultNameRegexp = /^[\\w\\p{L}]$/u;\n\n/**\n * Performs `findLeafNodeAtOffset` with a minor difference: When encountering a character that matches the `nameRegexp` argument,\n * it will instead return the leaf node at the `offset - 1` position.\n *\n * For LSP services, users expect that the declaration of an element is available if the cursor is directly after the element.\n */\nexport function findDeclarationNodeAtOffset(cstNode: CstNode | undefined, offset: number, nameRegexp = DefaultNameRegexp): LeafCstNode | undefined {\n    if (cstNode) {\n        if (offset > 0) {\n            const localOffset = offset - cstNode.offset;\n            const textAtOffset = cstNode.text.charAt(localOffset);\n            if (!nameRegexp.test(textAtOffset)) {\n                offset--;\n            }\n        }\n        return findLeafNodeAtOffset(cstNode, offset);\n    }\n    return undefined;\n}\n\nexport function findCommentNode(cstNode: CstNode | undefined, commentNames: string[]): CstNode | undefined {\n    if (cstNode) {\n        const previous = getPreviousNode(cstNode, true);\n        if (previous && isCommentNode(previous, commentNames)) {\n            return previous;\n        }\n        if (isRootCstNode(cstNode)) {\n            // Go from the first non-hidden node through all nodes in reverse order\n            // We do this to find the comment node which directly precedes the root node\n            const endIndex = cstNode.content.findIndex(e => !e.hidden);\n            for (let i = endIndex - 1; i >= 0; i--) {\n                const child = cstNode.content[i];\n                if (isCommentNode(child, commentNames)) {\n                    return child;\n                }\n            }\n        }\n    }\n    return undefined;\n}\n\nexport function isCommentNode(cstNode: CstNode, commentNames: string[]): boolean {\n    return isLeafCstNode(cstNode) && commentNames.includes(cstNode.tokenType.name);\n}\n\n/**\n * Finds the leaf CST node at the specified 0-based string offset.\n * Note that the given offset will be within the range of the returned leaf node.\n *\n * If the offset does not point to a CST node (but just white space), this method will return `undefined`.\n *\n * @param node The CST node to search through.\n * @param offset The specified offset.\n * @returns The CST node at the specified offset.\n */\nexport function findLeafNodeAtOffset(node: CstNode, offset: number): LeafCstNode | undefined {\n    if (isLeafCstNode(node)) {\n        return node;\n    } else if (isCompositeCstNode(node)) {\n        const searchResult = binarySearch(node, offset, false);\n        if (searchResult) {\n            return findLeafNodeAtOffset(searchResult, offset);\n        }\n    }\n    return undefined;\n}\n\n/**\n * Finds the leaf CST node at the specified 0-based string offset.\n * If no CST node exists at the specified position, it will return the leaf node before it.\n *\n * If there is no leaf node before the specified offset, this method will return `undefined`.\n *\n * @param node The CST node to search through.\n * @param offset The specified offset.\n * @returns The CST node closest to the specified offset.\n */\nexport function findLeafNodeBeforeOffset(node: CstNode, offset: number): LeafCstNode | undefined {\n    if (isLeafCstNode(node)) {\n        return node;\n    } else if (isCompositeCstNode(node)) {\n        const searchResult = binarySearch(node, offset, true);\n        if (searchResult) {\n            return findLeafNodeBeforeOffset(searchResult, offset);\n        }\n    }\n    return undefined;\n}\n\nfunction binarySearch(node: CompositeCstNode, offset: number, closest: boolean): CstNode | undefined {\n    let left = 0;\n    let right = node.content.length - 1;\n    let closestNode: CstNode | undefined = undefined;\n\n    while (left <= right) {\n        const middle = Math.floor((left + right) / 2);\n        const middleNode = node.content[middle];\n\n        if (middleNode.offset <= offset && middleNode.end > offset) {\n            // Found an exact match\n            return middleNode;\n        }\n\n        if (middleNode.end <= offset) {\n            // Update the closest node (less than offset) and move to the right half\n            closestNode = closest ? middleNode : undefined;\n            left = middle + 1;\n        } else {\n            // Move to the left half\n            right = middle - 1;\n        }\n    }\n\n    return closestNode;\n}\n\nexport function getPreviousNode(node: CstNode, hidden = true): CstNode | undefined {\n    while (node.container) {\n        const parent = node.container;\n        let index = parent.content.indexOf(node);\n        while (index > 0) {\n            index--;\n            const previous = parent.content[index];\n            if (hidden || !previous.hidden) {\n                return previous;\n            }\n        }\n        node = parent;\n    }\n    return undefined;\n}\n\nexport function getNextNode(node: CstNode, hidden = true): CstNode | undefined {\n    while (node.container) {\n        const parent = node.container;\n        let index = parent.content.indexOf(node);\n        const last = parent.content.length - 1;\n        while (index < last) {\n            index++;\n            const next = parent.content[index];\n            if (hidden || !next.hidden) {\n                return next;\n            }\n        }\n        node = parent;\n    }\n    return undefined;\n}\n\nexport function getStartlineNode(node: CstNode): CstNode {\n    if (node.range.start.character === 0) {\n        return node;\n    }\n    const line = node.range.start.line;\n    let last = node;\n    let index: number | undefined;\n    while (node.container) {\n        const parent = node.container;\n        const selfIndex = index ?? parent.content.indexOf(node);\n        if (selfIndex === 0) {\n            node = parent;\n            index = undefined;\n        } else {\n            index = selfIndex - 1;\n            node = parent.content[index];\n        }\n        if (node.range.start.line !== line) {\n            break;\n        }\n        last = node;\n    }\n    return last;\n}\n\nexport function getInteriorNodes(start: CstNode, end: CstNode): CstNode[] {\n    const commonParent = getCommonParent(start, end);\n    if (!commonParent) {\n        return [];\n    }\n    return commonParent.parent.content.slice(commonParent.a + 1, commonParent.b);\n}\n\nfunction getCommonParent(a: CstNode, b: CstNode): CommonParent | undefined {\n    const aParents = getParentChain(a);\n    const bParents = getParentChain(b);\n    let current: CommonParent | undefined;\n    for (let i = 0; i < aParents.length && i < bParents.length; i++) {\n        const aParent = aParents[i];\n        const bParent = bParents[i];\n        if (aParent.parent === bParent.parent) {\n            current = {\n                parent: aParent.parent,\n                a: aParent.index,\n                b: bParent.index\n            };\n        } else {\n            break;\n        }\n    }\n    return current;\n}\n\ninterface CommonParent {\n    parent: CompositeCstNode\n    a: number\n    b: number\n}\n\nfunction getParentChain(node: CstNode): ParentLink[] {\n    const chain: ParentLink[] = [];\n    while (node.container) {\n        const parent = node.container;\n        const index = parent.content.indexOf(node);\n        chain.push({\n            parent,\n            index\n        });\n        node = parent;\n    }\n    return chain.reverse();\n}\n\ninterface ParentLink {\n    parent: CompositeCstNode\n    index: number\n}\n", "/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { TokenType } from 'chevrotain';\nimport type { URI } from './utils/uri-utils.js';\nimport type { AbstractElement } from './languages/generated/ast.js';\nimport type { DocumentSegment, LangiumDocument } from './workspace/documents.js';\n\n/**\n * A node in the Abstract Syntax Tree (AST).\n */\nexport interface AstNode {\n    /** Every AST node has a type corresponding to what was specified in the grammar declaration. */\n    readonly $type: string;\n    /** The container node in the AST; every node except the root node has a container. */\n    readonly $container?: AstNode;\n    /** The property of the `$container` node that contains this node. This is either a direct reference or an array. */\n    readonly $containerProperty?: string;\n    /** In case `$containerProperty` is an array, the array index is stored here. */\n    readonly $containerIndex?: number;\n    /** The Concrete Syntax Tree (CST) node of the text range from which this node was parsed. */\n    readonly $cstNode?: CstNode;\n    /** The document containing the AST; only the root node has a direct reference to the document. */\n    readonly $document?: LangiumDocument;\n}\n\nexport function isAstNode(obj: unknown): obj is AstNode {\n    return typeof obj === 'object' && obj !== null && typeof (obj as AstNode).$type === 'string';\n}\n\nexport interface GenericAstNode extends AstNode {\n    [key: string]: unknown\n}\n\ntype SpecificNodeProperties<N extends AstNode> = keyof Omit<N, keyof AstNode | number | symbol>;\n\n/**\n * The property names of a given AST node type.\n */\nexport type Properties<N extends AstNode> = SpecificNodeProperties<N> extends never ? string : SpecificNodeProperties<N>\n\n/**\n * A cross-reference in the AST. Cross-references may or may not be successfully resolved.\n */\nexport interface Reference<T extends AstNode = AstNode> {\n    /**\n     * The target AST node of this reference. Accessing this property may trigger cross-reference\n     * resolution by the `Linker` in case it has not been done yet. If the reference cannot be resolved,\n     * the value is `undefined`.\n     */\n    readonly ref?: T;\n\n    /** If any problem occurred while resolving the reference, it is described by this property. */\n    readonly error?: LinkingError;\n    /** The CST node from which the reference was parsed */\n    readonly $refNode?: CstNode;\n    /** The actual text used to look up in the surrounding scope */\n    readonly $refText: string;\n    /** The node description for the AstNode returned by `ref`  */\n    readonly $nodeDescription?: AstNodeDescription;\n}\n\nexport function isReference(obj: unknown): obj is Reference {\n    return typeof obj === 'object' && obj !== null && typeof (obj as Reference).$refText === 'string';\n}\n\nexport type ResolvedReference<T extends AstNode = AstNode> = Reference<T> & {\n    readonly ref: T;\n}\n\n/**\n * A description of an AST node is used when constructing scopes and looking up cross-reference targets.\n */\nexport interface AstNodeDescription {\n    /** The target node; should be present only for local references (linking to the same document). */\n    node?: AstNode;\n    /**\n     * The document segment that represents the range of the name of the AST node.\n     */\n    nameSegment?: DocumentSegment;\n    /**\n     * The document segment that represents the full range of the AST node.\n     */\n    selectionSegment?: DocumentSegment;\n    /** `$type` property value of the AST node */\n    type: string;\n    /** Name of the AST node; this is usually determined by the `NameProvider` service. */\n    name: string;\n    /** URI to the document containing the AST node */\n    documentUri: URI;\n    /** Navigation path inside the document */\n    path: string;\n}\n\nexport function isAstNodeDescription(obj: unknown): obj is AstNodeDescription {\n    return typeof obj === 'object' && obj !== null\n        && typeof (obj as AstNodeDescription).name === 'string'\n        && typeof (obj as AstNodeDescription).type === 'string'\n        && typeof (obj as AstNodeDescription).path === 'string';\n}\n\n/**\n * Information about a cross-reference. This is used when traversing references in an AST or to describe\n * unresolved references.\n */\nexport interface ReferenceInfo {\n    reference: Reference\n    container: AstNode\n    property: string\n    index?: number\n}\n\n/**\n * Used to collect information when the `Linker` service fails to resolve a cross-reference.\n */\nexport interface LinkingError extends ReferenceInfo {\n    message: string;\n    targetDescription?: AstNodeDescription;\n}\n\nexport function isLinkingError(obj: unknown): obj is LinkingError {\n    return typeof obj === 'object' && obj !== null\n        && isAstNode((obj as LinkingError).container)\n        && isReference((obj as LinkingError).reference)\n        && typeof (obj as LinkingError).message === 'string';\n}\n\n/**\n * Service used for generic access to the structure of the AST. This service is shared between\n * all involved languages, so it operates on the superset of types of these languages.\n */\nexport interface AstReflection {\n    getAllTypes(): string[]\n    getAllSubTypes(type: string): string[]\n    getReferenceType(refInfo: ReferenceInfo): string\n    getTypeMetaData(type: string): TypeMetaData\n    isInstance(node: unknown, type: string): boolean\n    isSubtype(subtype: string, supertype: string): boolean\n}\n\n/**\n * An abstract implementation of the {@link AstReflection} interface.\n * Serves to cache subtype computation results to improve performance throughout different parts of Langium.\n */\nexport abstract class AbstractAstReflection implements AstReflection {\n\n    protected subtypes: Record<string, Record<string, boolean | undefined>> = {};\n    protected allSubtypes: Record<string, string[] | undefined> = {};\n\n    abstract getAllTypes(): string[];\n    abstract getReferenceType(refInfo: ReferenceInfo): string;\n    abstract getTypeMetaData(type: string): TypeMetaData;\n    protected abstract computeIsSubtype(subtype: string, supertype: string): boolean;\n\n    isInstance(node: unknown, type: string): boolean {\n        return isAstNode(node) && this.isSubtype(node.$type, type);\n    }\n\n    isSubtype(subtype: string, supertype: string): boolean {\n        if (subtype === supertype) {\n            return true;\n        }\n        let nested = this.subtypes[subtype];\n        if (!nested) {\n            nested = this.subtypes[subtype] = {};\n        }\n        const existing = nested[supertype];\n        if (existing !== undefined) {\n            return existing;\n        } else {\n            const result = this.computeIsSubtype(subtype, supertype);\n            nested[supertype] = result;\n            return result;\n        }\n    }\n\n    getAllSubTypes(type: string): string[] {\n        const existing = this.allSubtypes[type];\n        if (existing) {\n            return existing;\n        } else {\n            const allTypes = this.getAllTypes();\n            const types: string[] = [];\n            for (const possibleSubType of allTypes) {\n                if (this.isSubtype(possibleSubType, type)) {\n                    types.push(possibleSubType);\n                }\n            }\n            this.allSubtypes[type] = types;\n            return types;\n        }\n    }\n}\n\n/**\n * Represents runtime meta data about a meta model type.\n */\nexport interface TypeMetaData {\n    /** The name of this meta model type. Corresponds to the `AstNode.$type` value. */\n    name: string\n    /** A list of properties. They can contain default values for their respective property in the AST. */\n    properties: TypeProperty[]\n}\n\n/**\n * Describes the meta data of a property of an AST node.\n *\n * The optional `defaultValue` indicates that the property is mandatory in the AST node.\n * For example, if an AST node contains an array, but no elements of this array have been parsed, we still expect an empty array instead of `undefined`.\n */\nexport interface TypeProperty {\n    name: string\n    defaultValue?: PropertyType\n}\n\n/**\n * Represents a default value for an AST property.\n */\nexport type PropertyType = number | string | boolean | PropertyType[];\n\n/**\n * A node in the Concrete Syntax Tree (CST).\n */\nexport interface CstNode extends DocumentSegment {\n    /** The container node in the CST */\n    readonly container?: CompositeCstNode;\n    /** @deprecated use `container` instead. */\n    readonly parent?: CompositeCstNode;\n    /** The actual text */\n    readonly text: string;\n    /** The root CST node */\n    readonly root: RootCstNode;\n    /** The grammar element from which this node was parsed */\n    readonly grammarSource: AbstractElement;\n    /** @deprecated use `grammarSource` instead. */\n    readonly feature: AbstractElement;\n    /** The AST node created from this CST node */\n    readonly astNode: AstNode;\n    /** @deprecated use `astNode` instead. */\n    readonly element: AstNode;\n    /** Whether the token is hidden, i.e. not explicitly part of the containing grammar rule */\n    readonly hidden: boolean;\n}\n\n/**\n * A composite CST node contains other nodes, but no directly associated token.\n */\nexport interface CompositeCstNode extends CstNode {\n    readonly content: CstNode[];\n    /** @deprecated use `content` instead. */\n    readonly children: CstNode[];\n}\n\nexport function isCompositeCstNode(node: unknown): node is CompositeCstNode {\n    return typeof node === 'object' && node !== null && Array.isArray((node as CompositeCstNode).content);\n}\n\n/**\n * A leaf CST node corresponds to a token in the input token stream.\n */\nexport interface LeafCstNode extends CstNode {\n    readonly tokenType: TokenType;\n}\n\nexport function isLeafCstNode(node: unknown): node is LeafCstNode {\n    return typeof node === 'object' && node !== null && typeof (node as LeafCstNode).tokenType === 'object';\n}\n\nexport interface RootCstNode extends CompositeCstNode {\n    readonly fullText: string\n}\n\nexport function isRootCstNode(node: unknown): node is RootCstNode {\n    return isCompositeCstNode(node) && typeof (node as RootCstNode).fullText === 'string';\n}\n\n/**\n * Returns a type to have only properties names (!) of a type T whose property value is of a certain type K.\n */\ntype ExtractKeysOfValueType<T, K> = { [I in keyof T]: T[I] extends K ? I : never }[keyof T];\n\n/**\n * Returns the property names (!) of an AstNode that are cross-references.\n * Meant to be used during cross-reference resolution in combination with `assertUnreachable(context.property)`.\n */\nexport type CrossReferencesOfAstNodeType<N extends AstNode> = (\n    ExtractKeysOfValueType<N, Reference|undefined>\n    | ExtractKeysOfValueType<N, Array<Reference|undefined>|undefined>\n// eslint-disable-next-line @typescript-eslint/ban-types\n) & {};\n\n/**\n * Represents the enumeration-like type, that lists all AstNode types of your grammar.\n */\nexport type AstTypeList<T> = Record<keyof T, AstNode>;\n\n/**\n * Returns all types that contain cross-references, A is meant to be the interface `XXXAstType` fromm your generated `ast.ts` file.\n * Meant to be used during cross-reference resolution in combination with `assertUnreachable(context.container)`.\n */\nexport type AstNodeTypesWithCrossReferences<A extends AstTypeList<A>> = {\n    [T in keyof A]: CrossReferencesOfAstNodeType<A[T]> extends never ? never : A[T]\n}[keyof A];\n\nexport type Mutable<T> = {\n    -readonly [P in keyof T]: T[P]\n};\n", "/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n/**\n * A stream is a read-only sequence of values. While the contents of an array can be accessed\n * both sequentially and randomly (via index), a stream allows only sequential access.\n *\n * The advantage of this is that a stream can be evaluated lazily, so it does not require\n * to store intermediate values. This can boost performance when a large sequence is\n * processed via filtering, mapping etc. and accessed at most once. However, lazy\n * evaluation means that all processing is repeated when you access the sequence multiple\n * times; in such a case, it may be better to store the resulting sequence into an array.\n */\nexport interface Stream<T> extends Iterable<T> {\n\n    /**\n     * Returns an iterator for this stream. This is the same as calling the `Symbol.iterator` function property.\n     */\n    iterator(): IterableIterator<T>;\n\n    /**\n     * Determines whether this stream contains no elements.\n     */\n    isEmpty(): boolean;\n\n    /**\n     * Determines the number of elements in this stream.\n     */\n    count(): number;\n\n    /**\n     * Collects all elements of this stream into an array.\n     */\n    toArray(): T[];\n\n    /**\n     * Collects all elements of this stream into a Set.\n     */\n    toSet(): Set<T>;\n\n    /**\n     * Collects all elements of this stream into a Map, applying the provided functions to determine keys and values.\n     *\n     * @param keyFn The function to derive map keys. If omitted, the stream elements are used as keys.\n     * @param valueFn The function to derive map values. If omitted, the stream elements are used as values.\n     */\n    toMap<K = T, V = T>(keyFn?: (e: T) => K, valueFn?: (e: T) => V): Map<K, V>;\n\n    /**\n     * Returns a string representation of a stream.\n     */\n    toString(): string;\n\n    /**\n     * Combines two streams by returning a new stream that yields all elements of this stream and the other stream.\n     *\n     * @param other Stream to be concatenated with this one.\n     */\n    concat<T2>(other: Iterable<T2>): Stream<T | T2>;\n\n    /**\n     * Adds all elements of the stream into a string, separated by the specified separator string.\n     *\n     * @param separator A string used to separate one element of the stream from the next in the resulting string.\n     *        If omitted, the steam elements are separated with a comma.\n     */\n    join(separator?: string): string\n\n    /**\n     * Returns the index of the first occurrence of a value in the stream, or -1 if it is not present.\n     *\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The stream index at which to begin the search. If fromIndex is omitted, the search\n     *        starts at index 0.\n     */\n    indexOf(searchElement: T, fromIndex?: number): number;\n\n    /**\n     * Determines whether all members of the stream satisfy the specified test.\n     *\n     * @param predicate This method calls the predicate function for each element in the stream until the\n     *        predicate returns a value which is coercible to the Boolean value `false`, or until the end\n     *        of the stream.\n     */\n    every<S extends T>(predicate: (value: T) => value is S): this is Stream<S>;\n    every(predicate: (value: T) => unknown): boolean;\n\n    /**\n     * Determines whether any member of the stream satisfies the specified test.\n     *\n     * @param predicate This method calls the predicate function for each element in the stream until the\n     *        predicate returns a value which is coercible to the Boolean value `true`, or until the end\n     *        of the stream.\n     */\n    some(predicate: (value: T) => unknown): boolean;\n\n    /**\n     * Performs the specified action for each element in the stream.\n     *\n     * @param callbackfn Function called once for each element in the stream.\n     */\n    forEach(callbackfn: (value: T, index: number) => void): void;\n\n    /**\n     * Returns a stream that yields the results of calling the specified callback function on each element\n     * of the stream. The function is called when the resulting stream elements are actually accessed, so\n     * accessing the resulting stream multiple times means the function is also called multiple times for\n     * each element of the stream.\n     *\n     * @param callbackfn Lazily evaluated function mapping stream elements.\n     */\n    map<U>(callbackfn: (value: T) => U): Stream<U>;\n\n    /**\n     * Returns the elements of the stream that meet the condition specified in a callback function.\n     * The function is called when the resulting stream elements are actually accessed, so accessing the\n     * resulting stream multiple times means the function is also called multiple times for each element\n     * of the stream.\n     *\n     * @param predicate Lazily evaluated function checking a condition on stream elements.\n     */\n    filter<S extends T>(predicate: (value: T) => value is S): Stream<S>;\n    filter(predicate: (value: T) => unknown): Stream<T>;\n\n    /**\n     * Returns the elements of the stream that are _non-nullable_, which means they are neither `undefined`\n     * nor `null`.\n     */\n    nonNullable(): Stream<NonNullable<T>>;\n\n    /**\n     * Calls the specified callback function for all elements in the stream. The return value of the\n     * callback function is the accumulated result, and is provided as an argument in the next call to\n     * the callback function.\n     *\n     * @param callbackfn This method calls the function once for each element in the stream, providing\n     *        the previous and current values of the reduction.\n     * @param initialValue If specified, `initialValue` is used as the initial value to start the\n     *        accumulation. The first call to the function provides this value as an argument instead\n     *        of a stream value.\n     */\n    reduce(callbackfn: (previousValue: T, currentValue: T) => T): T | undefined;\n    reduce<U = T>(callbackfn: (previousValue: U, currentValue: T) => U, initialValue: U): U;\n\n    /**\n     * Calls the specified callback function for all elements in the stream, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an\n     * argument in the next call to the callback function.\n     *\n     * @param callbackfn This method calls the function once for each element in the stream, providing\n     *        the previous and current values of the reduction.\n     * @param initialValue If specified, `initialValue` is used as the initial value to start the\n     *        accumulation. The first call to the function provides this value as an argument instead\n     *        of an array value.\n     */\n    reduceRight(callbackfn: (previousValue: T, currentValue: T) => T): T | undefined;\n    reduceRight<U = T>(callbackfn: (previousValue: U, currentValue: T) => U, initialValue: U): U;\n\n    /**\n     * Returns the value of the first element in the stream that meets the condition, or `undefined`\n     * if there is no such element.\n     *\n     * @param predicate This method calls `predicate` once for each element of the stream, in ascending\n     *        order, until it finds one where `predicate` returns a value which is coercible to the\n     *        Boolean value `true`.\n     */\n    find<S extends T>(predicate: (value: T) => value is S): S | undefined;\n    find(predicate: (value: T) => unknown): T | undefined;\n\n    /**\n     * Returns the index of the first element in the stream that meets the condition, or `-1`\n     * if there is no such element.\n     *\n     * @param predicate This method calls `predicate` once for each element of the stream, in ascending\n     *        order, until it finds one where `predicate` returns a value which is coercible to the\n     *        Boolean value `true`.\n     */\n    findIndex(predicate: (value: T) => unknown): number;\n\n    /**\n     * Determines whether the stream includes a certain element, returning `true` or `false` as appropriate.\n     *\n     * @param searchElement The element to search for.\n     */\n    includes(searchElement: T): boolean;\n\n    /**\n     * Calls a defined callback function on each element of the stream and then flattens the result into\n     * a new stream. This is identical to a `map` followed by `flat` with depth 1.\n     *\n     * @param callbackfn Lazily evaluated function mapping stream elements.\n     */\n    flatMap<U>(callbackfn: (value: T) => U | Iterable<U>): Stream<U>;\n\n    /**\n     * Returns a new stream with all sub-stream or sub-array elements concatenated into it recursively up\n     * to the specified depth.\n     *\n     * @param depth The maximum recursion depth. Defaults to 1.\n     */\n    flat<D extends number = 1>(depth?: D): FlatStream<T, D>;\n\n    /**\n     * Returns the first element in the stream, or `undefined` if the stream is empty.\n     */\n    head(): T | undefined;\n\n    /**\n     * Returns a stream that skips the first `skipCount` elements from this stream.\n     *\n     * @param skipCount The number of elements to skip. If this is larger than the number of elements in\n     *        the stream, an empty stream is returned. Defaults to 1.\n     */\n    tail(skipCount?: number): Stream<T>;\n\n    /**\n     * Returns a stream consisting of the elements of this stream, truncated to be no longer than `maxSize`\n     * in length.\n     *\n     * @param maxSize The number of elements the stream should be limited to\n     */\n    limit(maxSize: number): Stream<T>;\n\n    /**\n     * Returns a stream containing only the distinct elements from this stream.\n     * Equality is determined with the same rules as a standard `Set`.\n     *\n     * @param by A function returning the key used to check equality with a previous stream element.\n     *        If omitted, the stream elements themselves are used for comparison.\n     */\n    distinct<Key = T>(by?: (element: T) => Key): Stream<T>;\n\n    /**\n     * Returns a stream that contains all elements that don't exist in the {@link other} iterable.\n     * Equality is determined with the same rules as a standard `Set`.\n     * @param other The elements that should be exluded from this stream.\n     * @param key A function returning the key used to check quality.\n     *        If omitted, the stream elements themselves are used for comparison.\n     */\n    exclude<Key = T>(other: Iterable<T>, key?: (element: T) => Key): Stream<T>;\n\n}\n\nexport type FlatStream<T, Depth extends number> = {\n    'done': Stream<T>,\n    'recur': T extends Iterable<infer Content>\n        ? FlatStream<Content, MinusOne<Depth>>\n        : Stream<T>\n}[Depth extends 0 ? 'done' : 'recur'];\n\nexport type MinusOne<N extends number> = [-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20][N];\n\n/**\n * The default implementation of `Stream` works with two input functions:\n *  - The first function creates the initial state of an iteration.\n *  - The second function gets the current state as argument and returns an `IteratorResult`.\n */\nexport class StreamImpl<S, T> implements Stream<T> {\n    protected readonly startFn: () => S;\n    protected readonly nextFn: (state: S) => IteratorResult<T>;\n\n    constructor(startFn: () => S, nextFn: (state: S) => IteratorResult<T, undefined>) {\n        this.startFn = startFn;\n        this.nextFn = nextFn;\n    }\n\n    iterator(): IterableIterator<T> {\n        const iterator = {\n            state: this.startFn(),\n            next: () => this.nextFn(iterator.state),\n            [Symbol.iterator]: () => iterator\n        };\n        return iterator;\n    }\n\n    [Symbol.iterator](): Iterator<T> {\n        return this.iterator();\n    }\n\n    isEmpty(): boolean {\n        const iterator = this.iterator();\n        return Boolean(iterator.next().done);\n    }\n\n    count(): number {\n        const iterator = this.iterator();\n        let count = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            count++;\n            next = iterator.next();\n        }\n        return count;\n    }\n\n    toArray(): T[] {\n        const result: T[] = [];\n        const iterator = this.iterator();\n        let next: IteratorResult<T>;\n        do {\n            next = iterator.next();\n            if (next.value !== undefined) {\n                result.push(next.value);\n            }\n        } while (!next.done);\n        return result;\n    }\n\n    toSet(): Set<T> {\n        return new Set(this);\n    }\n\n    toMap<K = T, V = T>(keyFn?: (e: T) => K, valueFn?: (e: T) => V): Map<K, V> {\n        const entryStream = this.map(element => <[K, V]>[\n            keyFn ? keyFn(element) : element,\n            valueFn ? valueFn(element) : element\n        ]);\n        return new Map(entryStream);\n    }\n\n    toString(): string {\n        return this.join();\n    }\n\n    concat<T2>(other: Iterable<T2>): Stream<T | T2> {\n        const iterator = other[Symbol.iterator]();\n        return new StreamImpl<{ first: S, firstDone: boolean }, T | T2>(\n            () => ({ first: this.startFn(), firstDone: false }),\n            state => {\n                let result: IteratorResult<T | T2>;\n                if (!state.firstDone) {\n                    do {\n                        result = this.nextFn(state.first);\n                        if (!result.done) {\n                            return result;\n                        }\n                    } while (!result.done);\n                    state.firstDone = true;\n                }\n                do {\n                    result = iterator.next();\n                    if (!result.done) {\n                        return result;\n                    }\n                } while (!result.done);\n                return DONE_RESULT;\n            }\n        );\n    }\n\n    join(separator = ','): string {\n        const iterator = this.iterator();\n        let value = '';\n        let result: IteratorResult<T>;\n        let addSeparator = false;\n        do {\n            result = iterator.next();\n            if (!result.done) {\n                if (addSeparator) {\n                    value += separator;\n                }\n                value += toString(result.value);\n            }\n            addSeparator = true;\n        } while (!result.done);\n        return value;\n    }\n\n    indexOf(searchElement: T, fromIndex = 0): number {\n        const iterator = this.iterator();\n        let index = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            if (index >= fromIndex && next.value === searchElement) {\n                return index;\n            }\n            next = iterator.next();\n            index++;\n        }\n        return -1;\n    }\n\n    // In the following definition the '& this' part in the return type is important\n    // _and_ the order within 'Stream<U> & this' is crucial!\n    // Otherwise Typescript would infer the type of 'this' as 'StreamImpl<S, T> & Stream<U>'\n    // (or '<subClass of StreamImpl<S, T> & Stream<U>') and usages like\n    // ```\n    //  const stream = new StreamImpl(...);\n    //  ... stream.every(<typeGuard>) & stream....\n    // ```\n    // cannot benefit from '<typeGuard>', as Typescript would priorize the signatures\n    // of 'StreamImpl<S, T>' (i.e. those of 'Stream<T>') over those of 'Stream<U>'.\n    // With the order of 'Stream<U> & this' the signatures of 'Stream<U>' get precedence.\n    every<U extends T>(predicate: (value: T) => value is U): this is Stream<U> & this;\n    every(predicate: (value: T) => unknown): boolean;\n    every(predicate: (value: T) => unknown): boolean {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (!predicate(next.value)) {\n                return false;\n            }\n            next = iterator.next();\n        }\n        return true;\n    }\n\n    some(predicate: (value: T) => unknown): boolean {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (predicate(next.value)) {\n                return true;\n            }\n            next = iterator.next();\n        }\n        return false;\n    }\n\n    forEach(callbackfn: (value: T, index: number) => void): void {\n        const iterator = this.iterator();\n        let index = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            callbackfn(next.value, index);\n            next = iterator.next();\n            index++;\n        }\n    }\n\n    map<U>(callbackfn: (value: T) => U): Stream<U> {\n        return new StreamImpl<S, U>(\n            this.startFn,\n            (state) => {\n                const { done, value } = this.nextFn(state);\n                if (done) {\n                    return DONE_RESULT;\n                } else {\n                    return { done: false, value: callbackfn(value) };\n                }\n            }\n        );\n    }\n\n    // for remarks on the return type definition refer to 'every<U extends T>(...)'\n    filter<U extends T>(predicate: (value: T) => value is U): Stream<U> & this;\n    filter(predicate: (value: T) => unknown): Stream<T> & this;\n    filter(predicate: (value: T) => unknown): Stream<T> {\n        return new StreamImpl<S, T>(\n            this.startFn,\n            state => {\n                let result: IteratorResult<T>;\n                do {\n                    result = this.nextFn(state);\n                    if (!result.done && predicate(result.value)) {\n                        return result;\n                    }\n                } while (!result.done);\n                return DONE_RESULT;\n            }\n        );\n    }\n\n    nonNullable(): Stream<NonNullable<T>> {\n        return this.filter(e => e !== undefined && e !== null) as Stream<NonNullable<T>>;\n    }\n\n    reduce(callbackfn: (previousValue: T, currentValue: T) => T): T | undefined;\n    reduce<U = T>(callbackfn: (previousValue: U, currentValue: T) => U, initialValue: U): U;\n    reduce<U>(callbackfn: (previousValue: U | T, currentValue: T) => U, initialValue?: U): U | T | undefined {\n        const iterator = this.iterator();\n        let previousValue: U | T | undefined = initialValue;\n        let next = iterator.next();\n        while (!next.done) {\n            if (previousValue === undefined) {\n                previousValue = next.value;\n            } else {\n                previousValue = callbackfn(previousValue, next.value);\n            }\n            next = iterator.next();\n        }\n        return previousValue;\n    }\n\n    reduceRight(callbackfn: (previousValue: T, currentValue: T) => T): T | undefined;\n    reduceRight<U = T>(callbackfn: (previousValue: U, currentValue: T) => U, initialValue: U): U;\n    reduceRight<U>(callbackfn: (previousValue: U | T, currentValue: T) => U, initialValue?: U): U | T | undefined {\n        return this.recursiveReduce(this.iterator(), callbackfn, initialValue);\n    }\n\n    protected recursiveReduce<U>(iterator: Iterator<T>, callbackfn: (previousValue: U | T, currentValue: T) => U, initialValue?: U): U | T | undefined {\n        const next = iterator.next();\n        if (next.done) {\n            return initialValue;\n        }\n        const previousValue = this.recursiveReduce(iterator, callbackfn, initialValue);\n        if (previousValue === undefined) {\n            return next.value;\n        }\n        return callbackfn(previousValue, next.value);\n    }\n\n    find<S extends T>(predicate: (value: T) => value is S): S | undefined;\n    find(predicate: (value: T) => unknown): T | undefined;\n    find(predicate: (value: T) => unknown): T | undefined {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (predicate(next.value)) {\n                return next.value;\n            }\n            next = iterator.next();\n        }\n        return undefined;\n    }\n\n    findIndex(predicate: (value: T) => unknown): number {\n        const iterator = this.iterator();\n        let index = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            if (predicate(next.value)) {\n                return index;\n            }\n            next = iterator.next();\n            index++;\n        }\n        return -1;\n    }\n\n    includes(searchElement: T): boolean {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (next.value === searchElement) {\n                return true;\n            }\n            next = iterator.next();\n        }\n        return false;\n    }\n\n    flatMap<U>(callbackfn: (value: T) => U | Iterable<U>): Stream<U> {\n        type FlatMapState = { this: S, iterator?: Iterator<U, undefined> }\n        return new StreamImpl<FlatMapState, U>(\n            () => ({ this: this.startFn() }),\n            (state) => {\n                do {\n                    if (state.iterator) {\n                        const next = state.iterator.next();\n                        if (next.done) {\n                            state.iterator = undefined;\n                        } else {\n                            return next;\n                        }\n                    }\n                    const { done, value } = this.nextFn(state.this);\n                    if (!done) {\n                        const mapped = callbackfn(value);\n                        if (isIterable(mapped)) {\n                            state.iterator = mapped[Symbol.iterator]();\n                        } else {\n                            return { done: false, value: mapped };\n                        }\n                    }\n                } while (state.iterator);\n                return DONE_RESULT;\n            }\n        );\n    }\n\n    flat<D extends number = 1>(depth?: D): FlatStream<T, D> {\n        if (depth === undefined) {\n            depth = 1 as D;\n        }\n        if (depth <= 0) {\n            return this as unknown as FlatStream<T, D>;\n        }\n        const stream = depth > 1 ? this.flat(depth - 1) as unknown as StreamImpl<S, T> : this;\n        type FlatMapState = { this: S, iterator?: Iterator<T, undefined> }\n        return new StreamImpl<FlatMapState, T>(\n            () => ({ this: stream.startFn() }),\n            (state) => {\n                do {\n                    if (state.iterator) {\n                        const next = state.iterator.next();\n                        if (next.done) {\n                            state.iterator = undefined;\n                        } else {\n                            return next;\n                        }\n                    }\n                    const { done, value } = stream.nextFn(state.this);\n                    if (!done) {\n                        if (isIterable(value)) {\n                            state.iterator = value[Symbol.iterator]() as Iterator<T>;\n                        } else {\n                            return { done: false, value: value };\n                        }\n                    }\n                } while (state.iterator);\n                return DONE_RESULT;\n            }\n        ) as unknown as FlatStream<T, D>;\n    }\n\n    head(): T | undefined {\n        const iterator = this.iterator();\n        const result = iterator.next();\n        if (result.done) {\n            return undefined;\n        }\n        return result.value;\n    }\n\n    tail(skipCount = 1): Stream<T> {\n        return new StreamImpl<S, T>(\n            () => {\n                const state = this.startFn();\n                for (let i = 0; i < skipCount; i++) {\n                    const next = this.nextFn(state);\n                    if (next.done) {\n                        return state;\n                    }\n                }\n                return state;\n            },\n            this.nextFn\n        );\n    }\n\n    limit(maxSize: number): Stream<T> {\n        return new StreamImpl<{ size: number, state: S }, T>(\n            () => ({ size: 0, state: this.startFn() }),\n            state => {\n                state.size++;\n                if (state.size > maxSize) {\n                    return DONE_RESULT;\n                }\n                return this.nextFn(state.state);\n            }\n        );\n    }\n\n    distinct<Key = T>(by?: (element: T) => Key): Stream<T> {\n        const set = new Set<T | Key>();\n        return this.filter(e => {\n            const value = by ? by(e) : e;\n            if (set.has(value)) {\n                return false;\n            } else {\n                set.add(value);\n                return true;\n            }\n        });\n    }\n\n    exclude<Key = T>(other: Iterable<T>, key?: (element: T) => Key): Stream<T> {\n        const otherKeySet = new Set<Key | T>();\n        for (const item of other) {\n            const value = key ? key(item) : item;\n            otherKeySet.add(value);\n        }\n        return this.filter(e => {\n            const ownKey = key ? key(e) : e;\n            return !otherKeySet.has(ownKey);\n        });\n    }\n}\n\nfunction toString(item: unknown): string {\n    if (typeof item === 'string') {\n        return item as string;\n    }\n    if (typeof item === 'undefined') {\n        return 'undefined';\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (typeof (item as any).toString === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return (item as any).toString();\n    }\n    return Object.prototype.toString.call(item);\n}\n\nfunction isIterable<T>(obj: unknown): obj is Iterable<T> {\n    return !!obj && typeof (obj as Iterable<T>)[Symbol.iterator] === 'function';\n}\n\n/**\n * An empty stream of any type.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const EMPTY_STREAM: Stream<any> = new StreamImpl<undefined, any>(() => undefined, () => DONE_RESULT);\n\n/**\n * Use this `IteratorResult` when implementing a `StreamImpl` to indicate that there are no more elements in the stream.\n */\nexport const DONE_RESULT: IteratorReturnResult<undefined> = Object.freeze({ done: true, value: undefined });\n\n/**\n * Create a stream from one or more iterables or array-likes.\n */\nexport function stream<T>(...collections: Array<Iterable<T> | ArrayLike<T>>): Stream<T> {\n    if (collections.length === 1) {\n        const collection = collections[0];\n        if (collection instanceof StreamImpl) {\n            return collection as Stream<T>;\n        }\n        if (isIterable(collection)) {\n            return new StreamImpl<Iterator<T, undefined>, T>(\n                () => collection[Symbol.iterator](),\n                (iterator) => iterator.next()\n            );\n        }\n        if (typeof collection.length === 'number') {\n            return new StreamImpl<{ index: number }, T>(\n                () => ({ index: 0 }),\n                (state) => {\n                    if (state.index < collection.length) {\n                        return { done: false, value: collection[state.index++] };\n                    } else {\n                        return DONE_RESULT;\n                    }\n                }\n            );\n        }\n    }\n    if (collections.length > 1) {\n        type State = { collIndex: number, iterator?: Iterator<T, undefined>, array?: ArrayLike<T>, arrIndex: number };\n        return new StreamImpl<State, T>(\n            () => ({ collIndex: 0, arrIndex: 0 }),\n            (state) => {\n                do {\n                    if (state.iterator) {\n                        const next = state.iterator.next();\n                        if (!next.done) {\n                            return next;\n                        }\n                        state.iterator = undefined;\n                    }\n                    if (state.array) {\n                        if (state.arrIndex < state.array.length) {\n                            return { done: false, value: state.array[state.arrIndex++] };\n                        }\n                        state.array = undefined;\n                        state.arrIndex = 0;\n                    }\n                    if (state.collIndex < collections.length) {\n                        const collection = collections[state.collIndex++];\n                        if (isIterable(collection)) {\n                            state.iterator = collection[Symbol.iterator]();\n                        } else if (collection && typeof collection.length === 'number') {\n                            state.array = collection;\n                        }\n                    }\n                } while (state.iterator || state.array || state.collIndex < collections.length);\n                return DONE_RESULT;\n            }\n        );\n    }\n    return EMPTY_STREAM;\n}\n\n/**\n * A tree iterator adds the ability to prune the current iteration.\n */\nexport interface TreeIterator<T> extends IterableIterator<T> {\n    /**\n     * Skip the whole subtree below the last returned element. The iteration continues as if that\n     * element had no children.\n     */\n    prune(): void\n}\n\n/**\n * A tree stream is used to stream the elements of a tree, for example an AST or CST.\n */\nexport interface TreeStream<T> extends Stream<T> {\n    iterator(): TreeIterator<T>\n}\n\n/**\n * The default implementation of `TreeStream` takes a root element and a function that computes the\n * children of its argument. Whether the root node included in the stream is controlled with the\n * `includeRoot` option, which defaults to `false`.\n */\nexport class TreeStreamImpl<T>\n    extends StreamImpl<{ iterators: Array<Iterator<T>>, pruned: boolean }, T>\n    implements TreeStream<T> {\n\n    constructor(root: T, children: (node: T) => Iterable<T>, options?: { includeRoot?: boolean }) {\n        super(\n            () => ({\n                iterators: options?.includeRoot ? [[root][Symbol.iterator]()] : [children(root)[Symbol.iterator]()],\n                pruned: false\n            }),\n            state => {\n                if (state.pruned) {\n                    state.iterators.pop();\n                    state.pruned = false;\n                }\n                while (state.iterators.length > 0) {\n                    const iterator = state.iterators[state.iterators.length - 1];\n                    const next = iterator.next();\n                    if (next.done) {\n                        state.iterators.pop();\n                    } else {\n                        state.iterators.push(children(next.value)[Symbol.iterator]());\n                        return next;\n                    }\n                }\n                return DONE_RESULT;\n            }\n        );\n    }\n\n    override iterator(): TreeIterator<T> {\n        const iterator = {\n            state: this.startFn(),\n            next: () => this.nextFn(iterator.state),\n            prune: () => {\n                iterator.state.pruned = true;\n            },\n            [Symbol.iterator]: () => iterator\n        };\n        return iterator;\n    }\n}\n\n/**\n * A set of utility functions that reduce a stream to a single value.\n */\nexport namespace Reduction {\n\n    /**\n     * Compute the sum of a number stream.\n     */\n    export function sum(stream: Stream<number>): number {\n        return stream.reduce((a, b) => a + b, 0);\n    }\n\n    /**\n     * Compute the product of a number stream.\n     */\n    export function product(stream: Stream<number>): number {\n        return stream.reduce((a, b) => a * b, 0);\n    }\n\n    /**\n     * Compute the minimum of a number stream. Returns `undefined` if the stream is empty.\n     */\n    export function min(stream: Stream<number>): number | undefined {\n        return stream.reduce((a, b) => Math.min(a, b));\n    }\n\n    /**\n     * Compute the maximum of a number stream. Returns `undefined` if the stream is empty.\n     */\n    export function max(stream: Stream<number>): number | undefined {\n        return stream.reduce((a, b) => Math.max(a, b));\n    }\n\n}\n", "/******************************************************************************\n * Copyright 2021-2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport { assertUnreachable } from '../utils/errors.js';\nimport * as ast from '../languages/generated/ast.js';\nimport type { AstNode, CstNode } from '../syntax-tree.js';\nimport { isCompositeCstNode } from '../syntax-tree.js';\nimport { getContainerOfType, streamAllContents } from './ast-utils.js';\nimport { streamCst } from './cst-utils.js';\nimport { escapeRegExp } from './regexp-utils.js';\n\n/**\n * Returns the entry rule of the given grammar, if any. If the grammar file does not contain an entry rule,\n * the result is `undefined`.\n */\nexport function getEntryRule(grammar: ast.Grammar): ast.ParserRule | undefined {\n    return grammar.rules.find(e => ast.isParserRule(e) && e.entry) as ast.ParserRule;\n}\n\n/**\n * Returns all hidden terminal rules of the given grammar, if any.\n */\nexport function getHiddenRules(grammar: ast.Grammar) {\n    return grammar.rules.filter((e): e is ast.TerminalRule => ast.isTerminalRule(e) && e.hidden);\n}\n\n/**\n * Returns all rules that can be reached from the topmost rules of the specified grammar (entry and hidden terminal rules).\n *\n * @param grammar The grammar that contains all rules\n * @param allTerminals Whether or not to include terminals that are referenced only by other terminals\n * @returns A list of referenced parser and terminal rules. If the grammar contains no entry rule,\n *      this function returns all rules of the specified grammar.\n */\nexport function getAllReachableRules(grammar: ast.Grammar, allTerminals: boolean): Set<ast.AbstractRule> {\n    const ruleNames = new Set<string>();\n    const entryRule = getEntryRule(grammar);\n    if (!entryRule) {\n        return new Set(grammar.rules);\n    }\n\n    const topMostRules = [entryRule as ast.AbstractRule].concat(getHiddenRules(grammar));\n    for (const rule of topMostRules) {\n        ruleDfs(rule, ruleNames, allTerminals);\n    }\n\n    const rules = new Set<ast.AbstractRule>();\n    for (const rule of grammar.rules) {\n        if (ruleNames.has(rule.name) || (ast.isTerminalRule(rule) && rule.hidden)) {\n            rules.add(rule);\n        }\n    }\n    return rules;\n}\n\nfunction ruleDfs(rule: ast.AbstractRule, visitedSet: Set<string>, allTerminals: boolean): void {\n    visitedSet.add(rule.name);\n    streamAllContents(rule).forEach(node => {\n        if (ast.isRuleCall(node) || (allTerminals && ast.isTerminalRuleCall(node))) {\n            const refRule = node.rule.ref;\n            if (refRule && !visitedSet.has(refRule.name)) {\n                ruleDfs(refRule, visitedSet, allTerminals);\n            }\n        }\n    });\n}\n\n/**\n * Determines the grammar expression used to parse a cross-reference (usually a reference to a terminal rule).\n * A cross-reference can declare this expression explicitly in the form `[Type : Terminal]`, but if `Terminal`\n * is omitted, this function attempts to infer it from the name of the referenced `Type` (using `findNameAssignment`).\n *\n * Returns the grammar expression used to parse the given cross-reference, or `undefined` if it is not declared\n * and cannot be inferred.\n */\nexport function getCrossReferenceTerminal(crossRef: ast.CrossReference): ast.AbstractElement | undefined {\n    if (crossRef.terminal) {\n        return crossRef.terminal;\n    } else if (crossRef.type.ref) {\n        const nameAssigment = findNameAssignment(crossRef.type.ref);\n        return nameAssigment?.terminal;\n    }\n    return undefined;\n}\n\n/**\n * Determines whether the given terminal rule represents a comment. This is true if the rule is marked\n * as `hidden` and it does not match white space. This means every hidden token (i.e. excluded from the AST)\n * that contains visible characters is considered a comment.\n */\nexport function isCommentTerminal(terminalRule: ast.TerminalRule): boolean {\n    return terminalRule.hidden && !terminalRegex(terminalRule).test(' ');\n}\n\n/**\n * Find all CST nodes within the given node that contribute to the specified property.\n *\n * @param node A CST node in which to look for property assignments. If this is undefined, the result is an empty array.\n * @param property A property name of the constructed AST node. If this is undefined, the result is an empty array.\n */\nexport function findNodesForProperty(node: CstNode | undefined, property: string | undefined): CstNode[] {\n    if (!node || !property) {\n        return [];\n    }\n    return findNodesForPropertyInternal(node, property, node.astNode, true);\n}\n\n/**\n * Find a single CST node within the given node that contributes to the specified property.\n *\n * @param node A CST node in which to look for property assignments. If this is undefined, the result is `undefined`.\n * @param property A property name of the constructed AST node. If this is undefined, the result is `undefined`.\n * @param index If no index is specified or the index is less than zero, the first found node is returned. If the\n *        specified index exceeds the number of assignments to the property, the last found node is returned. Otherwise,\n *        the node with the specified index is returned.\n */\nexport function findNodeForProperty(node: CstNode | undefined, property: string | undefined, index?: number): CstNode | undefined {\n    if (!node || !property) {\n        return undefined;\n    }\n    const nodes = findNodesForPropertyInternal(node, property, node.astNode, true);\n    if (nodes.length === 0) {\n        return undefined;\n    }\n    if (index !== undefined) {\n        index = Math.max(0, Math.min(index, nodes.length - 1));\n    } else {\n        index = 0;\n    }\n    return nodes[index];\n}\n\nfunction findNodesForPropertyInternal(node: CstNode, property: string, element: AstNode | undefined, first: boolean): CstNode[] {\n    if (!first) {\n        const nodeFeature = getContainerOfType(node.grammarSource, ast.isAssignment);\n        if (nodeFeature && nodeFeature.feature === property) {\n            return [node];\n        }\n    }\n    if (isCompositeCstNode(node) && node.astNode === element) {\n        return node.content.flatMap(e => findNodesForPropertyInternal(e, property, element, false));\n    }\n    return [];\n}\n\n/**\n * Find all CST nodes within the given node that correspond to the specified keyword.\n *\n * @param node A CST node in which to look for keywords. If this is undefined, the result is an empty array.\n * @param keyword A keyword as specified in the grammar.\n */\nexport function findNodesForKeyword(node: CstNode | undefined, keyword: string): CstNode[] {\n    if (!node) {\n        return [];\n    }\n    return findNodesForKeywordInternal(node, keyword, node?.astNode);\n}\n\n/**\n * Find a single CST node within the given node that corresponds to the specified keyword.\n *\n * @param node A CST node in which to look for keywords. If this is undefined, the result is `undefined`.\n * @param keyword A keyword as specified in the grammar.\n * @param index If no index is specified or the index is less than zero, the first found node is returned. If the\n *        specified index exceeds the number of keyword occurrences, the last found node is returned. Otherwise,\n *        the node with the specified index is returned.\n */\nexport function findNodeForKeyword(node: CstNode | undefined, keyword: string, index?: number): CstNode | undefined {\n    if (!node) {\n        return undefined;\n    }\n    const nodes = findNodesForKeywordInternal(node, keyword, node?.astNode);\n    if (nodes.length === 0) {\n        return undefined;\n    }\n    if (index !== undefined) {\n        index = Math.max(0, Math.min(index, nodes.length - 1));\n    } else {\n        index = 0;\n    }\n    return nodes[index];\n}\n\nexport function findNodesForKeywordInternal(node: CstNode, keyword: string, element: AstNode | undefined): CstNode[] {\n    if (node.astNode !== element) {\n        return [];\n    }\n    if (ast.isKeyword(node.grammarSource) && node.grammarSource.value === keyword) {\n        return [node];\n    }\n    const treeIterator = streamCst(node).iterator();\n    let result: IteratorResult<CstNode>;\n    const keywordNodes: CstNode[] = [];\n    do {\n        result = treeIterator.next();\n        if (!result.done) {\n            const childNode = result.value;\n            if (childNode.astNode === element) {\n                if (ast.isKeyword(childNode.grammarSource) && childNode.grammarSource.value === keyword) {\n                    keywordNodes.push(childNode);\n                }\n            } else {\n                treeIterator.prune();\n            }\n        }\n    } while (!result.done);\n    return keywordNodes;\n}\n\n/**\n * If the given CST node was parsed in the context of a property assignment, the respective `Assignment` grammar\n * node is returned. If no assignment is found, the result is `undefined`.\n *\n * @param cstNode A CST node for which to find a property assignment.\n */\nexport function findAssignment(cstNode: CstNode): ast.Assignment | undefined {\n    const astNode = cstNode.astNode;\n    // Only search until the ast node of the parent cst node is no longer the original ast node\n    // This would make us jump to a preceding rule call, which contains only unrelated assignments\n    while (astNode === cstNode.container?.astNode) {\n        const assignment = getContainerOfType(cstNode.grammarSource, ast.isAssignment);\n        if (assignment) {\n            return assignment;\n        }\n        cstNode = cstNode.container;\n    }\n    return undefined;\n}\n\n/**\n * Find an assignment to the `name` property for the given grammar type. This requires the `type` to be inferred\n * from a parser rule, and that rule must contain an assignment to the `name` property. In all other cases,\n * this function returns `undefined`.\n */\nexport function findNameAssignment(type: ast.AbstractType): ast.Assignment | undefined {\n    let startNode: AstNode = type;\n    if (ast.isInferredType(startNode)) {\n        // for inferred types, the location to start searching for the name-assignment is different\n        if (ast.isAction(startNode.$container)) {\n            // a type which is explicitly inferred by an action: investigate the sibbling of the Action node, i.e. start searching at the Action's parent\n            startNode = startNode.$container.$container!;\n        } else if (ast.isParserRule(startNode.$container)) {\n            // investigate the parser rule with the explicitly inferred type\n            startNode = startNode.$container;\n        } else {\n            assertUnreachable(startNode.$container);\n        }\n    }\n    return findNameAssignmentInternal(type, startNode, new Map());\n}\n\nfunction findNameAssignmentInternal(type: ast.AbstractType, startNode: AstNode, cache: Map<ast.AbstractType, ast.Assignment | undefined>): ast.Assignment | undefined {\n    // the cache is only required to prevent infinite loops\n    function go(node: AstNode, refType: ast.AbstractType): ast.Assignment | undefined {\n        let childAssignment: ast.Assignment | undefined = undefined;\n        const parentAssignment = getContainerOfType(node, ast.isAssignment);\n        // No parent assignment implies unassigned rule call\n        if (!parentAssignment) {\n            childAssignment = findNameAssignmentInternal(refType, refType, cache);\n        }\n        cache.set(type, childAssignment);\n        return childAssignment;\n    }\n\n    if (cache.has(type)) {\n        return cache.get(type);\n    }\n    cache.set(type, undefined);\n    for (const node of streamAllContents(startNode)) {\n        if (ast.isAssignment(node) && node.feature.toLowerCase() === 'name') {\n            cache.set(type, node);\n            return node;\n        } else if (ast.isRuleCall(node) && ast.isParserRule(node.rule.ref)) {\n            return go(node, node.rule.ref);\n        } else if (ast.isSimpleType(node) && node.typeRef?.ref) {\n            return go(node, node.typeRef.ref);\n        }\n    }\n    return undefined;\n}\n\nexport function getActionAtElement(element: ast.AbstractElement): ast.Action | undefined {\n    const parent = element.$container;\n    if (ast.isGroup(parent)) {\n        const elements = parent.elements;\n        const index = elements.indexOf(element);\n        for (let i = index - 1; i >= 0; i--) {\n            const item = elements[i];\n            if (ast.isAction(item)) {\n                return item;\n            } else {\n                const action = streamAllContents(elements[i]).find(ast.isAction);\n                if (action) {\n                    return action;\n                }\n            }\n        }\n    }\n    if (ast.isAbstractElement(parent)) {\n        return getActionAtElement(parent);\n    } else {\n        return undefined;\n    }\n}\n\nexport type Cardinality = '?' | '*' | '+' | undefined;\nexport type Operator = '=' | '+=' | '?=' | undefined;\n\nexport function isOptionalCardinality(cardinality?: Cardinality, element?: ast.AbstractElement): boolean {\n    return cardinality === '?' || cardinality === '*' || (ast.isGroup(element) && Boolean(element.guardCondition));\n}\n\nexport function isArrayCardinality(cardinality?: Cardinality): boolean {\n    return cardinality === '*' || cardinality === '+';\n}\n\nexport function isArrayOperator(operator?: Operator): boolean {\n    return operator === '+=';\n}\n\n/**\n * Determines whether the given parser rule is a _data type rule_, meaning that it has a\n * primitive return type like `number`, `boolean`, etc.\n */\nexport function isDataTypeRule(rule: ast.ParserRule): boolean {\n    return isDataTypeRuleInternal(rule, new Set());\n}\n\nfunction isDataTypeRuleInternal(rule: ast.ParserRule, visited: Set<ast.ParserRule>): boolean {\n    if (visited.has(rule)) {\n        return true;\n    } else {\n        visited.add(rule);\n    }\n    for (const node of streamAllContents(rule)) {\n        if (ast.isRuleCall(node)) {\n            if (!node.rule.ref) {\n                // RuleCall to unresolved rule. Don't assume `rule` is a DataType rule.\n                return false;\n            }\n            if (ast.isParserRule(node.rule.ref) && !isDataTypeRuleInternal(node.rule.ref, visited)) {\n                return false;\n            }\n        } else if (ast.isAssignment(node)) {\n            return false;\n        } else if (ast.isAction(node)) {\n            return false;\n        }\n    }\n    return Boolean(rule.definition);\n}\n\nexport function isDataType(type: ast.Type): boolean {\n    return isDataTypeInternal(type.type, new Set());\n}\n\nfunction isDataTypeInternal(type: ast.TypeDefinition, visited: Set<ast.TypeDefinition>): boolean {\n    if (visited.has(type)) {\n        return true;\n    } else {\n        visited.add(type);\n    }\n    if (ast.isArrayType(type)) {\n        return false;\n    } else if (ast.isReferenceType(type)) {\n        return false;\n    } else if (ast.isUnionType(type)) {\n        return type.types.every(e => isDataTypeInternal(e, visited));\n    } else if (ast.isSimpleType(type)) {\n        if (type.primitiveType !== undefined) {\n            return true;\n        } else if (type.stringType !== undefined) {\n            return true;\n        } else if (type.typeRef !== undefined) {\n            const ref = type.typeRef.ref;\n            if (ast.isType(ref)) {\n                return isDataTypeInternal(ref.type, visited);\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    } else {\n        return false;\n    }\n}\n\nexport function getExplicitRuleType(rule: ast.ParserRule): string | undefined {\n    if (rule.inferredType) {\n        return rule.inferredType.name;\n    } else if (rule.dataType) {\n        return rule.dataType;\n    } else if (rule.returnType) {\n        const refType = rule.returnType.ref;\n        if(refType) {\n            // check if we need to check Action as return type\n            if (ast.isParserRule(refType)) {\n                return refType.name;\n            }  else if(ast.isInterface(refType) || ast.isType(refType)) {\n                return refType.name;\n            }\n        }\n    }\n    return undefined;\n}\n\nexport function getTypeName(type: ast.AbstractType | ast.Action): string {\n    if (ast.isParserRule(type)) {\n        return isDataTypeRule(type) ? type.name : getExplicitRuleType(type) ?? type.name;\n    } else if (ast.isInterface(type) || ast.isType(type) || ast.isReturnType(type)) {\n        return type.name;\n    } else if (ast.isAction(type)) {\n        const actionType = getActionType(type);\n        if (actionType) {\n            return actionType;\n        }\n    } else if (ast.isInferredType(type)) {\n        return type.name;\n    }\n    throw new Error('Cannot get name of Unknown Type');\n}\n\nexport function getActionType(action: ast.Action): string | undefined {\n    if (action.inferredType) {\n        return action.inferredType.name;\n    } else if (action.type?.ref) {\n        return getTypeName(action.type.ref);\n    }\n    return undefined; // not inferring and not referencing a valid type\n}\n\nexport function getRuleType(rule: ast.AbstractRule): string {\n    if (ast.isTerminalRule(rule)) {\n        return rule.type?.name ?? 'string';\n    } else {\n        return isDataTypeRule(rule) ? rule.name : getExplicitRuleType(rule) ?? rule.name;\n    }\n}\n\nexport function terminalRegex(terminalRule: ast.TerminalRule): RegExp {\n    const flags: Flags = {\n        s: false,\n        i: false,\n        u: false\n    };\n    const source = abstractElementToRegex(terminalRule.definition, flags);\n    const flagText = Object.entries(flags).filter(([, value]) => value).map(([name]) => name).join('');\n    return new RegExp(source, flagText);\n}\n\n// Using [\\s\\S]* allows to match everything, compared to . which doesn't match line terminators\nconst WILDCARD = /[\\s\\S]/.source;\n\ntype Flags = {\n    s: boolean;\n    i: boolean;\n    u: boolean;\n}\n\nfunction abstractElementToRegex(element: ast.AbstractElement, flags?: Flags): string {\n    if (ast.isTerminalAlternatives(element)) {\n        return terminalAlternativesToRegex(element);\n    } else if (ast.isTerminalGroup(element)) {\n        return terminalGroupToRegex(element);\n    } else if (ast.isCharacterRange(element)) {\n        return characterRangeToRegex(element);\n    } else if (ast.isTerminalRuleCall(element)) {\n        const rule = element.rule.ref;\n        if (!rule) {\n            throw new Error('Missing rule reference.');\n        }\n        return withCardinality(abstractElementToRegex(rule.definition), {\n            cardinality: element.cardinality,\n            lookahead: element.lookahead\n        });\n    } else if (ast.isNegatedToken(element)) {\n        return negateTokenToRegex(element);\n    } else if (ast.isUntilToken(element)) {\n        return untilTokenToRegex(element);\n    } else if (ast.isRegexToken(element)) {\n        const lastSlash = element.regex.lastIndexOf('/');\n        const source = element.regex.substring(1, lastSlash);\n        const regexFlags = element.regex.substring(lastSlash + 1);\n        if (flags) {\n            flags.i = regexFlags.includes('i');\n            flags.s = regexFlags.includes('s');\n            flags.u = regexFlags.includes('u');\n        }\n        return withCardinality(source, {\n            cardinality: element.cardinality,\n            lookahead: element.lookahead,\n            wrap: false\n        });\n    } else if (ast.isWildcard(element)) {\n        return withCardinality(WILDCARD, {\n            cardinality: element.cardinality,\n            lookahead: element.lookahead\n        });\n    } else {\n        throw new Error(`Invalid terminal element: ${element?.$type}`);\n    }\n}\n\nfunction terminalAlternativesToRegex(alternatives: ast.TerminalAlternatives): string {\n    return withCardinality(alternatives.elements.map(e => abstractElementToRegex(e)).join('|'), {\n        cardinality: alternatives.cardinality,\n        lookahead: alternatives.lookahead\n    });\n}\n\nfunction terminalGroupToRegex(group: ast.TerminalGroup): string {\n    return withCardinality(group.elements.map(e => abstractElementToRegex(e)).join(''), {\n        cardinality: group.cardinality,\n        lookahead: group.lookahead\n    });\n}\n\nfunction untilTokenToRegex(until: ast.UntilToken): string {\n    return withCardinality(`${WILDCARD}*?${abstractElementToRegex(until.terminal)}`, {\n        cardinality: until.cardinality,\n        lookahead: until.lookahead\n    });\n}\n\nfunction negateTokenToRegex(negate: ast.NegatedToken): string {\n    return withCardinality(`(?!${abstractElementToRegex(negate.terminal)})${WILDCARD}*?`, {\n        cardinality: negate.cardinality,\n        lookahead: negate.lookahead\n    });\n}\n\nfunction characterRangeToRegex(range: ast.CharacterRange): string {\n    if (range.right) {\n        return withCardinality(`[${keywordToRegex(range.left)}-${keywordToRegex(range.right)}]`, {\n            cardinality: range.cardinality,\n            lookahead: range.lookahead,\n            wrap: false\n        });\n    }\n    return withCardinality(keywordToRegex(range.left), {\n        cardinality: range.cardinality,\n        lookahead: range.lookahead,\n        wrap: false\n    });\n}\n\nfunction keywordToRegex(keyword: ast.Keyword): string {\n    return escapeRegExp(keyword.value);\n}\n\nfunction withCardinality(regex: string, options: {\n    cardinality?: string\n    wrap?: boolean\n    lookahead?: string\n}): string {\n    if (options.wrap !== false || options.lookahead) {\n        regex = `(${options.lookahead ?? ''}${regex})`;\n    }\n    if (options.cardinality) {\n        return `${regex}${options.cardinality}`;\n    }\n    return regex;\n}\n", "/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { CstNode } from '../syntax-tree.js';\n\nexport class ErrorWithLocation extends Error {\n    constructor(node: CstNode | undefined, message: string) {\n        super(node ? `${message} at ${node.range.start.line}:${node.range.start.character}` : message);\n    }\n}\n\nexport function assertUnreachable(_: never): never {\n    throw new Error('Error! The input value was not handled.');\n}\n", "/******************************************************************************\n * This file was generated by langium-cli 3.0.0.\n * DO NOT EDIT MANUALLY!\n ******************************************************************************/\n\n/* eslint-disable */\nimport type { AstNode, Reference, ReferenceInfo, TypeMetaData } from '../../syntax-tree.js';\nimport { AbstractAstReflection } from '../../syntax-tree.js';\n\nexport const LangiumGrammarTerminals = {\n    ID: /\\^?[_a-zA-Z][\\w_]*/,\n    STRING: /\"(\\\\.|[^\"\\\\])*\"|'(\\\\.|[^'\\\\])*'/,\n    NUMBER: /NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity)/,\n    RegexLiteral: /\\/(?![*+?])(?:[^\\r\\n\\[/\\\\]|\\\\.|\\[(?:[^\\r\\n\\]\\\\]|\\\\.)*\\])+\\/[a-z]*/,\n    WS: /\\s+/,\n    ML_COMMENT: /\\/\\*[\\s\\S]*?\\*\\//,\n    SL_COMMENT: /\\/\\/[^\\n\\r]*/,\n};\n\nexport type AbstractRule = ParserRule | TerminalRule;\n\nexport const AbstractRule = 'AbstractRule';\n\nexport function isAbstractRule(item: unknown): item is AbstractRule {\n    return reflection.isInstance(item, AbstractRule);\n}\n\nexport type AbstractType = InferredType | Interface | ParserRule | Type;\n\nexport const AbstractType = 'AbstractType';\n\nexport function isAbstractType(item: unknown): item is AbstractType {\n    return reflection.isInstance(item, AbstractType);\n}\n\nexport type Condition = BooleanLiteral | Conjunction | Disjunction | Negation | ParameterReference;\n\nexport const Condition = 'Condition';\n\nexport function isCondition(item: unknown): item is Condition {\n    return reflection.isInstance(item, Condition);\n}\n\nexport type FeatureName = 'current' | 'entry' | 'extends' | 'false' | 'fragment' | 'grammar' | 'hidden' | 'import' | 'infer' | 'infers' | 'interface' | 'returns' | 'terminal' | 'true' | 'type' | 'with' | PrimitiveType | string;\n\nexport function isFeatureName(item: unknown): item is FeatureName {\n    return isPrimitiveType(item) || item === 'current' || item === 'entry' || item === 'extends' || item === 'false' || item === 'fragment' || item === 'grammar' || item === 'hidden' || item === 'import' || item === 'interface' || item === 'returns' || item === 'terminal' || item === 'true' || item === 'type' || item === 'infer' || item === 'infers' || item === 'with' || (typeof item === 'string' && (/\\^?[_a-zA-Z][\\w_]*/.test(item)));\n}\n\nexport type PrimitiveType = 'Date' | 'bigint' | 'boolean' | 'number' | 'string';\n\nexport function isPrimitiveType(item: unknown): item is PrimitiveType {\n    return item === 'string' || item === 'number' || item === 'boolean' || item === 'Date' || item === 'bigint';\n}\n\nexport type TypeDefinition = ArrayType | ReferenceType | SimpleType | UnionType;\n\nexport const TypeDefinition = 'TypeDefinition';\n\nexport function isTypeDefinition(item: unknown): item is TypeDefinition {\n    return reflection.isInstance(item, TypeDefinition);\n}\n\nexport type ValueLiteral = ArrayLiteral | BooleanLiteral | NumberLiteral | StringLiteral;\n\nexport const ValueLiteral = 'ValueLiteral';\n\nexport function isValueLiteral(item: unknown): item is ValueLiteral {\n    return reflection.isInstance(item, ValueLiteral);\n}\n\nexport interface AbstractElement extends AstNode {\n    readonly $type: 'AbstractElement' | 'Action' | 'Alternatives' | 'Assignment' | 'CharacterRange' | 'CrossReference' | 'EndOfFile' | 'Group' | 'Keyword' | 'NegatedToken' | 'RegexToken' | 'RuleCall' | 'TerminalAlternatives' | 'TerminalGroup' | 'TerminalRuleCall' | 'UnorderedGroup' | 'UntilToken' | 'Wildcard';\n    cardinality?: '*' | '+' | '?';\n    lookahead?: '?!' | '?<!' | '?<=' | '?=';\n}\n\nexport const AbstractElement = 'AbstractElement';\n\nexport function isAbstractElement(item: unknown): item is AbstractElement {\n    return reflection.isInstance(item, AbstractElement);\n}\n\nexport interface ArrayLiteral extends AstNode {\n    readonly $container: ArrayLiteral | TypeAttribute;\n    readonly $type: 'ArrayLiteral';\n    elements: Array<ValueLiteral>;\n}\n\nexport const ArrayLiteral = 'ArrayLiteral';\n\nexport function isArrayLiteral(item: unknown): item is ArrayLiteral {\n    return reflection.isInstance(item, ArrayLiteral);\n}\n\nexport interface ArrayType extends AstNode {\n    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;\n    readonly $type: 'ArrayType';\n    elementType: TypeDefinition;\n}\n\nexport const ArrayType = 'ArrayType';\n\nexport function isArrayType(item: unknown): item is ArrayType {\n    return reflection.isInstance(item, ArrayType);\n}\n\nexport interface BooleanLiteral extends AstNode {\n    readonly $container: ArrayLiteral | Conjunction | Disjunction | Group | NamedArgument | Negation | TypeAttribute;\n    readonly $type: 'BooleanLiteral';\n    true: boolean;\n}\n\nexport const BooleanLiteral = 'BooleanLiteral';\n\nexport function isBooleanLiteral(item: unknown): item is BooleanLiteral {\n    return reflection.isInstance(item, BooleanLiteral);\n}\n\nexport interface Conjunction extends AstNode {\n    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;\n    readonly $type: 'Conjunction';\n    left: Condition;\n    right: Condition;\n}\n\nexport const Conjunction = 'Conjunction';\n\nexport function isConjunction(item: unknown): item is Conjunction {\n    return reflection.isInstance(item, Conjunction);\n}\n\nexport interface Disjunction extends AstNode {\n    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;\n    readonly $type: 'Disjunction';\n    left: Condition;\n    right: Condition;\n}\n\nexport const Disjunction = 'Disjunction';\n\nexport function isDisjunction(item: unknown): item is Disjunction {\n    return reflection.isInstance(item, Disjunction);\n}\n\nexport interface Grammar extends AstNode {\n    readonly $type: 'Grammar';\n    definesHiddenTokens: boolean;\n    hiddenTokens: Array<Reference<AbstractRule>>;\n    imports: Array<GrammarImport>;\n    interfaces: Array<Interface>;\n    isDeclared: boolean;\n    name?: string;\n    rules: Array<AbstractRule>;\n    types: Array<Type>;\n    usedGrammars: Array<Reference<Grammar>>;\n}\n\nexport const Grammar = 'Grammar';\n\nexport function isGrammar(item: unknown): item is Grammar {\n    return reflection.isInstance(item, Grammar);\n}\n\nexport interface GrammarImport extends AstNode {\n    readonly $container: Grammar;\n    readonly $type: 'GrammarImport';\n    path: string;\n}\n\nexport const GrammarImport = 'GrammarImport';\n\nexport function isGrammarImport(item: unknown): item is GrammarImport {\n    return reflection.isInstance(item, GrammarImport);\n}\n\nexport interface InferredType extends AstNode {\n    readonly $container: Action | ParserRule;\n    readonly $type: 'InferredType';\n    name: string;\n}\n\nexport const InferredType = 'InferredType';\n\nexport function isInferredType(item: unknown): item is InferredType {\n    return reflection.isInstance(item, InferredType);\n}\n\nexport interface Interface extends AstNode {\n    readonly $container: Grammar;\n    readonly $type: 'Interface';\n    attributes: Array<TypeAttribute>;\n    name: string;\n    superTypes: Array<Reference<AbstractType>>;\n}\n\nexport const Interface = 'Interface';\n\nexport function isInterface(item: unknown): item is Interface {\n    return reflection.isInstance(item, Interface);\n}\n\nexport interface NamedArgument extends AstNode {\n    readonly $container: RuleCall;\n    readonly $type: 'NamedArgument';\n    calledByName: boolean;\n    parameter?: Reference<Parameter>;\n    value: Condition;\n}\n\nexport const NamedArgument = 'NamedArgument';\n\nexport function isNamedArgument(item: unknown): item is NamedArgument {\n    return reflection.isInstance(item, NamedArgument);\n}\n\nexport interface Negation extends AstNode {\n    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;\n    readonly $type: 'Negation';\n    value: Condition;\n}\n\nexport const Negation = 'Negation';\n\nexport function isNegation(item: unknown): item is Negation {\n    return reflection.isInstance(item, Negation);\n}\n\nexport interface NumberLiteral extends AstNode {\n    readonly $container: ArrayLiteral | TypeAttribute;\n    readonly $type: 'NumberLiteral';\n    value: number;\n}\n\nexport const NumberLiteral = 'NumberLiteral';\n\nexport function isNumberLiteral(item: unknown): item is NumberLiteral {\n    return reflection.isInstance(item, NumberLiteral);\n}\n\nexport interface Parameter extends AstNode {\n    readonly $container: ParserRule;\n    readonly $type: 'Parameter';\n    name: string;\n}\n\nexport const Parameter = 'Parameter';\n\nexport function isParameter(item: unknown): item is Parameter {\n    return reflection.isInstance(item, Parameter);\n}\n\nexport interface ParameterReference extends AstNode {\n    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;\n    readonly $type: 'ParameterReference';\n    parameter: Reference<Parameter>;\n}\n\nexport const ParameterReference = 'ParameterReference';\n\nexport function isParameterReference(item: unknown): item is ParameterReference {\n    return reflection.isInstance(item, ParameterReference);\n}\n\nexport interface ParserRule extends AstNode {\n    readonly $container: Grammar;\n    readonly $type: 'ParserRule';\n    dataType?: PrimitiveType;\n    definesHiddenTokens: boolean;\n    definition: AbstractElement;\n    entry: boolean;\n    fragment: boolean;\n    hiddenTokens: Array<Reference<AbstractRule>>;\n    inferredType?: InferredType;\n    name: string;\n    parameters: Array<Parameter>;\n    returnType?: Reference<AbstractType>;\n    wildcard: boolean;\n}\n\nexport const ParserRule = 'ParserRule';\n\nexport function isParserRule(item: unknown): item is ParserRule {\n    return reflection.isInstance(item, ParserRule);\n}\n\nexport interface ReferenceType extends AstNode {\n    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;\n    readonly $type: 'ReferenceType';\n    referenceType: TypeDefinition;\n}\n\nexport const ReferenceType = 'ReferenceType';\n\nexport function isReferenceType(item: unknown): item is ReferenceType {\n    return reflection.isInstance(item, ReferenceType);\n}\n\nexport interface ReturnType extends AstNode {\n    readonly $container: TerminalRule;\n    readonly $type: 'ReturnType';\n    name: PrimitiveType | string;\n}\n\nexport const ReturnType = 'ReturnType';\n\nexport function isReturnType(item: unknown): item is ReturnType {\n    return reflection.isInstance(item, ReturnType);\n}\n\nexport interface SimpleType extends AstNode {\n    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;\n    readonly $type: 'SimpleType';\n    primitiveType?: PrimitiveType;\n    stringType?: string;\n    typeRef?: Reference<AbstractType>;\n}\n\nexport const SimpleType = 'SimpleType';\n\nexport function isSimpleType(item: unknown): item is SimpleType {\n    return reflection.isInstance(item, SimpleType);\n}\n\nexport interface StringLiteral extends AstNode {\n    readonly $container: ArrayLiteral | TypeAttribute;\n    readonly $type: 'StringLiteral';\n    value: string;\n}\n\nexport const StringLiteral = 'StringLiteral';\n\nexport function isStringLiteral(item: unknown): item is StringLiteral {\n    return reflection.isInstance(item, StringLiteral);\n}\n\nexport interface TerminalRule extends AstNode {\n    readonly $container: Grammar;\n    readonly $type: 'TerminalRule';\n    definition: AbstractElement;\n    fragment: boolean;\n    hidden: boolean;\n    name: string;\n    type?: ReturnType;\n}\n\nexport const TerminalRule = 'TerminalRule';\n\nexport function isTerminalRule(item: unknown): item is TerminalRule {\n    return reflection.isInstance(item, TerminalRule);\n}\n\nexport interface Type extends AstNode {\n    readonly $container: Grammar;\n    readonly $type: 'Type';\n    name: string;\n    type: TypeDefinition;\n}\n\nexport const Type = 'Type';\n\nexport function isType(item: unknown): item is Type {\n    return reflection.isInstance(item, Type);\n}\n\nexport interface TypeAttribute extends AstNode {\n    readonly $container: Interface;\n    readonly $type: 'TypeAttribute';\n    defaultValue?: ValueLiteral;\n    isOptional: boolean;\n    name: FeatureName;\n    type: TypeDefinition;\n}\n\nexport const TypeAttribute = 'TypeAttribute';\n\nexport function isTypeAttribute(item: unknown): item is TypeAttribute {\n    return reflection.isInstance(item, TypeAttribute);\n}\n\nexport interface UnionType extends AstNode {\n    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;\n    readonly $type: 'UnionType';\n    types: Array<TypeDefinition>;\n}\n\nexport const UnionType = 'UnionType';\n\nexport function isUnionType(item: unknown): item is UnionType {\n    return reflection.isInstance(item, UnionType);\n}\n\nexport interface Action extends AbstractElement {\n    readonly $type: 'Action';\n    feature?: FeatureName;\n    inferredType?: InferredType;\n    operator?: '+=' | '=';\n    type?: Reference<AbstractType>;\n}\n\nexport const Action = 'Action';\n\nexport function isAction(item: unknown): item is Action {\n    return reflection.isInstance(item, Action);\n}\n\nexport interface Alternatives extends AbstractElement {\n    readonly $type: 'Alternatives';\n    elements: Array<AbstractElement>;\n}\n\nexport const Alternatives = 'Alternatives';\n\nexport function isAlternatives(item: unknown): item is Alternatives {\n    return reflection.isInstance(item, Alternatives);\n}\n\nexport interface Assignment extends AbstractElement {\n    readonly $type: 'Assignment';\n    feature: FeatureName;\n    operator: '+=' | '=' | '?=';\n    terminal: AbstractElement;\n}\n\nexport const Assignment = 'Assignment';\n\nexport function isAssignment(item: unknown): item is Assignment {\n    return reflection.isInstance(item, Assignment);\n}\n\nexport interface CharacterRange extends AbstractElement {\n    readonly $type: 'CharacterRange';\n    left: Keyword;\n    right?: Keyword;\n}\n\nexport const CharacterRange = 'CharacterRange';\n\nexport function isCharacterRange(item: unknown): item is CharacterRange {\n    return reflection.isInstance(item, CharacterRange);\n}\n\nexport interface CrossReference extends AbstractElement {\n    readonly $type: 'CrossReference';\n    deprecatedSyntax: boolean;\n    terminal?: AbstractElement;\n    type: Reference<AbstractType>;\n}\n\nexport const CrossReference = 'CrossReference';\n\nexport function isCrossReference(item: unknown): item is CrossReference {\n    return reflection.isInstance(item, CrossReference);\n}\n\nexport interface EndOfFile extends AbstractElement {\n    readonly $type: 'EndOfFile';\n}\n\nexport const EndOfFile = 'EndOfFile';\n\nexport function isEndOfFile(item: unknown): item is EndOfFile {\n    return reflection.isInstance(item, EndOfFile);\n}\n\nexport interface Group extends AbstractElement {\n    readonly $type: 'Group';\n    elements: Array<AbstractElement>;\n    guardCondition?: Condition;\n}\n\nexport const Group = 'Group';\n\nexport function isGroup(item: unknown): item is Group {\n    return reflection.isInstance(item, Group);\n}\n\nexport interface Keyword extends AbstractElement {\n    readonly $container: CharacterRange;\n    readonly $type: 'Keyword';\n    value: string;\n}\n\nexport const Keyword = 'Keyword';\n\nexport function isKeyword(item: unknown): item is Keyword {\n    return reflection.isInstance(item, Keyword);\n}\n\nexport interface NegatedToken extends AbstractElement {\n    readonly $type: 'NegatedToken';\n    terminal: AbstractElement;\n}\n\nexport const NegatedToken = 'NegatedToken';\n\nexport function isNegatedToken(item: unknown): item is NegatedToken {\n    return reflection.isInstance(item, NegatedToken);\n}\n\nexport interface RegexToken extends AbstractElement {\n    readonly $type: 'RegexToken';\n    regex: string;\n}\n\nexport const RegexToken = 'RegexToken';\n\nexport function isRegexToken(item: unknown): item is RegexToken {\n    return reflection.isInstance(item, RegexToken);\n}\n\nexport interface RuleCall extends AbstractElement {\n    readonly $type: 'RuleCall';\n    arguments: Array<NamedArgument>;\n    rule: Reference<AbstractRule>;\n}\n\nexport const RuleCall = 'RuleCall';\n\nexport function isRuleCall(item: unknown): item is RuleCall {\n    return reflection.isInstance(item, RuleCall);\n}\n\nexport interface TerminalAlternatives extends AbstractElement {\n    readonly $type: 'TerminalAlternatives';\n    elements: Array<AbstractElement>;\n}\n\nexport const TerminalAlternatives = 'TerminalAlternatives';\n\nexport function isTerminalAlternatives(item: unknown): item is TerminalAlternatives {\n    return reflection.isInstance(item, TerminalAlternatives);\n}\n\nexport interface TerminalGroup extends AbstractElement {\n    readonly $type: 'TerminalGroup';\n    elements: Array<AbstractElement>;\n}\n\nexport const TerminalGroup = 'TerminalGroup';\n\nexport function isTerminalGroup(item: unknown): item is TerminalGroup {\n    return reflection.isInstance(item, TerminalGroup);\n}\n\nexport interface TerminalRuleCall extends AbstractElement {\n    readonly $type: 'TerminalRuleCall';\n    rule: Reference<TerminalRule>;\n}\n\nexport const TerminalRuleCall = 'TerminalRuleCall';\n\nexport function isTerminalRuleCall(item: unknown): item is TerminalRuleCall {\n    return reflection.isInstance(item, TerminalRuleCall);\n}\n\nexport interface UnorderedGroup extends AbstractElement {\n    readonly $type: 'UnorderedGroup';\n    elements: Array<AbstractElement>;\n}\n\nexport const UnorderedGroup = 'UnorderedGroup';\n\nexport function isUnorderedGroup(item: unknown): item is UnorderedGroup {\n    return reflection.isInstance(item, UnorderedGroup);\n}\n\nexport interface UntilToken extends AbstractElement {\n    readonly $type: 'UntilToken';\n    terminal: AbstractElement;\n}\n\nexport const UntilToken = 'UntilToken';\n\nexport function isUntilToken(item: unknown): item is UntilToken {\n    return reflection.isInstance(item, UntilToken);\n}\n\nexport interface Wildcard extends AbstractElement {\n    readonly $type: 'Wildcard';\n}\n\nexport const Wildcard = 'Wildcard';\n\nexport function isWildcard(item: unknown): item is Wildcard {\n    return reflection.isInstance(item, Wildcard);\n}\n\nexport type LangiumGrammarAstType = {\n    AbstractElement: AbstractElement\n    AbstractRule: AbstractRule\n    AbstractType: AbstractType\n    Action: Action\n    Alternatives: Alternatives\n    ArrayLiteral: ArrayLiteral\n    ArrayType: ArrayType\n    Assignment: Assignment\n    BooleanLiteral: BooleanLiteral\n    CharacterRange: CharacterRange\n    Condition: Condition\n    Conjunction: Conjunction\n    CrossReference: CrossReference\n    Disjunction: Disjunction\n    EndOfFile: EndOfFile\n    Grammar: Grammar\n    GrammarImport: GrammarImport\n    Group: Group\n    InferredType: InferredType\n    Interface: Interface\n    Keyword: Keyword\n    NamedArgument: NamedArgument\n    NegatedToken: NegatedToken\n    Negation: Negation\n    NumberLiteral: NumberLiteral\n    Parameter: Parameter\n    ParameterReference: ParameterReference\n    ParserRule: ParserRule\n    ReferenceType: ReferenceType\n    RegexToken: RegexToken\n    ReturnType: ReturnType\n    RuleCall: RuleCall\n    SimpleType: SimpleType\n    StringLiteral: StringLiteral\n    TerminalAlternatives: TerminalAlternatives\n    TerminalGroup: TerminalGroup\n    TerminalRule: TerminalRule\n    TerminalRuleCall: TerminalRuleCall\n    Type: Type\n    TypeAttribute: TypeAttribute\n    TypeDefinition: TypeDefinition\n    UnionType: UnionType\n    UnorderedGroup: UnorderedGroup\n    UntilToken: UntilToken\n    ValueLiteral: ValueLiteral\n    Wildcard: Wildcard\n}\n\nexport class LangiumGrammarAstReflection extends AbstractAstReflection {\n\n    getAllTypes(): string[] {\n        return ['AbstractElement', 'AbstractRule', 'AbstractType', 'Action', 'Alternatives', 'ArrayLiteral', 'ArrayType', 'Assignment', 'BooleanLiteral', 'CharacterRange', 'Condition', 'Conjunction', 'CrossReference', 'Disjunction', 'EndOfFile', 'Grammar', 'GrammarImport', 'Group', 'InferredType', 'Interface', 'Keyword', 'NamedArgument', 'NegatedToken', 'Negation', 'NumberLiteral', 'Parameter', 'ParameterReference', 'ParserRule', 'ReferenceType', 'RegexToken', 'ReturnType', 'RuleCall', 'SimpleType', 'StringLiteral', 'TerminalAlternatives', 'TerminalGroup', 'TerminalRule', 'TerminalRuleCall', 'Type', 'TypeAttribute', 'TypeDefinition', 'UnionType', 'UnorderedGroup', 'UntilToken', 'ValueLiteral', 'Wildcard'];\n    }\n\n    protected override computeIsSubtype(subtype: string, supertype: string): boolean {\n        switch (subtype) {\n            case Action:\n            case Alternatives:\n            case Assignment:\n            case CharacterRange:\n            case CrossReference:\n            case EndOfFile:\n            case Group:\n            case Keyword:\n            case NegatedToken:\n            case RegexToken:\n            case RuleCall:\n            case TerminalAlternatives:\n            case TerminalGroup:\n            case TerminalRuleCall:\n            case UnorderedGroup:\n            case UntilToken:\n            case Wildcard: {\n                return this.isSubtype(AbstractElement, supertype);\n            }\n            case ArrayLiteral:\n            case NumberLiteral:\n            case StringLiteral: {\n                return this.isSubtype(ValueLiteral, supertype);\n            }\n            case ArrayType:\n            case ReferenceType:\n            case SimpleType:\n            case UnionType: {\n                return this.isSubtype(TypeDefinition, supertype);\n            }\n            case BooleanLiteral: {\n                return this.isSubtype(Condition, supertype) || this.isSubtype(ValueLiteral, supertype);\n            }\n            case Conjunction:\n            case Disjunction:\n            case Negation:\n            case ParameterReference: {\n                return this.isSubtype(Condition, supertype);\n            }\n            case InferredType:\n            case Interface:\n            case Type: {\n                return this.isSubtype(AbstractType, supertype);\n            }\n            case ParserRule: {\n                return this.isSubtype(AbstractRule, supertype) || this.isSubtype(AbstractType, supertype);\n            }\n            case TerminalRule: {\n                return this.isSubtype(AbstractRule, supertype);\n            }\n            default: {\n                return false;\n            }\n        }\n    }\n\n    getReferenceType(refInfo: ReferenceInfo): string {\n        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;\n        switch (referenceId) {\n            case 'Action:type':\n            case 'CrossReference:type':\n            case 'Interface:superTypes':\n            case 'ParserRule:returnType':\n            case 'SimpleType:typeRef': {\n                return AbstractType;\n            }\n            case 'Grammar:hiddenTokens':\n            case 'ParserRule:hiddenTokens':\n            case 'RuleCall:rule': {\n                return AbstractRule;\n            }\n            case 'Grammar:usedGrammars': {\n                return Grammar;\n            }\n            case 'NamedArgument:parameter':\n            case 'ParameterReference:parameter': {\n                return Parameter;\n            }\n            case 'TerminalRuleCall:rule': {\n                return TerminalRule;\n            }\n            default: {\n                throw new Error(`${referenceId} is not a valid reference id.`);\n            }\n        }\n    }\n\n    getTypeMetaData(type: string): TypeMetaData {\n        switch (type) {\n            case 'AbstractElement': {\n                return {\n                    name: 'AbstractElement',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case 'ArrayLiteral': {\n                return {\n                    name: 'ArrayLiteral',\n                    properties: [\n                        { name: 'elements', defaultValue: [] }\n                    ]\n                };\n            }\n            case 'ArrayType': {\n                return {\n                    name: 'ArrayType',\n                    properties: [\n                        { name: 'elementType' }\n                    ]\n                };\n            }\n            case 'BooleanLiteral': {\n                return {\n                    name: 'BooleanLiteral',\n                    properties: [\n                        { name: 'true', defaultValue: false }\n                    ]\n                };\n            }\n            case 'Conjunction': {\n                return {\n                    name: 'Conjunction',\n                    properties: [\n                        { name: 'left' },\n                        { name: 'right' }\n                    ]\n                };\n            }\n            case 'Disjunction': {\n                return {\n                    name: 'Disjunction',\n                    properties: [\n                        { name: 'left' },\n                        { name: 'right' }\n                    ]\n                };\n            }\n            case 'Grammar': {\n                return {\n                    name: 'Grammar',\n                    properties: [\n                        { name: 'definesHiddenTokens', defaultValue: false },\n                        { name: 'hiddenTokens', defaultValue: [] },\n                        { name: 'imports', defaultValue: [] },\n                        { name: 'interfaces', defaultValue: [] },\n                        { name: 'isDeclared', defaultValue: false },\n                        { name: 'name' },\n                        { name: 'rules', defaultValue: [] },\n                        { name: 'types', defaultValue: [] },\n                        { name: 'usedGrammars', defaultValue: [] }\n                    ]\n                };\n            }\n            case 'GrammarImport': {\n                return {\n                    name: 'GrammarImport',\n                    properties: [\n                        { name: 'path' }\n                    ]\n                };\n            }\n            case 'InferredType': {\n                return {\n                    name: 'InferredType',\n                    properties: [\n                        { name: 'name' }\n                    ]\n                };\n            }\n            case 'Interface': {\n                return {\n                    name: 'Interface',\n                    properties: [\n                        { name: 'attributes', defaultValue: [] },\n                        { name: 'name' },\n                        { name: 'superTypes', defaultValue: [] }\n                    ]\n                };\n            }\n            case 'NamedArgument': {\n                return {\n                    name: 'NamedArgument',\n                    properties: [\n                        { name: 'calledByName', defaultValue: false },\n                        { name: 'parameter' },\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case 'Negation': {\n                return {\n                    name: 'Negation',\n                    properties: [\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case 'NumberLiteral': {\n                return {\n                    name: 'NumberLiteral',\n                    properties: [\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case 'Parameter': {\n                return {\n                    name: 'Parameter',\n                    properties: [\n                        { name: 'name' }\n                    ]\n                };\n            }\n            case 'ParameterReference': {\n                return {\n                    name: 'ParameterReference',\n                    properties: [\n                        { name: 'parameter' }\n                    ]\n                };\n            }\n            case 'ParserRule': {\n                return {\n                    name: 'ParserRule',\n                    properties: [\n                        { name: 'dataType' },\n                        { name: 'definesHiddenTokens', defaultValue: false },\n                        { name: 'definition' },\n                        { name: 'entry', defaultValue: false },\n                        { name: 'fragment', defaultValue: false },\n                        { name: 'hiddenTokens', defaultValue: [] },\n                        { name: 'inferredType' },\n                        { name: 'name' },\n                        { name: 'parameters', defaultValue: [] },\n                        { name: 'returnType' },\n                        { name: 'wildcard', defaultValue: false }\n                    ]\n                };\n            }\n            case 'ReferenceType': {\n                return {\n                    name: 'ReferenceType',\n                    properties: [\n                        { name: 'referenceType' }\n                    ]\n                };\n            }\n            case 'ReturnType': {\n                return {\n                    name: 'ReturnType',\n                    properties: [\n                        { name: 'name' }\n                    ]\n                };\n            }\n            case 'SimpleType': {\n                return {\n                    name: 'SimpleType',\n                    properties: [\n                        { name: 'primitiveType' },\n                        { name: 'stringType' },\n                        { name: 'typeRef' }\n                    ]\n                };\n            }\n            case 'StringLiteral': {\n                return {\n                    name: 'StringLiteral',\n                    properties: [\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case 'TerminalRule': {\n                return {\n                    name: 'TerminalRule',\n                    properties: [\n                        { name: 'definition' },\n                        { name: 'fragment', defaultValue: false },\n                        { name: 'hidden', defaultValue: false },\n                        { name: 'name' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case 'Type': {\n                return {\n                    name: 'Type',\n                    properties: [\n                        { name: 'name' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case 'TypeAttribute': {\n                return {\n                    name: 'TypeAttribute',\n                    properties: [\n                        { name: 'defaultValue' },\n                        { name: 'isOptional', defaultValue: false },\n                        { name: 'name' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case 'UnionType': {\n                return {\n                    name: 'UnionType',\n                    properties: [\n                        { name: 'types', defaultValue: [] }\n                    ]\n                };\n            }\n            case 'Action': {\n                return {\n                    name: 'Action',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'feature' },\n                        { name: 'inferredType' },\n                        { name: 'lookahead' },\n                        { name: 'operator' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case 'Alternatives': {\n                return {\n                    name: 'Alternatives',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case 'Assignment': {\n                return {\n                    name: 'Assignment',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'feature' },\n                        { name: 'lookahead' },\n                        { name: 'operator' },\n                        { name: 'terminal' }\n                    ]\n                };\n            }\n            case 'CharacterRange': {\n                return {\n                    name: 'CharacterRange',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'left' },\n                        { name: 'lookahead' },\n                        { name: 'right' }\n                    ]\n                };\n            }\n            case 'CrossReference': {\n                return {\n                    name: 'CrossReference',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'deprecatedSyntax', defaultValue: false },\n                        { name: 'lookahead' },\n                        { name: 'terminal' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case 'EndOfFile': {\n                return {\n                    name: 'EndOfFile',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case 'Group': {\n                return {\n                    name: 'Group',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'guardCondition' },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case 'Keyword': {\n                return {\n                    name: 'Keyword',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case 'NegatedToken': {\n                return {\n                    name: 'NegatedToken',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'terminal' }\n                    ]\n                };\n            }\n            case 'RegexToken': {\n                return {\n                    name: 'RegexToken',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'regex' }\n                    ]\n                };\n            }\n            case 'RuleCall': {\n                return {\n                    name: 'RuleCall',\n                    properties: [\n                        { name: 'arguments', defaultValue: [] },\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'rule' }\n                    ]\n                };\n            }\n            case 'TerminalAlternatives': {\n                return {\n                    name: 'TerminalAlternatives',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case 'TerminalGroup': {\n                return {\n                    name: 'TerminalGroup',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case 'TerminalRuleCall': {\n                return {\n                    name: 'TerminalRuleCall',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'rule' }\n                    ]\n                };\n            }\n            case 'UnorderedGroup': {\n                return {\n                    name: 'UnorderedGroup',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case 'UntilToken': {\n                return {\n                    name: 'UntilToken',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'terminal' }\n                    ]\n                };\n            }\n            case 'Wildcard': {\n                return {\n                    name: 'Wildcard',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            default: {\n                return {\n                    name: type,\n                    properties: []\n                };\n            }\n        }\n    }\n}\n\nexport const reflection = new LangiumGrammarAstReflection();\n", "/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { Range } from 'vscode-languageserver-types';\nimport type { AstNode, AstReflection, CstNode, GenericAstNode, Mutable, PropertyType, Reference, ReferenceInfo } from '../syntax-tree.js';\nimport type { Stream, TreeStream } from './stream.js';\nimport type { LangiumDocument } from '../workspace/documents.js';\nimport { isAstNode, isReference } from '../syntax-tree.js';\nimport { DONE_RESULT, stream, StreamImpl, TreeStreamImpl } from './stream.js';\nimport { inRange } from './cst-utils.js';\n\n/**\n * Link the `$container` and other related properties of every AST node that is directly contained\n * in the given `node`.\n */\nexport function linkContentToContainer(node: AstNode): void {\n    for (const [name, value] of Object.entries(node)) {\n        if (!name.startsWith('$')) {\n            if (Array.isArray(value)) {\n                value.forEach((item, index) => {\n                    if (isAstNode(item)) {\n                        (item as Mutable<AstNode>).$container = node;\n                        (item as Mutable<AstNode>).$containerProperty = name;\n                        (item as Mutable<AstNode>).$containerIndex = index;\n                    }\n                });\n            } else if (isAstNode(value)) {\n                (value as Mutable<AstNode>).$container = node;\n                (value as Mutable<AstNode>).$containerProperty = name;\n            }\n        }\n    }\n}\n\n/**\n * Walk along the hierarchy of containers from the given AST node to the root and return the first\n * node that matches the type predicate. If the start node itself matches, it is returned.\n * If no container matches, `undefined` is returned.\n */\nexport function getContainerOfType<T extends AstNode>(node: AstNode | undefined, typePredicate: (n: AstNode) => n is T): T | undefined {\n    let item = node;\n    while (item) {\n        if (typePredicate(item)) {\n            return item;\n        }\n        item = item.$container;\n    }\n    return undefined;\n}\n\n/**\n * Walk along the hierarchy of containers from the given AST node to the root and check for existence\n * of a container that matches the given predicate. The start node is included in the checks.\n */\nexport function hasContainerOfType(node: AstNode | undefined, predicate: (n: AstNode) => boolean): boolean {\n    let item = node;\n    while (item) {\n        if (predicate(item)) {\n            return true;\n        }\n        item = item.$container;\n    }\n    return false;\n}\n\n/**\n * Retrieve the document in which the given AST node is contained. A reference to the document is\n * usually held by the root node of the AST.\n *\n * @throws an error if the node is not contained in a document.\n */\nexport function getDocument<T extends AstNode = AstNode>(node: AstNode): LangiumDocument<T> {\n    const rootNode = findRootNode(node);\n    const result = rootNode.$document;\n    if (!result) {\n        throw new Error('AST node has no document.');\n    }\n    return result as LangiumDocument<T>;\n}\n\n/**\n * Returns the root node of the given AST node by following the `$container` references.\n */\nexport function findRootNode(node: AstNode): AstNode {\n    while (node.$container) {\n        node = node.$container;\n    }\n    return node;\n}\n\nexport interface AstStreamOptions {\n    /**\n     * Optional target range that the nodes in the stream need to intersect\n     */\n    range?: Range\n}\n\n/**\n * Create a stream of all AST nodes that are directly contained in the given node. This includes\n * single-valued as well as multi-valued (array) properties.\n */\nexport function streamContents(node: AstNode, options?: AstStreamOptions): Stream<AstNode> {\n    if (!node) {\n        throw new Error('Node must be an AstNode.');\n    }\n    const range = options?.range;\n    type State = { keys: string[], keyIndex: number, arrayIndex: number };\n    return new StreamImpl<State, AstNode>(() => ({\n        keys: Object.keys(node),\n        keyIndex: 0,\n        arrayIndex: 0\n    }), state => {\n        while (state.keyIndex < state.keys.length) {\n            const property = state.keys[state.keyIndex];\n            if (!property.startsWith('$')) {\n                const value = (node as GenericAstNode)[property];\n                if (isAstNode(value)) {\n                    state.keyIndex++;\n                    if (isAstNodeInRange(value, range)) {\n                        return { done: false, value };\n                    }\n                } else if (Array.isArray(value)) {\n                    while (state.arrayIndex < value.length) {\n                        const index = state.arrayIndex++;\n                        const element = value[index];\n                        if (isAstNode(element) && isAstNodeInRange(element, range)) {\n                            return { done: false, value: element };\n                        }\n                    }\n                    state.arrayIndex = 0;\n                }\n            }\n            state.keyIndex++;\n        }\n        return DONE_RESULT;\n    });\n}\n\n/**\n * Create a stream of all AST nodes that are directly and indirectly contained in the given root node.\n * This does not include the root node itself.\n */\nexport function streamAllContents(root: AstNode, options?: AstStreamOptions): TreeStream<AstNode> {\n    if (!root) {\n        throw new Error('Root node must be an AstNode.');\n    }\n    return new TreeStreamImpl(root, node => streamContents(node, options));\n}\n\n/**\n * Create a stream of all AST nodes that are directly and indirectly contained in the given root node,\n * including the root node itself.\n */\nexport function streamAst(root: AstNode, options?: AstStreamOptions): TreeStream<AstNode> {\n    if (!root) {\n        throw new Error('Root node must be an AstNode.');\n    } else if (options?.range && !isAstNodeInRange(root, options.range)) {\n        // Return an empty stream if the root node isn't in range\n        return new TreeStreamImpl(root, () => []);\n    }\n    return new TreeStreamImpl(root, node => streamContents(node, options), { includeRoot: true });\n}\n\nfunction isAstNodeInRange(astNode: AstNode, range?: Range): boolean {\n    if (!range) {\n        return true;\n    }\n    const nodeRange = astNode.$cstNode?.range;\n    if (!nodeRange) {\n        return false;\n    }\n    return inRange(nodeRange, range);\n}\n\n/**\n * Create a stream of all cross-references that are held by the given AST node. This includes\n * single-valued as well as multi-valued (array) properties.\n */\nexport function streamReferences(node: AstNode): Stream<ReferenceInfo> {\n    type State = { keys: string[], keyIndex: number, arrayIndex: number };\n    return new StreamImpl<State, ReferenceInfo>(() => ({\n        keys: Object.keys(node),\n        keyIndex: 0,\n        arrayIndex: 0\n    }), state => {\n        while (state.keyIndex < state.keys.length) {\n            const property = state.keys[state.keyIndex];\n            if (!property.startsWith('$')) {\n                const value = (node as GenericAstNode)[property];\n                if (isReference(value)) {\n                    state.keyIndex++;\n                    return { done: false, value: { reference: value, container: node, property } };\n                } else if (Array.isArray(value)) {\n                    while (state.arrayIndex < value.length) {\n                        const index = state.arrayIndex++;\n                        const element = value[index];\n                        if (isReference(element)) {\n                            return { done: false, value: { reference: element, container: node, property, index } };\n                        }\n                    }\n                    state.arrayIndex = 0;\n                }\n            }\n            state.keyIndex++;\n        }\n        return DONE_RESULT;\n    });\n}\n\n/**\n * Returns a Stream of references to the target node from the AstNode tree\n *\n * @param targetNode AstNode we are looking for\n * @param lookup AstNode where we search for references. If not provided, the root node of the document is used as the default value\n */\nexport function findLocalReferences(targetNode: AstNode, lookup = getDocument(targetNode).parseResult.value): Stream<Reference> {\n    const refs: Reference[] = [];\n    streamAst(lookup).forEach(node => {\n        streamReferences(node).forEach(refInfo => {\n            if (refInfo.reference.ref === targetNode) {\n                refs.push(refInfo.reference);\n            }\n        });\n    });\n    return stream(refs);\n}\n\n/**\n * Assigns all mandatory AST properties to the specified node.\n *\n * @param reflection Reflection object used to gather mandatory properties for the node.\n * @param node Specified node is modified in place and properties are directly assigned.\n */\nexport function assignMandatoryProperties(reflection: AstReflection, node: AstNode): void {\n    const typeMetaData = reflection.getTypeMetaData(node.$type);\n    const genericNode = node as GenericAstNode;\n    for (const property of typeMetaData.properties) {\n        // Only set the value if the property is not already set and if it has a default value\n        if (property.defaultValue !== undefined && genericNode[property.name] === undefined) {\n            genericNode[property.name] = copyDefaultValue(property.defaultValue);\n        }\n    }\n}\n\nfunction copyDefaultValue(propertyType: PropertyType): PropertyType {\n    if (Array.isArray(propertyType)) {\n        return [...propertyType.map(copyDefaultValue)];\n    } else {\n        return propertyType;\n    }\n}\n\n/**\n * Creates a deep copy of the specified AST node.\n * The resulting copy will only contain semantically relevant information, such as the `$type` property and AST properties.\n *\n * References are copied without resolved cross reference. The specified function is used to rebuild them.\n */\nexport function copyAstNode<T extends AstNode = AstNode>(node: T, buildReference: (node: AstNode, property: string, refNode: CstNode | undefined, refText: string) => Reference<AstNode>): T {\n    const copy: GenericAstNode = { $type: node.$type };\n\n    for (const [name, value] of Object.entries(node)) {\n        if (!name.startsWith('$')) {\n            if (isAstNode(value)) {\n                copy[name] = copyAstNode(value, buildReference);\n            } else if (isReference(value)) {\n                copy[name] = buildReference(\n                    copy,\n                    name,\n                    value.$refNode,\n                    value.$refText\n                );\n            } else if (Array.isArray(value)) {\n                const copiedArray: unknown[] = [];\n                for (const element of value) {\n                    if (isAstNode(element)) {\n                        copiedArray.push(copyAstNode(element, buildReference));\n                    } else if (isReference(element)) {\n                        copiedArray.push(\n                            buildReference(\n                                copy,\n                                name,\n                                element.$refNode,\n                                element.$refText\n                            )\n                        );\n                    } else {\n                        copiedArray.push(element);\n                    }\n                }\n                copy[name] = copiedArray;\n            } else {\n                copy[name] = value;\n            }\n        }\n    }\n\n    linkContentToContainer(copy);\n    return copy as unknown as T;\n}\n", "/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { Set, Group, Character, IRegExpAST } from '@chevrotain/regexp-to-ast';\nimport { RegExpParser, BaseRegExpVisitor } from '@chevrotain/regexp-to-ast';\n\nexport const NEWLINE_REGEXP = /\\r?\\n/gm;\n\nconst regexpParser = new RegExpParser();\n\n/**\n * This class is in charge of heuristically identifying start/end tokens of terminals.\n *\n * The way this works is by doing the following:\n * 1. Traverse the regular expression in the \"start state\"\n * 2. Add any encountered sets/single characters to the \"start regexp\"\n * 3. Once we encounter any variable-length content (i.e. with quantifiers such as +/?/*), we enter the \"end state\"\n * 4. In the end state, any sets/single characters are added to an \"end stack\".\n * 5. If we re-encounter any variable-length content we reset the end stack\n * 6. We continue visiting the regex until the end, reseting the end stack and rebuilding it as necessary\n *\n * After traversing a regular expression the `startRegexp/endRegexp` properties allow access to the stored start/end of the terminal\n */\nclass TerminalRegExpVisitor extends BaseRegExpVisitor {\n\n    private isStarting = true;\n    startRegexp: string;\n    private endRegexpStack: string[] = [];\n    multiline = false;\n    regex: string;\n\n    get endRegex(): string {\n        return this.endRegexpStack.join('');\n    }\n\n    reset(regex: string): void {\n        this.multiline = false;\n        this.regex = regex;\n        this.startRegexp = '';\n        this.isStarting = true;\n        this.endRegexpStack = [];\n    }\n\n    override visitGroup(node: Group) {\n        if (node.quantifier) {\n            this.isStarting = false;\n            this.endRegexpStack = [];\n        }\n    }\n\n    override visitCharacter(node: Character): void {\n        const char = String.fromCharCode(node.value);\n        if (!this.multiline && char === '\\n') {\n            this.multiline = true;\n        }\n        if (node.quantifier) {\n            this.isStarting = false;\n            this.endRegexpStack = [];\n        } else {\n            const escapedChar = escapeRegExp(char);\n            this.endRegexpStack.push(escapedChar);\n            if (this.isStarting) {\n                this.startRegexp += escapedChar;\n            }\n        }\n    }\n\n    override visitSet(node: Set): void {\n        if (!this.multiline) {\n            const set = this.regex.substring(node.loc.begin, node.loc.end);\n            const regex = new RegExp(set);\n            this.multiline = Boolean('\\n'.match(regex));\n        }\n        if (node.quantifier) {\n            this.isStarting = false;\n            this.endRegexpStack = [];\n        } else {\n            const set = this.regex.substring(node.loc.begin, node.loc.end);\n            this.endRegexpStack.push(set);\n            if (this.isStarting) {\n                this.startRegexp += set;\n            }\n        }\n    }\n\n    override visitChildren(node: IRegExpAST): void {\n        if (node.type === 'Group') {\n            // Ignore children of groups with quantifier (+/*/?)\n            // These groups are unrelated to start/end tokens of terminals\n            const group = node as Group;\n            if (group.quantifier) {\n                return;\n            }\n        }\n        super.visitChildren(node);\n    }\n}\n\nconst visitor = new TerminalRegExpVisitor();\n\nexport function getTerminalParts(regexp: RegExp | string): Array<{ start: string, end: string }> {\n    try {\n        if (typeof regexp !== 'string') {\n            regexp = regexp.source;\n        }\n        regexp = `/${regexp}/`;\n        const pattern = regexpParser.pattern(regexp);\n        const parts: Array<{ start: string, end: string }> = [];\n        for (const alternative of pattern.value.value) {\n            visitor.reset(regexp);\n            visitor.visit(alternative);\n            parts.push({\n                start: visitor.startRegexp,\n                end: visitor.endRegex\n            });\n        }\n        return parts;\n    } catch {\n        return [];\n    }\n}\n\nexport function isMultilineComment(regexp: RegExp | string): boolean {\n    try {\n        if (typeof regexp === 'string') {\n            regexp = new RegExp(regexp);\n        }\n        regexp = regexp.toString();\n        visitor.reset(regexp);\n        // Parsing the pattern might fail (since it's user code)\n        visitor.visit(regexpParser.pattern(regexp));\n        return visitor.multiline;\n    } catch {\n        return false;\n    }\n}\n\nexport function isWhitespace(value: RegExp | string): boolean {\n    const regexp = typeof value === 'string' ? new RegExp(value) : value;\n    return regexp.test(' ');\n}\n\nexport function escapeRegExp(value: string): string {\n    return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nexport function getCaseInsensitivePattern(keyword: string): string {\n    return Array.prototype.map.call(keyword, letter =>\n        /\\w/.test(letter) ? `[${letter.toLowerCase()}${letter.toUpperCase()}]` : escapeRegExp(letter)\n    ).join('');\n}\n\n/**\n * Determines whether the given input has a partial match with the specified regex.\n * @param regex The regex to partially match against\n * @param input The input string\n * @returns Whether any match exists.\n */\nexport function partialMatches(regex: RegExp | string, input: string): boolean {\n    const partial = partialRegExp(regex);\n    const match = input.match(partial);\n    return !!match && match[0].length > 0;\n}\n\n/**\n * Builds a partial regex from the input regex. A partial regex is able to match incomplete input strings. E.g.\n * a partial regex constructed from `/ab/` is able to match the string `a` without needing a following `b` character. However it won't match `b` alone.\n * @param regex The input regex to be converted.\n * @returns A partial regex constructed from the input regex.\n */\nexport function partialRegExp(regex: RegExp | string): RegExp {\n    if (typeof regex === 'string') {\n        regex = new RegExp(regex);\n    }\n    const re = regex, source = regex.source;\n    let i = 0;\n\n    function process() {\n        let result = '',\n            tmp;\n\n        function appendRaw(nbChars: number) {\n            result += source.substr(i, nbChars);\n            i += nbChars;\n        }\n\n        function appendOptional(nbChars: number) {\n            result += '(?:' + source.substr(i, nbChars) + '|$)';\n            i += nbChars;\n        }\n\n        while (i < source.length) {\n            switch (source[i]) {\n                case '\\\\':\n                    switch (source[i + 1]) {\n                        case 'c':\n                            appendOptional(3);\n                            break;\n                        case 'x':\n                            appendOptional(4);\n                            break;\n                        case 'u':\n                            if (re.unicode) {\n                                if (source[i + 2] === '{') {\n                                    appendOptional(source.indexOf('}', i) - i + 1);\n                                } else {\n                                    appendOptional(6);\n                                }\n                            } else {\n                                appendOptional(2);\n                            }\n                            break;\n                        case 'p':\n                        case 'P':\n                            if (re.unicode) {\n                                appendOptional(source.indexOf('}', i) - i + 1);\n                            } else {\n                                appendOptional(2);\n                            }\n                            break;\n                        case 'k':\n                            appendOptional(source.indexOf('>', i) - i + 1);\n                            break;\n                        default:\n                            appendOptional(2);\n                            break;\n                    }\n                    break;\n\n                case '[':\n                    tmp = /\\[(?:\\\\.
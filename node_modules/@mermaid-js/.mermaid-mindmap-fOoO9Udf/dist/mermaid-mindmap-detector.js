(function(global2, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2["mermaid-mindmap-detector"] = {}));
})(this, function(exports2) {
  "use strict";
  const id$1 = "mindmap";
  const detector = (txt) => {
    return txt.match(/^\s*mindmap/) !== null;
  };
  const loadDiagram = async () => {
    const { diagram: diagram2 } = await Promise.resolve().then(() => diagramDefinition);
    return { id: id$1, diagram: diagram2 };
  };
  var parser = function() {
    var o = function(k, v, o2, l) {
      for (o2 = o2 || {}, l = k.length; l--; o2[k[l]] = v)
        ;
      return o2;
    }, $V0 = [1, 7], $V1 = [1, 9], $V2 = [1, 10], $V3 = [1, 14], $V4 = [1, 13], $V5 = [1, 19], $V6 = [1, 20], $V7 = [6, 9], $V8 = [1, 7, 12, 13, 16, 19], $V9 = [1, 28], $Va = [1, 29], $Vb = [1, 6, 7, 9, 12, 13, 16, 19];
    var parser2 = {
      trace: function trace() {
      },
      yy: {},
      symbols_: { "error": 2, "start": 3, "MINDMAP": 4, "document": 5, "NL": 6, "SPACELIST": 7, "stop": 8, "EOF": 9, "statement": 10, "node": 11, "ICON": 12, "CLASS": 13, "nodeWithId": 14, "nodeWithoutId": 15, "NODE_DSTART": 16, "NODE_DESCR": 17, "NODE_DEND": 18, "NODE_ID": 19, "$accept": 0, "$end": 1 },
      terminals_: { 2: "error", 4: "MINDMAP", 6: "NL", 7: "SPACELIST", 9: "EOF", 12: "ICON", 13: "CLASS", 16: "NODE_DSTART", 17: "NODE_DESCR", 18: "NODE_DEND", 19: "NODE_ID" },
      productions_: [0, [3, 2], [3, 3], [3, 3], [8, 1], [8, 1], [8, 2], [8, 2], [5, 3], [5, 2], [10, 2], [10, 2], [10, 2], [10, 1], [10, 1], [10, 1], [10, 1], [11, 1], [11, 1], [15, 3], [14, 1], [14, 4]],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
        var $0 = $$.length - 1;
        switch (yystate) {
          case 1:
          case 2:
          case 3:
            return yy;
          case 4:
            yy.getLogger().trace("Stop NL ");
            break;
          case 5:
            yy.getLogger().trace("Stop EOF ");
            break;
          case 6:
            yy.getLogger().trace("Stop NL2 ");
            break;
          case 7:
            yy.getLogger().trace("Stop EOF2 ");
            break;
          case 10:
            yy.getLogger().trace("Node: ", $$[$0].id);
            yy.addNode($$[$0 - 1].length, $$[$0].id, $$[$0].descr, $$[$0].type);
            break;
          case 11:
            yy.getLogger().trace("Icon: ", $$[$0]);
            yy.decorateNode({ icon: $$[$0] });
            break;
          case 12:
          case 15:
            yy.decorateNode({ class: $$[$0] });
            break;
          case 13:
            yy.getLogger().trace("Node: ", $$[$0].id);
            yy.addNode(0, $$[$0].id, $$[$0].descr, $$[$0].type);
            break;
          case 14:
            yy.decorateNode({ icon: $$[$0] });
            break;
          case 19:
            yy.getLogger().trace("node found ..", $$[$0 - 2]);
            this.$ = { id: $$[$0 - 1], descr: $$[$0 - 1], type: yy.getType($$[$0 - 2], $$[$0]) };
            break;
          case 20:
            this.$ = { id: $$[$0], descr: $$[$0], type: yy.nodeType.DEFAULT };
            break;
          case 21:
            yy.getLogger().trace("node found ..", $$[$0 - 3]);
            this.$ = { id: $$[$0 - 3], descr: $$[$0 - 1], type: yy.getType($$[$0 - 2], $$[$0]) };
            break;
        }
      },
      table: [{ 3: 1, 4: [1, 2], 7: [1, 3] }, { 1: [3] }, { 5: 4, 6: [1, 5], 7: $V0, 10: 6, 11: 8, 12: $V1, 13: $V2, 14: 11, 15: 12, 16: $V3, 19: $V4 }, { 4: [1, 15] }, { 1: [2, 1], 7: $V0, 10: 16, 11: 8, 12: $V1, 13: $V2, 14: 11, 15: 12, 16: $V3, 19: $V4 }, { 5: 17, 7: $V0, 10: 6, 11: 8, 12: $V1, 13: $V2, 14: 11, 15: 12, 16: $V3, 19: $V4 }, { 6: $V5, 8: 18, 9: $V6 }, o($V7, [2, 16], { 14: 11, 15: 12, 11: 21, 12: [1, 22], 13: [1, 23], 16: $V3, 19: $V4 }), o($V7, [2, 13]), o($V7, [2, 14]), o($V7, [2, 15]), o($V7, [2, 17]), o($V7, [2, 18]), o($V7, [2, 20], { 16: [1, 24] }), { 17: [1, 25] }, { 5: 26, 7: $V0, 10: 6, 11: 8, 12: $V1, 13: $V2, 14: 11, 15: 12, 16: $V3, 19: $V4 }, { 6: $V5, 8: 27, 9: $V6 }, { 1: [2, 2], 7: $V0, 10: 16, 11: 8, 12: $V1, 13: $V2, 14: 11, 15: 12, 16: $V3, 19: $V4 }, o($V8, [2, 9], { 6: $V9, 9: $Va }), o($Vb, [2, 4]), o($Vb, [2, 5]), o($V7, [2, 10]), o($V7, [2, 11]), o($V7, [2, 12]), { 17: [1, 30] }, { 18: [1, 31] }, { 1: [2, 3], 7: $V0, 10: 16, 11: 8, 12: $V1, 13: $V2, 14: 11, 15: 12, 16: $V3, 19: $V4 }, o($V8, [2, 8], { 6: $V9, 9: $Va }), o($Vb, [2, 6]), o($Vb, [2, 7]), { 18: [1, 32] }, o($V7, [2, 19]), o($V7, [2, 21])],
      defaultActions: {},
      parseError: function parseError2(str, hash) {
        if (hash.recoverable) {
          this.trace(str);
        } else {
          var error2 = new Error(str);
          error2.hash = hash;
          throw error2;
        }
      },
      parse: function parse2(input) {
        var self2 = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF = 1;
        var args = lstack.slice.call(arguments, 1);
        var lexer2 = Object.create(this.lexer);
        var sharedState = { yy: {} };
        for (var k in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
          }
        }
        lexer2.setInput(input, sharedState.yy);
        sharedState.yy.lexer = lexer2;
        sharedState.yy.parser = this;
        if (typeof lexer2.yylloc == "undefined") {
          lexer2.yylloc = {};
        }
        var yyloc = lexer2.yylloc;
        lstack.push(yyloc);
        var ranges = lexer2.options && lexer2.options.ranges;
        if (typeof sharedState.yy.parseError === "function") {
          this.parseError = sharedState.yy.parseError;
        } else {
          this.parseError = Object.getPrototypeOf(this).parseError;
        }
        function lex() {
          var token;
          token = tstack.pop() || lexer2.lex() || EOF;
          if (typeof token !== "number") {
            if (token instanceof Array) {
              tstack = token;
              token = tstack.pop();
            }
            token = self2.symbols_[token] || token;
          }
          return token;
        }
        var symbol, state, action, r, yyval = {}, p2, len, newState, expected;
        while (true) {
          state = stack[stack.length - 1];
          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == "undefined") {
              symbol = lex();
            }
            action = table[state] && table[state][symbol];
          }
          if (typeof action === "undefined" || !action.length || !action[0]) {
            var errStr = "";
            expected = [];
            for (p2 in table[state]) {
              if (this.terminals_[p2] && p2 > TERROR) {
                expected.push("'" + this.terminals_[p2] + "'");
              }
            }
            if (lexer2.showPosition) {
              errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
            } else {
              errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
            }
            this.parseError(errStr, {
              text: lexer2.match,
              token: this.terminals_[symbol] || symbol,
              line: lexer2.yylineno,
              loc: yyloc,
              expected
            });
          }
          if (action[0] instanceof Array && action.length > 1) {
            throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
          }
          switch (action[0]) {
            case 1:
              stack.push(symbol);
              vstack.push(lexer2.yytext);
              lstack.push(lexer2.yylloc);
              stack.push(action[1]);
              symbol = null;
              {
                yyleng = lexer2.yyleng;
                yytext = lexer2.yytext;
                yylineno = lexer2.yylineno;
                yyloc = lexer2.yylloc;
              }
              break;
            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };
              if (ranges) {
                yyval._$.range = [
                  lstack[lstack.length - (len || 1)].range[0],
                  lstack[lstack.length - 1].range[1]
                ];
              }
              r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
              ].concat(args));
              if (typeof r !== "undefined") {
                return r;
              }
              if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }
              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;
            case 3:
              return true;
          }
        }
        return true;
      }
    };
    var lexer = function() {
      var lexer2 = {
        EOF: 1,
        parseError: function parseError2(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str);
          }
        },
        setInput: function(input, yy) {
          this.yy = yy || this.yy || {};
          this._input = input;
          this._more = this._backtrack = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = "";
          this.conditionStack = ["INITIAL"];
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          };
          if (this.options.ranges) {
            this.yylloc.range = [0, 0];
          }
          this.offset = 0;
          return this;
        },
        input: function() {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }
          if (this.options.ranges) {
            this.yylloc.range[1]++;
          }
          this._input = this._input.slice(1);
          return ch;
        },
        unput: function(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len);
          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);
          if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
          }
          var r = this.yylloc.range;
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
          };
          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }
          this.yyleng = this.yytext.length;
          return this;
        },
        more: function() {
          this._more = true;
          return this;
        },
        reject: function() {
          if (this.options.backtrack_lexer) {
            this._backtrack = true;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
          return this;
        },
        less: function(n) {
          this.unput(this.match.slice(n));
        },
        pastInput: function() {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
        },
        upcomingInput: function() {
          var next2 = this.match;
          if (next2.length < 20) {
            next2 += this._input.substr(0, 20 - next2.length);
          }
          return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
        },
        showPosition: function() {
          var pre = this.pastInput();
          var c = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c + "^";
        },
        test_match: function(match2, indexed_rule) {
          var token, lines, backup;
          if (this.options.backtrack_lexer) {
            backup = {
              yylineno: this.yylineno,
              yylloc: {
                first_line: this.yylloc.first_line,
                last_line: this.last_line,
                first_column: this.yylloc.first_column,
                last_column: this.yylloc.last_column
              },
              yytext: this.yytext,
              match: this.match,
              matches: this.matches,
              matched: this.matched,
              yyleng: this.yyleng,
              offset: this.offset,
              _more: this._more,
              _input: this._input,
              yy: this.yy,
              conditionStack: this.conditionStack.slice(0),
              done: this.done
            };
            if (this.options.ranges) {
              backup.yylloc.range = this.yylloc.range.slice(0);
            }
          }
          lines = match2[0].match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno += lines.length;
          }
          this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match2[0].length
          };
          this.yytext += match2[0];
          this.match += match2[0];
          this.matches = match2;
          this.yyleng = this.yytext.length;
          if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
          }
          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match2[0].length);
          this.matched += match2[0];
          token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
          if (this.done && this._input) {
            this.done = false;
          }
          if (token) {
            return token;
          } else if (this._backtrack) {
            for (var k in backup) {
              this[k] = backup[k];
            }
            return false;
          }
          return false;
        },
        next: function() {
          if (this.done) {
            return this.EOF;
          }
          if (!this._input) {
            this.done = true;
          }
          var token, match2, tempMatch, index;
          if (!this._more) {
            this.yytext = "";
            this.match = "";
          }
          var rules = this._currentRules();
          for (var i2 = 0; i2 < rules.length; i2++) {
            tempMatch = this._input.match(this.rules[rules[i2]]);
            if (tempMatch && (!match2 || tempMatch[0].length > match2[0].length)) {
              match2 = tempMatch;
              index = i2;
              if (this.options.backtrack_lexer) {
                token = this.test_match(tempMatch, rules[i2]);
                if (token !== false) {
                  return token;
                } else if (this._backtrack) {
                  match2 = false;
                  continue;
                } else {
                  return false;
                }
              } else if (!this.options.flex) {
                break;
              }
            }
          }
          if (match2) {
            token = this.test_match(match2, rules[index]);
            if (token !== false) {
              return token;
            }
            return false;
          }
          if (this._input === "") {
            return this.EOF;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
        },
        lex: function lex() {
          var r = this.next();
          if (r) {
            return r;
          } else {
            return this.lex();
          }
        },
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },
        popState: function popState() {
          var n = this.conditionStack.length - 1;
          if (n > 0) {
            return this.conditionStack.pop();
          } else {
            return this.conditionStack[0];
          }
        },
        _currentRules: function _currentRules() {
          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          } else {
            return this.conditions["INITIAL"].rules;
          }
        },
        topState: function topState(n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0);
          if (n >= 0) {
            return this.conditionStack[n];
          } else {
            return "INITIAL";
          }
        },
        pushState: function pushState(condition) {
          this.begin(condition);
        },
        stateStackSize: function stateStackSize() {
          return this.conditionStack.length;
        },
        options: { "case-insensitive": true },
        performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          switch ($avoiding_name_collisions) {
            case 0:
              yy.getLogger().trace("Found comment", yy_.yytext);
              break;
            case 1:
              return 4;
            case 2:
              this.begin("CLASS");
              break;
            case 3:
              this.popState();
              return 13;
            case 4:
              this.popState();
              break;
            case 5:
              yy.getLogger().trace("Begin icon");
              this.begin("ICON");
              break;
            case 6:
              return 6;
            case 7:
              return 12;
            case 8:
              yy.getLogger().trace("end icon");
              this.popState();
              break;
            case 9:
              yy.getLogger().trace("Exploding node");
              this.begin("NODE");
              return 16;
            case 10:
              yy.getLogger().trace("Cloud");
              this.begin("NODE");
              return 16;
            case 11:
              yy.getLogger().trace("Explosion Bang");
              this.begin("NODE");
              return 16;
            case 12:
              yy.getLogger().trace("Cloud Bang");
              this.begin("NODE");
              return 16;
            case 13:
              this.begin("NODE");
              return 16;
            case 14:
              this.begin("NODE");
              return 16;
            case 15:
              this.begin("NODE");
              return 16;
            case 16:
              return 7;
            case 17:
              return 19;
            case 18:
              return 9;
            case 19:
              yy.getLogger().trace("Starting NSTR");
              this.begin("NSTR");
              break;
            case 20:
              yy.getLogger().trace("description:", yy_.yytext);
              return "NODE_DESCR";
            case 21:
              this.popState();
              break;
            case 22:
              this.popState();
              yy.getLogger().trace("node end ))");
              return "NODE_DEND";
            case 23:
              this.popState();
              yy.getLogger().trace("node end )");
              return "NODE_DEND";
            case 24:
              this.popState();
              yy.getLogger().trace("node end ...", yy_.yytext);
              return "NODE_DEND";
            case 25:
              this.popState();
              yy.getLogger().trace("node end (-");
              return "NODE_DEND";
            case 26:
              this.popState();
              yy.getLogger().trace("node end (-");
              return "NODE_DEND";
            case 27:
              this.popState();
              yy.getLogger().trace("node end ((");
              return "NODE_DEND";
            case 28:
              this.popState();
              yy.getLogger().trace("node end ((");
              return "NODE_DEND";
            case 29:
              yy.getLogger().trace("Long description:", yy_.yytext);
              return 17;
            case 30:
              yy.getLogger().trace("Long description:", yy_.yytext);
              return 17;
          }
        },
        rules: [/^(?:\s*%%.*)/i, /^(?:mindmap\b)/i, /^(?::::)/i, /^(?:.+)/i, /^(?:\n)/i, /^(?:::icon\()/i, /^(?:[\n]+)/i, /^(?:[^\)]+)/i, /^(?:\))/i, /^(?:-\))/i, /^(?:\(-)/i, /^(?:\)\))/i, /^(?:\))/i, /^(?:\(\()/i, /^(?:\()/i, /^(?:\[)/i, /^(?:[\s]+)/i, /^(?:[^\(\[\n\-\)]+)/i, /^(?:$)/i, /^(?:["])/i, /^(?:[^"]+)/i, /^(?:["])/i, /^(?:[\)]\))/i, /^(?:[\)])/i, /^(?:[\]])/i, /^(?:\(-)/i, /^(?:-\))/i, /^(?:\(\()/i, /^(?:\()/i, /^(?:[^\)\]\(]+)/i, /^(?:.+(?!\(\())/i],
        conditions: { "CLASS": { "rules": [3, 4], "inclusive": false }, "ICON": { "rules": [7, 8], "inclusive": false }, "NSTR": { "rules": [20, 21], "inclusive": false }, "NODE": { "rules": [19, 22, 23, 24, 25, 26, 27, 28, 29, 30], "inclusive": false }, "INITIAL": { "rules": [0, 1, 2, 5, 6, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18], "inclusive": true } }
      };
      return lexer2;
    }();
    parser2.lexer = lexer;
    function Parser() {
      this.yy = {};
    }
    Parser.prototype = parser2;
    parser2.Parser = Parser;
    return new Parser();
  }();
  parser.parser = parser;
  const mindmapParser = parser;
  const warning = (s) => {
    console.error("Log function was called before initialization", s);
  };
  const log = {
    trace: warning,
    debug: warning,
    info: warning,
    warn: warning,
    error: warning,
    fatal: warning
  };
  let getConfig;
  let sanitizeText;
  let setupGraphViewbox;
  const injectUtils = (_log, _setLogLevel, _getConfig, _sanitizeText, _setupGraphViewbox) => {
    _log.info("Mermaid utils injected");
    log.trace = _log.trace;
    log.debug = _log.debug;
    log.info = _log.info;
    log.warn = _log.warn;
    log.error = _log.error;
    log.fatal = _log.fatal;
    getConfig = _getConfig;
    sanitizeText = _sanitizeText;
    setupGraphViewbox = _setupGraphViewbox;
  };
  let nodes = [];
  let cnt = 0;
  let elements = {};
  const clear = () => {
    nodes = [];
    cnt = 0;
    elements = {};
  };
  const getParent = function(level) {
    for (let i2 = nodes.length - 1; i2 >= 0; i2--) {
      if (nodes[i2].level < level) {
        return nodes[i2];
      }
    }
    return null;
  };
  const getMindmap = () => {
    return nodes.length > 0 ? nodes[0] : null;
  };
  const addNode = (level, id2, descr, type) => {
    log.info("addNode", level, id2, descr, type);
    const conf = getConfig();
    const node = {
      id: cnt++,
      nodeId: sanitizeText(id2),
      level,
      descr: sanitizeText(descr),
      type,
      children: [],
      width: getConfig().mindmap.maxNodeWidth
    };
    switch (node.type) {
      case nodeType.ROUNDED_RECT:
        node.padding = 2 * conf.mindmap.padding;
        break;
      case nodeType.RECT:
        node.padding = 2 * conf.mindmap.padding;
        break;
      default:
        node.padding = conf.mindmap.padding;
    }
    const parent = getParent(level);
    if (parent) {
      parent.children.push(node);
      nodes.push(node);
    } else {
      if (nodes.length === 0) {
        nodes.push(node);
      } else {
        let error2 = new Error(
          'There can be only one root. No parent could be found for ("' + node.descr + '")'
        );
        error2.hash = {
          text: "branch " + name,
          token: "branch " + name,
          line: "1",
          loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
          expected: ['"checkout ' + name + '"']
        };
        throw error2;
      }
    }
  };
  const nodeType = {
    DEFAULT: 0,
    NO_BORDER: 0,
    ROUNDED_RECT: 1,
    RECT: 2,
    CIRCLE: 3,
    CLOUD: 4,
    BANG: 5
  };
  const getType = (startStr, endStr) => {
    log.debug("In get type", startStr, endStr);
    switch (startStr) {
      case "[":
        return nodeType.RECT;
      case "(":
        return endStr === ")" ? nodeType.ROUNDED_RECT : nodeType.CLOUD;
      case "((":
        return nodeType.CIRCLE;
      case ")":
        return nodeType.CLOUD;
      case "))":
        return nodeType.BANG;
      default:
        return nodeType.DEFAULT;
    }
  };
  const setElementForId = (id2, element2) => {
    elements[id2] = element2;
  };
  const decorateNode = (decoration) => {
    const node = nodes[nodes.length - 1];
    if (decoration && decoration.icon) {
      node.icon = sanitizeText(decoration.icon);
    }
    if (decoration && decoration.class) {
      node.class = sanitizeText(decoration.class);
    }
  };
  const type2Str = (type) => {
    switch (type) {
      case nodeType.DEFAULT:
        return "no-border";
      case nodeType.RECT:
        return "rect";
      case nodeType.ROUNDED_RECT:
        return "rounded-rect";
      case nodeType.CIRCLE:
        return "circle";
      case nodeType.CLOUD:
        return "cloud";
      case nodeType.BANG:
        return "bang";
      default:
        return "no-border";
    }
  };
  let parseError;
  const setErrorHandler = (handler) => {
    parseError = handler;
  };
  const getLogger = () => log;
  const getNodeById = (id2) => nodes[id2];
  const getElementById = (id2) => elements[id2];
  const mindmapDb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    clear,
    getMindmap,
    addNode,
    nodeType,
    getType,
    setElementForId,
    decorateNode,
    type2Str,
    get parseError() {
      return parseError;
    },
    setErrorHandler,
    getLogger,
    getNodeById,
    getElementById
  }, Symbol.toStringTag, { value: "Module" }));
  var noop$2 = { value: () => {
  } };
  function dispatch() {
    for (var i2 = 0, n = arguments.length, _2 = {}, t; i2 < n; ++i2) {
      if (!(t = arguments[i2] + "") || t in _2 || /[\s.]/.test(t))
        throw new Error("illegal type: " + t);
      _2[t] = [];
    }
    return new Dispatch(_2);
  }
  function Dispatch(_2) {
    this._ = _2;
  }
  function parseTypenames$1(typenames, types) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name2 = "", i2 = t.indexOf(".");
      if (i2 >= 0)
        name2 = t.slice(i2 + 1), t = t.slice(0, i2);
      if (t && !types.hasOwnProperty(t))
        throw new Error("unknown type: " + t);
      return { type: t, name: name2 };
    });
  }
  Dispatch.prototype = dispatch.prototype = {
    constructor: Dispatch,
    on: function(typename, callback) {
      var _2 = this._, T = parseTypenames$1(typename + "", _2), t, i2 = -1, n = T.length;
      if (arguments.length < 2) {
        while (++i2 < n)
          if ((t = (typename = T[i2]).type) && (t = get$3(_2[t], typename.name)))
            return t;
        return;
      }
      if (callback != null && typeof callback !== "function")
        throw new Error("invalid callback: " + callback);
      while (++i2 < n) {
        if (t = (typename = T[i2]).type)
          _2[t] = set$3(_2[t], typename.name, callback);
        else if (callback == null)
          for (t in _2)
            _2[t] = set$3(_2[t], typename.name, null);
      }
      return this;
    },
    copy: function() {
      var copy2 = {}, _2 = this._;
      for (var t in _2)
        copy2[t] = _2[t].slice();
      return new Dispatch(copy2);
    },
    call: function(type, that) {
      if ((n = arguments.length - 2) > 0)
        for (var args = new Array(n), i2 = 0, n, t; i2 < n; ++i2)
          args[i2] = arguments[i2 + 2];
      if (!this._.hasOwnProperty(type))
        throw new Error("unknown type: " + type);
      for (t = this._[type], i2 = 0, n = t.length; i2 < n; ++i2)
        t[i2].value.apply(that, args);
    },
    apply: function(type, that, args) {
      if (!this._.hasOwnProperty(type))
        throw new Error("unknown type: " + type);
      for (var t = this._[type], i2 = 0, n = t.length; i2 < n; ++i2)
        t[i2].value.apply(that, args);
    }
  };
  function get$3(type, name2) {
    for (var i2 = 0, n = type.length, c; i2 < n; ++i2) {
      if ((c = type[i2]).name === name2) {
        return c.value;
      }
    }
  }
  function set$3(type, name2, callback) {
    for (var i2 = 0, n = type.length; i2 < n; ++i2) {
      if (type[i2].name === name2) {
        type[i2] = noop$2, type = type.slice(0, i2).concat(type.slice(i2 + 1));
        break;
      }
    }
    if (callback != null)
      type.push({ name: name2, value: callback });
    return type;
  }
  var xhtml = "http://www.w3.org/1999/xhtml";
  const namespaces = {
    svg: "http://www.w3.org/2000/svg",
    xhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  function namespace(name2) {
    var prefix = name2 += "", i2 = prefix.indexOf(":");
    if (i2 >= 0 && (prefix = name2.slice(0, i2)) !== "xmlns")
      name2 = name2.slice(i2 + 1);
    return namespaces.hasOwnProperty(prefix) ? { space: namespaces[prefix], local: name2 } : name2;
  }
  function creatorInherit(name2) {
    return function() {
      var document2 = this.ownerDocument, uri = this.namespaceURI;
      return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name2) : document2.createElementNS(uri, name2);
    };
  }
  function creatorFixed(fullname) {
    return function() {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }
  function creator(name2) {
    var fullname = namespace(name2);
    return (fullname.local ? creatorFixed : creatorInherit)(fullname);
  }
  function none() {
  }
  function selector(selector2) {
    return selector2 == null ? none : function() {
      return this.querySelector(selector2);
    };
  }
  function selection_select(select2) {
    if (typeof select2 !== "function")
      select2 = selector(select2);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i2 = 0; i2 < n; ++i2) {
        if ((node = group[i2]) && (subnode = select2.call(node, node.__data__, i2, group))) {
          if ("__data__" in node)
            subnode.__data__ = node.__data__;
          subgroup[i2] = subnode;
        }
      }
    }
    return new Selection$1(subgroups, this._parents);
  }
  function array$1(x) {
    return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
  }
  function empty() {
    return [];
  }
  function selectorAll(selector2) {
    return selector2 == null ? empty : function() {
      return this.querySelectorAll(selector2);
    };
  }
  function arrayAll(select2) {
    return function() {
      return array$1(select2.apply(this, arguments));
    };
  }
  function selection_selectAll(select2) {
    if (typeof select2 === "function")
      select2 = arrayAll(select2);
    else
      select2 = selectorAll(select2);
    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i2 = 0; i2 < n; ++i2) {
        if (node = group[i2]) {
          subgroups.push(select2.call(node, node.__data__, i2, group));
          parents.push(node);
        }
      }
    }
    return new Selection$1(subgroups, parents);
  }
  function matcher(selector2) {
    return function() {
      return this.matches(selector2);
    };
  }
  function childMatcher(selector2) {
    return function(node) {
      return node.matches(selector2);
    };
  }
  var find = Array.prototype.find;
  function childFind(match2) {
    return function() {
      return find.call(this.children, match2);
    };
  }
  function childFirst() {
    return this.firstElementChild;
  }
  function selection_selectChild(match2) {
    return this.select(match2 == null ? childFirst : childFind(typeof match2 === "function" ? match2 : childMatcher(match2)));
  }
  var filter$1 = Array.prototype.filter;
  function children() {
    return Array.from(this.children);
  }
  function childrenFilter(match2) {
    return function() {
      return filter$1.call(this.children, match2);
    };
  }
  function selection_selectChildren(match2) {
    return this.selectAll(match2 == null ? children : childrenFilter(typeof match2 === "function" ? match2 : childMatcher(match2)));
  }
  function selection_filter(match2) {
    if (typeof match2 !== "function")
      match2 = matcher(match2);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i2 = 0; i2 < n; ++i2) {
        if ((node = group[i2]) && match2.call(node, node.__data__, i2, group)) {
          subgroup.push(node);
        }
      }
    }
    return new Selection$1(subgroups, this._parents);
  }
  function sparse(update2) {
    return new Array(update2.length);
  }
  function selection_enter() {
    return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
  }
  function EnterNode(parent, datum2) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum2;
  }
  EnterNode.prototype = {
    constructor: EnterNode,
    appendChild: function(child) {
      return this._parent.insertBefore(child, this._next);
    },
    insertBefore: function(child, next2) {
      return this._parent.insertBefore(child, next2);
    },
    querySelector: function(selector2) {
      return this._parent.querySelector(selector2);
    },
    querySelectorAll: function(selector2) {
      return this._parent.querySelectorAll(selector2);
    }
  };
  function constant$1(x) {
    return function() {
      return x;
    };
  }
  function bindIndex(parent, group, enter, update2, exit, data2) {
    var i2 = 0, node, groupLength = group.length, dataLength = data2.length;
    for (; i2 < dataLength; ++i2) {
      if (node = group[i2]) {
        node.__data__ = data2[i2];
        update2[i2] = node;
      } else {
        enter[i2] = new EnterNode(parent, data2[i2]);
      }
    }
    for (; i2 < groupLength; ++i2) {
      if (node = group[i2]) {
        exit[i2] = node;
      }
    }
  }
  function bindKey(parent, group, enter, update2, exit, data2, key) {
    var i2, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data2.length, keyValues = new Array(groupLength), keyValue;
    for (i2 = 0; i2 < groupLength; ++i2) {
      if (node = group[i2]) {
        keyValues[i2] = keyValue = key.call(node, node.__data__, i2, group) + "";
        if (nodeByKeyValue.has(keyValue)) {
          exit[i2] = node;
        } else {
          nodeByKeyValue.set(keyValue, node);
        }
      }
    }
    for (i2 = 0; i2 < dataLength; ++i2) {
      keyValue = key.call(parent, data2[i2], i2, data2) + "";
      if (node = nodeByKeyValue.get(keyValue)) {
        update2[i2] = node;
        node.__data__ = data2[i2];
        nodeByKeyValue.delete(keyValue);
      } else {
        enter[i2] = new EnterNode(parent, data2[i2]);
      }
    }
    for (i2 = 0; i2 < groupLength; ++i2) {
      if ((node = group[i2]) && nodeByKeyValue.get(keyValues[i2]) === node) {
        exit[i2] = node;
      }
    }
  }
  function datum(node) {
    return node.__data__;
  }
  function selection_data(value, key) {
    if (!arguments.length)
      return Array.from(this, datum);
    var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
    if (typeof value !== "function")
      value = constant$1(value);
    for (var m = groups.length, update2 = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
      var parent = parents[j], group = groups[j], groupLength = group.length, data2 = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data2.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update2[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
      bind(parent, group, enterGroup, updateGroup, exitGroup, data2, key);
      for (var i0 = 0, i1 = 0, previous, next2; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i1)
            i1 = i0 + 1;
          while (!(next2 = updateGroup[i1]) && ++i1 < dataLength)
            ;
          previous._next = next2 || null;
        }
      }
    }
    update2 = new Selection$1(update2, parents);
    update2._enter = enter;
    update2._exit = exit;
    return update2;
  }
  function arraylike(data2) {
    return typeof data2 === "object" && "length" in data2 ? data2 : Array.from(data2);
  }
  function selection_exit() {
    return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
  }
  function selection_join(onenter, onupdate, onexit) {
    var enter = this.enter(), update2 = this, exit = this.exit();
    if (typeof onenter === "function") {
      enter = onenter(enter);
      if (enter)
        enter = enter.selection();
    } else {
      enter = enter.append(onenter + "");
    }
    if (onupdate != null) {
      update2 = onupdate(update2);
      if (update2)
        update2 = update2.selection();
    }
    if (onexit == null)
      exit.remove();
    else
      onexit(exit);
    return enter && update2 ? enter.merge(update2).order() : update2;
  }
  function selection_merge(context) {
    var selection2 = context.selection ? context.selection() : context;
    for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i2 = 0; i2 < n; ++i2) {
        if (node = group0[i2] || group1[i2]) {
          merge[i2] = node;
        }
      }
    }
    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }
    return new Selection$1(merges, this._parents);
  }
  function selection_order() {
    for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
      for (var group = groups[j], i2 = group.length - 1, next2 = group[i2], node; --i2 >= 0; ) {
        if (node = group[i2]) {
          if (next2 && node.compareDocumentPosition(next2) ^ 4)
            next2.parentNode.insertBefore(node, next2);
          next2 = node;
        }
      }
    }
    return this;
  }
  function selection_sort(compare) {
    if (!compare)
      compare = ascending$1;
    function compareNode(a, b) {
      return a && b ? compare(a.__data__, b.__data__) : !a - !b;
    }
    for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i2 = 0; i2 < n; ++i2) {
        if (node = group[i2]) {
          sortgroup[i2] = node;
        }
      }
      sortgroup.sort(compareNode);
    }
    return new Selection$1(sortgroups, this._parents).order();
  }
  function ascending$1(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }
  function selection_call() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  }
  function selection_nodes() {
    return Array.from(this);
  }
  function selection_node() {
    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i2 = 0, n = group.length; i2 < n; ++i2) {
        var node = group[i2];
        if (node)
          return node;
      }
    }
    return null;
  }
  function selection_size() {
    let size = 0;
    for (const node of this)
      ++size;
    return size;
  }
  function selection_empty() {
    return !this.node();
  }
  function selection_each(callback) {
    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i2 = 0, n = group.length, node; i2 < n; ++i2) {
        if (node = group[i2])
          callback.call(node, node.__data__, i2, group);
      }
    }
    return this;
  }
  function attrRemove$1(name2) {
    return function() {
      this.removeAttribute(name2);
    };
  }
  function attrRemoveNS$1(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }
  function attrConstant$1(name2, value) {
    return function() {
      this.setAttribute(name2, value);
    };
  }
  function attrConstantNS$1(fullname, value) {
    return function() {
      this.setAttributeNS(fullname.space, fullname.local, value);
    };
  }
  function attrFunction$1(name2, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        this.removeAttribute(name2);
      else
        this.setAttribute(name2, v);
    };
  }
  function attrFunctionNS$1(fullname, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        this.removeAttributeNS(fullname.space, fullname.local);
      else
        this.setAttributeNS(fullname.space, fullname.local, v);
    };
  }
  function selection_attr(name2, value) {
    var fullname = namespace(name2);
    if (arguments.length < 2) {
      var node = this.node();
      return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
    }
    return this.each((value == null ? fullname.local ? attrRemoveNS$1 : attrRemove$1 : typeof value === "function" ? fullname.local ? attrFunctionNS$1 : attrFunction$1 : fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, value));
  }
  function defaultView(node) {
    return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
  }
  function styleRemove$1(name2) {
    return function() {
      this.style.removeProperty(name2);
    };
  }
  function styleConstant$1(name2, value, priority) {
    return function() {
      this.style.setProperty(name2, value, priority);
    };
  }
  function styleFunction$1(name2, value, priority) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        this.style.removeProperty(name2);
      else
        this.style.setProperty(name2, v, priority);
    };
  }
  function selection_style(name2, value, priority) {
    return arguments.length > 1 ? this.each((value == null ? styleRemove$1 : typeof value === "function" ? styleFunction$1 : styleConstant$1)(name2, value, priority == null ? "" : priority)) : styleValue(this.node(), name2);
  }
  function styleValue(node, name2) {
    return node.style.getPropertyValue(name2) || defaultView(node).getComputedStyle(node, null).getPropertyValue(name2);
  }
  function propertyRemove(name2) {
    return function() {
      delete this[name2];
    };
  }
  function propertyConstant(name2, value) {
    return function() {
      this[name2] = value;
    };
  }
  function propertyFunction(name2, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        delete this[name2];
      else
        this[name2] = v;
    };
  }
  function selection_property(name2, value) {
    return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name2, value)) : this.node()[name2];
  }
  function classArray(string2) {
    return string2.trim().split(/^|\s+/);
  }
  function classList(node) {
    return node.classList || new ClassList(node);
  }
  function ClassList(node) {
    this._node = node;
    this._names = classArray(node.getAttribute("class") || "");
  }
  ClassList.prototype = {
    add: function(name2) {
      var i2 = this._names.indexOf(name2);
      if (i2 < 0) {
        this._names.push(name2);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    remove: function(name2) {
      var i2 = this._names.indexOf(name2);
      if (i2 >= 0) {
        this._names.splice(i2, 1);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    contains: function(name2) {
      return this._names.indexOf(name2) >= 0;
    }
  };
  function classedAdd(node, names) {
    var list = classList(node), i2 = -1, n = names.length;
    while (++i2 < n)
      list.add(names[i2]);
  }
  function classedRemove(node, names) {
    var list = classList(node), i2 = -1, n = names.length;
    while (++i2 < n)
      list.remove(names[i2]);
  }
  function classedTrue(names) {
    return function() {
      classedAdd(this, names);
    };
  }
  function classedFalse(names) {
    return function() {
      classedRemove(this, names);
    };
  }
  function classedFunction(names, value) {
    return function() {
      (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
    };
  }
  function selection_classed(name2, value) {
    var names = classArray(name2 + "");
    if (arguments.length < 2) {
      var list = classList(this.node()), i2 = -1, n = names.length;
      while (++i2 < n)
        if (!list.contains(names[i2]))
          return false;
      return true;
    }
    return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
  }
  function textRemove() {
    this.textContent = "";
  }
  function textConstant$1(value) {
    return function() {
      this.textContent = value;
    };
  }
  function textFunction$1(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    };
  }
  function selection_text(value) {
    return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction$1 : textConstant$1)(value)) : this.node().textContent;
  }
  function htmlRemove() {
    this.innerHTML = "";
  }
  function htmlConstant(value) {
    return function() {
      this.innerHTML = value;
    };
  }
  function htmlFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    };
  }
  function selection_html(value) {
    return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
  }
  function raise() {
    if (this.nextSibling)
      this.parentNode.appendChild(this);
  }
  function selection_raise() {
    return this.each(raise);
  }
  function lower() {
    if (this.previousSibling)
      this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }
  function selection_lower() {
    return this.each(lower);
  }
  function selection_append(name2) {
    var create2 = typeof name2 === "function" ? name2 : creator(name2);
    return this.select(function() {
      return this.appendChild(create2.apply(this, arguments));
    });
  }
  function constantNull() {
    return null;
  }
  function selection_insert(name2, before) {
    var create2 = typeof name2 === "function" ? name2 : creator(name2), select2 = before == null ? constantNull : typeof before === "function" ? before : selector(before);
    return this.select(function() {
      return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
    });
  }
  function remove() {
    var parent = this.parentNode;
    if (parent)
      parent.removeChild(this);
  }
  function selection_remove() {
    return this.each(remove);
  }
  function selection_cloneShallow() {
    var clone2 = this.cloneNode(false), parent = this.parentNode;
    return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
  }
  function selection_cloneDeep() {
    var clone2 = this.cloneNode(true), parent = this.parentNode;
    return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
  }
  function selection_clone(deep) {
    return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
  }
  function selection_datum(value) {
    return arguments.length ? this.property("__data__", value) : this.node().__data__;
  }
  function contextListener(listener) {
    return function(event2) {
      listener.call(this, event2, this.__data__);
    };
  }
  function parseTypenames(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name2 = "", i2 = t.indexOf(".");
      if (i2 >= 0)
        name2 = t.slice(i2 + 1), t = t.slice(0, i2);
      return { type: t, name: name2 };
    });
  }
  function onRemove(typename) {
    return function() {
      var on = this.__on;
      if (!on)
        return;
      for (var j = 0, i2 = -1, m = on.length, o; j < m; ++j) {
        if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
        } else {
          on[++i2] = o;
        }
      }
      if (++i2)
        on.length = i2;
      else
        delete this.__on;
    };
  }
  function onAdd(typename, value, options) {
    return function() {
      var on = this.__on, o, listener = contextListener(value);
      if (on)
        for (var j = 0, m = on.length; j < m; ++j) {
          if ((o = on[j]).type === typename.type && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
            this.addEventListener(o.type, o.listener = listener, o.options = options);
            o.value = value;
            return;
          }
        }
      this.addEventListener(typename.type, listener, options);
      o = { type: typename.type, name: typename.name, value, listener, options };
      if (!on)
        this.__on = [o];
      else
        on.push(o);
    };
  }
  function selection_on(typename, value, options) {
    var typenames = parseTypenames(typename + ""), i2, n = typenames.length, t;
    if (arguments.length < 2) {
      var on = this.node().__on;
      if (on)
        for (var j = 0, m = on.length, o; j < m; ++j) {
          for (i2 = 0, o = on[j]; i2 < n; ++i2) {
            if ((t = typenames[i2]).type === o.type && t.name === o.name) {
              return o.value;
            }
          }
        }
      return;
    }
    on = value ? onAdd : onRemove;
    for (i2 = 0; i2 < n; ++i2)
      this.each(on(typenames[i2], value, options));
    return this;
  }
  function dispatchEvent(node, type, params) {
    var window2 = defaultView(node), event2 = window2.CustomEvent;
    if (typeof event2 === "function") {
      event2 = new event2(type, params);
    } else {
      event2 = window2.document.createEvent("Event");
      if (params)
        event2.initEvent(type, params.bubbles, params.cancelable), event2.detail = params.detail;
      else
        event2.initEvent(type, false, false);
    }
    node.dispatchEvent(event2);
  }
  function dispatchConstant(type, params) {
    return function() {
      return dispatchEvent(this, type, params);
    };
  }
  function dispatchFunction(type, params) {
    return function() {
      return dispatchEvent(this, type, params.apply(this, arguments));
    };
  }
  function selection_dispatch(type, params) {
    return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
  }
  function* selection_iterator() {
    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i2 = 0, n = group.length, node; i2 < n; ++i2) {
        if (node = group[i2])
          yield node;
      }
    }
  }
  var root$5 = [null];
  function Selection$1(groups, parents) {
    this._groups = groups;
    this._parents = parents;
  }
  function selection() {
    return new Selection$1([[document.documentElement]], root$5);
  }
  function selection_selection() {
    return this;
  }
  Selection$1.prototype = selection.prototype = {
    constructor: Selection$1,
    select: selection_select,
    selectAll: selection_selectAll,
    selectChild: selection_selectChild,
    selectChildren: selection_selectChildren,
    filter: selection_filter,
    data: selection_data,
    enter: selection_enter,
    exit: selection_exit,
    join: selection_join,
    merge: selection_merge,
    selection: selection_selection,
    order: selection_order,
    sort: selection_sort,
    call: selection_call,
    nodes: selection_nodes,
    node: selection_node,
    size: selection_size,
    empty: selection_empty,
    each: selection_each,
    attr: selection_attr,
    style: selection_style,
    property: selection_property,
    classed: selection_classed,
    text: selection_text,
    html: selection_html,
    raise: selection_raise,
    lower: selection_lower,
    append: selection_append,
    insert: selection_insert,
    remove: selection_remove,
    clone: selection_clone,
    datum: selection_datum,
    on: selection_on,
    dispatch: selection_dispatch,
    [Symbol.iterator]: selection_iterator
  };
  function select(selector2) {
    return typeof selector2 === "string" ? new Selection$1([[document.querySelector(selector2)]], [document.documentElement]) : new Selection$1([[selector2]], root$5);
  }
  function define$4(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }
  function extend$1(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition)
      prototype[key] = definition[key];
    return prototype;
  }
  function Color$2() {
  }
  var darker = 0.7;
  var brighter = 1 / darker;
  var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
  var named = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  define$4(Color$2, color, {
    copy(channels2) {
      return Object.assign(new this.constructor(), this, channels2);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: color_formatHex,
    formatHex: color_formatHex,
    formatHex8: color_formatHex8,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });
  function color_formatHex() {
    return this.rgb().formatHex();
  }
  function color_formatHex8() {
    return this.rgb().formatHex8();
  }
  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }
  function color_formatRgb() {
    return this.rgb().formatRgb();
  }
  function color(format) {
    var m, l;
    format = (format + "").trim().toLowerCase();
    return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba$1(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba$1(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format)) ? rgba$1(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format)) ? rgba$1(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format)) ? hsla$1(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format)) ? hsla$1(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
  }
  function rgbn(n) {
    return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
  }
  function rgba$1(r, g, b, a) {
    if (a <= 0)
      r = g = b = NaN;
    return new Rgb(r, g, b, a);
  }
  function rgbConvert(o) {
    if (!(o instanceof Color$2))
      o = color(o);
    if (!o)
      return new Rgb();
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }
  function rgb(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
  }
  function Rgb(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }
  define$4(Rgb, rgb, extend$1(Color$2, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex,
    formatHex: rgb_formatHex,
    formatHex8: rgb_formatHex8,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));
  function rgb_formatHex() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
  }
  function rgb_formatHex8() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function rgb_formatRgb() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
  }
  function clampa(opacity) {
    return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
  }
  function clampi(value) {
    return Math.max(0, Math.min(255, Math.round(value) || 0));
  }
  function hex(value) {
    value = clampi(value);
    return (value < 16 ? "0" : "") + value.toString(16);
  }
  function hsla$1(h, s, l, a) {
    if (a <= 0)
      h = s = l = NaN;
    else if (l <= 0 || l >= 1)
      h = s = NaN;
    else if (s <= 0)
      h = NaN;
    return new Hsl(h, s, l, a);
  }
  function hslConvert(o) {
    if (o instanceof Hsl)
      return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color$2))
      o = color(o);
    if (!o)
      return new Hsl();
    if (o instanceof Hsl)
      return o;
    o = o.rgb();
    var r = o.r / 255, g = o.g / 255, b = o.b / 255, min2 = Math.min(r, g, b), max2 = Math.max(r, g, b), h = NaN, s = max2 - min2, l = (max2 + min2) / 2;
    if (s) {
      if (r === max2)
        h = (g - b) / s + (g < b) * 6;
      else if (g === max2)
        h = (b - r) / s + 2;
      else
        h = (r - g) / s + 4;
      s /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
      h *= 60;
    } else {
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl(h, s, l, o.opacity);
  }
  function hsl(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
  }
  function Hsl(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }
  define$4(Hsl, hsl, extend$1(Color$2, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb() {
      var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
      return new Rgb(
        hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
        hsl2rgb(h, m1, m2),
        hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
        this.opacity
      );
    },
    clamp() {
      return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl() {
      const a = clampa(this.opacity);
      return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
    }
  }));
  function clamph(value) {
    value = (value || 0) % 360;
    return value < 0 ? value + 360 : value;
  }
  function clampt(value) {
    return Math.max(0, Math.min(1, value || 0));
  }
  function hsl2rgb(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
  }
  const constant = (x) => () => x;
  function linear(a, d) {
    return function(t) {
      return a + t * d;
    };
  }
  function exponential(a, b, y) {
    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
      return Math.pow(a + t * b, y);
    };
  }
  function gamma(y) {
    return (y = +y) === 1 ? nogamma : function(a, b) {
      return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
    };
  }
  function nogamma(a, b) {
    var d = b - a;
    return d ? linear(a, d) : constant(isNaN(a) ? b : a);
  }
  const interpolateRgb = function rgbGamma(y) {
    var color2 = gamma(y);
    function rgb$1(start2, end) {
      var r = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
      return function(t) {
        start2.r = r(t);
        start2.g = g(t);
        start2.b = b(t);
        start2.opacity = opacity(t);
        return start2 + "";
      };
    }
    rgb$1.gamma = rgbGamma;
    return rgb$1;
  }(1);
  function interpolateNumber(a, b) {
    return a = +a, b = +b, function(t) {
      return a * (1 - t) + b * t;
    };
  }
  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
  function zero(b) {
    return function() {
      return b;
    };
  }
  function one(b) {
    return function(t) {
      return b(t) + "";
    };
  }
  function interpolateString(a, b) {
    var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i2 = -1, s = [], q = [];
    a = a + "", b = b + "";
    while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s[i2])
          s[i2] += bs;
        else
          s[++i2] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s[i2])
          s[i2] += bm;
        else
          s[++i2] = bm;
      } else {
        s[++i2] = null;
        q.push({ i: i2, x: interpolateNumber(am, bm) });
      }
      bi = reB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i2])
        s[i2] += bs;
      else
        s[++i2] = bs;
    }
    return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
      for (var i3 = 0, o; i3 < b; ++i3)
        s[(o = q[i3]).i] = o.x(t);
      return s.join("");
    });
  }
  var degrees = 180 / Math.PI;
  var identity$1 = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1
  };
  function decompose(a, b, c, d, e, f) {
    var scaleX, scaleY, skewX;
    if (scaleX = Math.sqrt(a * a + b * b))
      a /= scaleX, b /= scaleX;
    if (skewX = a * c + b * d)
      c -= a * skewX, d -= b * skewX;
    if (scaleY = Math.sqrt(c * c + d * d))
      c /= scaleY, d /= scaleY, skewX /= scaleY;
    if (a * d < b * c)
      a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
    return {
      translateX: e,
      translateY: f,
      rotate: Math.atan2(b, a) * degrees,
      skewX: Math.atan(skewX) * degrees,
      scaleX,
      scaleY
    };
  }
  var svgNode;
  function parseCss(value) {
    const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
    return m.isIdentity ? identity$1 : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
  }
  function parseSvg(value) {
    if (value == null)
      return identity$1;
    if (!svgNode)
      svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
    svgNode.setAttribute("transform", value);
    if (!(value = svgNode.transform.baseVal.consolidate()))
      return identity$1;
    value = value.matrix;
    return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
  }
  function interpolateTransform(parse2, pxComma, pxParen, degParen) {
    function pop(s) {
      return s.length ? s.pop() + " " : "";
    }
    function translate(xa, ya, xb, yb, s, q) {
      if (xa !== xb || ya !== yb) {
        var i2 = s.push("translate(", null, pxComma, null, pxParen);
        q.push({ i: i2 - 4, x: interpolateNumber(xa, xb) }, { i: i2 - 2, x: interpolateNumber(ya, yb) });
      } else if (xb || yb) {
        s.push("translate(" + xb + pxComma + yb + pxParen);
      }
    }
    function rotate(a, b, s, q) {
      if (a !== b) {
        if (a - b > 180)
          b += 360;
        else if (b - a > 180)
          a += 360;
        q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b) });
      } else if (b) {
        s.push(pop(s) + "rotate(" + b + degParen);
      }
    }
    function skewX(a, b, s, q) {
      if (a !== b) {
        q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b) });
      } else if (b) {
        s.push(pop(s) + "skewX(" + b + degParen);
      }
    }
    function scale(xa, ya, xb, yb, s, q) {
      if (xa !== xb || ya !== yb) {
        var i2 = s.push(pop(s) + "scale(", null, ",", null, ")");
        q.push({ i: i2 - 4, x: interpolateNumber(xa, xb) }, { i: i2 - 2, x: interpolateNumber(ya, yb) });
      } else if (xb !== 1 || yb !== 1) {
        s.push(pop(s) + "scale(" + xb + "," + yb + ")");
      }
    }
    return function(a, b) {
      var s = [], q = [];
      a = parse2(a), b = parse2(b);
      translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
      rotate(a.rotate, b.rotate, s, q);
      skewX(a.skewX, b.skewX, s, q);
      scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
      a = b = null;
      return function(t) {
        var i2 = -1, n = q.length, o;
        while (++i2 < n)
          s[(o = q[i2]).i] = o.x(t);
        return s.join("");
      };
    };
  }
  var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
  var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
  var frame = 0, timeout$1 = 0, interval = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
    setTimeout(f, 17);
  };
  function now$2() {
    return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
  }
  function clearNow() {
    clockNow = 0;
  }
  function Timer() {
    this._call = this._time = this._next = null;
  }
  Timer.prototype = timer.prototype = {
    constructor: Timer,
    restart: function(callback, delay, time) {
      if (typeof callback !== "function")
        throw new TypeError("callback is not a function");
      time = (time == null ? now$2() : +time) + (delay == null ? 0 : +delay);
      if (!this._next && taskTail !== this) {
        if (taskTail)
          taskTail._next = this;
        else
          taskHead = this;
        taskTail = this;
      }
      this._call = callback;
      this._time = time;
      sleep();
    },
    stop: function() {
      if (this._call) {
        this._call = null;
        this._time = Infinity;
        sleep();
      }
    }
  };
  function timer(callback, delay, time) {
    var t = new Timer();
    t.restart(callback, delay, time);
    return t;
  }
  function timerFlush() {
    now$2();
    ++frame;
    var t = taskHead, e;
    while (t) {
      if ((e = clockNow - t._time) >= 0)
        t._call.call(void 0, e);
      t = t._next;
    }
    --frame;
  }
  function wake() {
    clockNow = (clockLast = clock.now()) + clockSkew;
    frame = timeout$1 = 0;
    try {
      timerFlush();
    } finally {
      frame = 0;
      nap();
      clockNow = 0;
    }
  }
  function poke() {
    var now2 = clock.now(), delay = now2 - clockLast;
    if (delay > pokeDelay)
      clockSkew -= delay, clockLast = now2;
  }
  function nap() {
    var t0, t1 = taskHead, t2, time = Infinity;
    while (t1) {
      if (t1._call) {
        if (time > t1._time)
          time = t1._time;
        t0 = t1, t1 = t1._next;
      } else {
        t2 = t1._next, t1._next = null;
        t1 = t0 ? t0._next = t2 : taskHead = t2;
      }
    }
    taskTail = t0;
    sleep(time);
  }
  function sleep(time) {
    if (frame)
      return;
    if (timeout$1)
      timeout$1 = clearTimeout(timeout$1);
    var delay = time - clockNow;
    if (delay > 24) {
      if (time < Infinity)
        timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
      if (interval)
        interval = clearInterval(interval);
    } else {
      if (!interval)
        clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
      frame = 1, setFrame(wake);
    }
  }
  function timeout(callback, delay, time) {
    var t = new Timer();
    delay = delay == null ? 0 : +delay;
    t.restart((elapsed) => {
      t.stop();
      callback(elapsed + delay);
    }, delay, time);
    return t;
  }
  var emptyOn = dispatch("start", "end", "cancel", "interrupt");
  var emptyTween = [];
  var CREATED = 0;
  var SCHEDULED = 1;
  var STARTING = 2;
  var STARTED = 3;
  var RUNNING = 4;
  var ENDING = 5;
  var ENDED = 6;
  function schedule(node, name2, id2, index, group, timing) {
    var schedules = node.__transition;
    if (!schedules)
      node.__transition = {};
    else if (id2 in schedules)
      return;
    create(node, id2, {
      name: name2,
      index,
      group,
      on: emptyOn,
      tween: emptyTween,
      time: timing.time,
      delay: timing.delay,
      duration: timing.duration,
      ease: timing.ease,
      timer: null,
      state: CREATED
    });
  }
  function init(node, id2) {
    var schedule2 = get$2(node, id2);
    if (schedule2.state > CREATED)
      throw new Error("too late; already scheduled");
    return schedule2;
  }
  function set$2(node, id2) {
    var schedule2 = get$2(node, id2);
    if (schedule2.state > STARTED)
      throw new Error("too late; already running");
    return schedule2;
  }
  function get$2(node, id2) {
    var schedule2 = node.__transition;
    if (!schedule2 || !(schedule2 = schedule2[id2]))
      throw new Error("transition not found");
    return schedule2;
  }
  function create(node, id2, self2) {
    var schedules = node.__transition, tween;
    schedules[id2] = self2;
    self2.timer = timer(schedule2, 0, self2.time);
    function schedule2(elapsed) {
      self2.state = SCHEDULED;
      self2.timer.restart(start2, self2.delay, self2.time);
      if (self2.delay <= elapsed)
        start2(elapsed - self2.delay);
    }
    function start2(elapsed) {
      var i2, j, n, o;
      if (self2.state !== SCHEDULED)
        return stop();
      for (i2 in schedules) {
        o = schedules[i2];
        if (o.name !== self2.name)
          continue;
        if (o.state === STARTED)
          return timeout(start2);
        if (o.state === RUNNING) {
          o.state = ENDED;
          o.timer.stop();
          o.on.call("interrupt", node, node.__data__, o.index, o.group);
          delete schedules[i2];
        } else if (+i2 < id2) {
          o.state = ENDED;
          o.timer.stop();
          o.on.call("cancel", node, node.__data__, o.index, o.group);
          delete schedules[i2];
        }
      }
      timeout(function() {
        if (self2.state === STARTED) {
          self2.state = RUNNING;
          self2.timer.restart(tick, self2.delay, self2.time);
          tick(elapsed);
        }
      });
      self2.state = STARTING;
      self2.on.call("start", node, node.__data__, self2.index, self2.group);
      if (self2.state !== STARTING)
        return;
      self2.state = STARTED;
      tween = new Array(n = self2.tween.length);
      for (i2 = 0, j = -1; i2 < n; ++i2) {
        if (o = self2.tween[i2].value.call(node, node.__data__, self2.index, self2.group)) {
          tween[++j] = o;
        }
      }
      tween.length = j + 1;
    }
    function tick(elapsed) {
      var t = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i2 = -1, n = tween.length;
      while (++i2 < n) {
        tween[i2].call(node, t);
      }
      if (self2.state === ENDING) {
        self2.on.call("end", node, node.__data__, self2.index, self2.group);
        stop();
      }
    }
    function stop() {
      self2.state = ENDED;
      self2.timer.stop();
      delete schedules[id2];
      for (var i2 in schedules)
        return;
      delete node.__transition;
    }
  }
  function interrupt(node, name2) {
    var schedules = node.__transition, schedule2, active, empty2 = true, i2;
    if (!schedules)
      return;
    name2 = name2 == null ? null : name2 + "";
    for (i2 in schedules) {
      if ((schedule2 = schedules[i2]).name !== name2) {
        empty2 = false;
        continue;
      }
      active = schedule2.state > STARTING && schedule2.state < ENDING;
      schedule2.state = ENDED;
      schedule2.timer.stop();
      schedule2.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule2.index, schedule2.group);
      delete schedules[i2];
    }
    if (empty2)
      delete node.__transition;
  }
  function selection_interrupt(name2) {
    return this.each(function() {
      interrupt(this, name2);
    });
  }
  function tweenRemove(id2, name2) {
    var tween0, tween1;
    return function() {
      var schedule2 = set$2(this, id2), tween = schedule2.tween;
      if (tween !== tween0) {
        tween1 = tween0 = tween;
        for (var i2 = 0, n = tween1.length; i2 < n; ++i2) {
          if (tween1[i2].name === name2) {
            tween1 = tween1.slice();
            tween1.splice(i2, 1);
            break;
          }
        }
      }
      schedule2.tween = tween1;
    };
  }
  function tweenFunction(id2, name2, value) {
    var tween0, tween1;
    if (typeof value !== "function")
      throw new Error();
    return function() {
      var schedule2 = set$2(this, id2), tween = schedule2.tween;
      if (tween !== tween0) {
        tween1 = (tween0 = tween).slice();
        for (var t = { name: name2, value }, i2 = 0, n = tween1.length; i2 < n; ++i2) {
          if (tween1[i2].name === name2) {
            tween1[i2] = t;
            break;
          }
        }
        if (i2 === n)
          tween1.push(t);
      }
      schedule2.tween = tween1;
    };
  }
  function transition_tween(name2, value) {
    var id2 = this._id;
    name2 += "";
    if (arguments.length < 2) {
      var tween = get$2(this.node(), id2).tween;
      for (var i2 = 0, n = tween.length, t; i2 < n; ++i2) {
        if ((t = tween[i2]).name === name2) {
          return t.value;
        }
      }
      return null;
    }
    return this.each((value == null ? tweenRemove : tweenFunction)(id2, name2, value));
  }
  function tweenValue(transition, name2, value) {
    var id2 = transition._id;
    transition.each(function() {
      var schedule2 = set$2(this, id2);
      (schedule2.value || (schedule2.value = {}))[name2] = value.apply(this, arguments);
    });
    return function(node) {
      return get$2(node, id2).value[name2];
    };
  }
  function interpolate(a, b) {
    var c;
    return (typeof b === "number" ? interpolateNumber : b instanceof color ? interpolateRgb : (c = color(b)) ? (b = c, interpolateRgb) : interpolateString)(a, b);
  }
  function attrRemove(name2) {
    return function() {
      this.removeAttribute(name2);
    };
  }
  function attrRemoveNS(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }
  function attrConstant(name2, interpolate2, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = this.getAttribute(name2);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
    };
  }
  function attrConstantNS(fullname, interpolate2, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = this.getAttributeNS(fullname.space, fullname.local);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
    };
  }
  function attrFunction(name2, interpolate2, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null)
        return void this.removeAttribute(name2);
      string0 = this.getAttribute(name2);
      string1 = value1 + "";
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
    };
  }
  function attrFunctionNS(fullname, interpolate2, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null)
        return void this.removeAttributeNS(fullname.space, fullname.local);
      string0 = this.getAttributeNS(fullname.space, fullname.local);
      string1 = value1 + "";
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
    };
  }
  function transition_attr(name2, value) {
    var fullname = namespace(name2), i2 = fullname === "transform" ? interpolateTransformSvg : interpolate;
    return this.attrTween(name2, typeof value === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i2, tweenValue(this, "attr." + name2, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i2, value));
  }
  function attrInterpolate(name2, i2) {
    return function(t) {
      this.setAttribute(name2, i2.call(this, t));
    };
  }
  function attrInterpolateNS(fullname, i2) {
    return function(t) {
      this.setAttributeNS(fullname.space, fullname.local, i2.call(this, t));
    };
  }
  function attrTweenNS(fullname, value) {
    var t0, i0;
    function tween() {
      var i2 = value.apply(this, arguments);
      if (i2 !== i0)
        t0 = (i0 = i2) && attrInterpolateNS(fullname, i2);
      return t0;
    }
    tween._value = value;
    return tween;
  }
  function attrTween(name2, value) {
    var t0, i0;
    function tween() {
      var i2 = value.apply(this, arguments);
      if (i2 !== i0)
        t0 = (i0 = i2) && attrInterpolate(name2, i2);
      return t0;
    }
    tween._value = value;
    return tween;
  }
  function transition_attrTween(name2, value) {
    var key = "attr." + name2;
    if (arguments.length < 2)
      return (key = this.tween(key)) && key._value;
    if (value == null)
      return this.tween(key, null);
    if (typeof value !== "function")
      throw new Error();
    var fullname = namespace(name2);
    return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
  }
  function delayFunction(id2, value) {
    return function() {
      init(this, id2).delay = +value.apply(this, arguments);
    };
  }
  function delayConstant(id2, value) {
    return value = +value, function() {
      init(this, id2).delay = value;
    };
  }
  function transition_delay(value) {
    var id2 = this._id;
    return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get$2(this.node(), id2).delay;
  }
  function durationFunction(id2, value) {
    return function() {
      set$2(this, id2).duration = +value.apply(this, arguments);
    };
  }
  function durationConstant(id2, value) {
    return value = +value, function() {
      set$2(this, id2).duration = value;
    };
  }
  function transition_duration(value) {
    var id2 = this._id;
    return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get$2(this.node(), id2).duration;
  }
  function easeConstant(id2, value) {
    if (typeof value !== "function")
      throw new Error();
    return function() {
      set$2(this, id2).ease = value;
    };
  }
  function transition_ease(value) {
    var id2 = this._id;
    return arguments.length ? this.each(easeConstant(id2, value)) : get$2(this.node(), id2).ease;
  }
  function easeVarying(id2, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (typeof v !== "function")
        throw new Error();
      set$2(this, id2).ease = v;
    };
  }
  function transition_easeVarying(value) {
    if (typeof value !== "function")
      throw new Error();
    return this.each(easeVarying(this._id, value));
  }
  function transition_filter(match2) {
    if (typeof match2 !== "function")
      match2 = matcher(match2);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i2 = 0; i2 < n; ++i2) {
        if ((node = group[i2]) && match2.call(node, node.__data__, i2, group)) {
          subgroup.push(node);
        }
      }
    }
    return new Transition(subgroups, this._parents, this._name, this._id);
  }
  function transition_merge(transition) {
    if (transition._id !== this._id)
      throw new Error();
    for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i2 = 0; i2 < n; ++i2) {
        if (node = group0[i2] || group1[i2]) {
          merge[i2] = node;
        }
      }
    }
    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }
    return new Transition(merges, this._parents, this._name, this._id);
  }
  function start(name2) {
    return (name2 + "").trim().split(/^|\s+/).every(function(t) {
      var i2 = t.indexOf(".");
      if (i2 >= 0)
        t = t.slice(0, i2);
      return !t || t === "start";
    });
  }
  function onFunction(id2, name2, listener) {
    var on0, on1, sit = start(name2) ? init : set$2;
    return function() {
      var schedule2 = sit(this, id2), on = schedule2.on;
      if (on !== on0)
        (on1 = (on0 = on).copy()).on(name2, listener);
      schedule2.on = on1;
    };
  }
  function transition_on(name2, listener) {
    var id2 = this._id;
    return arguments.length < 2 ? get$2(this.node(), id2).on.on(name2) : this.each(onFunction(id2, name2, listener));
  }
  function removeFunction(id2) {
    return function() {
      var parent = this.parentNode;
      for (var i2 in this.__transition)
        if (+i2 !== id2)
          return;
      if (parent)
        parent.removeChild(this);
    };
  }
  function transition_remove() {
    return this.on("end.remove", removeFunction(this._id));
  }
  function transition_select(select2) {
    var name2 = this._name, id2 = this._id;
    if (typeof select2 !== "function")
      select2 = selector(select2);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i2 = 0; i2 < n; ++i2) {
        if ((node = group[i2]) && (subnode = select2.call(node, node.__data__, i2, group))) {
          if ("__data__" in node)
            subnode.__data__ = node.__data__;
          subgroup[i2] = subnode;
          schedule(subgroup[i2], name2, id2, i2, subgroup, get$2(node, id2));
        }
      }
    }
    return new Transition(subgroups, this._parents, name2, id2);
  }
  function transition_selectAll(select2) {
    var name2 = this._name, id2 = this._id;
    if (typeof select2 !== "function")
      select2 = selectorAll(select2);
    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i2 = 0; i2 < n; ++i2) {
        if (node = group[i2]) {
          for (var children2 = select2.call(node, node.__data__, i2, group), child, inherit2 = get$2(node, id2), k = 0, l = children2.length; k < l; ++k) {
            if (child = children2[k]) {
              schedule(child, name2, id2, k, children2, inherit2);
            }
          }
          subgroups.push(children2);
          parents.push(node);
        }
      }
    }
    return new Transition(subgroups, parents, name2, id2);
  }
  var Selection = selection.prototype.constructor;
  function transition_selection() {
    return new Selection(this._groups, this._parents);
  }
  function styleNull(name2, interpolate2) {
    var string00, string10, interpolate0;
    return function() {
      var string0 = styleValue(this, name2), string1 = (this.style.removeProperty(name2), styleValue(this, name2));
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);
    };
  }
  function styleRemove(name2) {
    return function() {
      this.style.removeProperty(name2);
    };
  }
  function styleConstant(name2, interpolate2, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = styleValue(this, name2);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
    };
  }
  function styleFunction(name2, interpolate2, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0 = styleValue(this, name2), value1 = value(this), string1 = value1 + "";
      if (value1 == null)
        string1 = value1 = (this.style.removeProperty(name2), styleValue(this, name2));
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
    };
  }
  function styleMaybeRemove(id2, name2) {
    var on0, on1, listener0, key = "style." + name2, event2 = "end." + key, remove2;
    return function() {
      var schedule2 = set$2(this, id2), on = schedule2.on, listener = schedule2.value[key] == null ? remove2 || (remove2 = styleRemove(name2)) : void 0;
      if (on !== on0 || listener0 !== listener)
        (on1 = (on0 = on).copy()).on(event2, listener0 = listener);
      schedule2.on = on1;
    };
  }
  function transition_style(name2, value, priority) {
    var i2 = (name2 += "") === "transform" ? interpolateTransformCss : interpolate;
    return value == null ? this.styleTween(name2, styleNull(name2, i2)).on("end.style." + name2, styleRemove(name2)) : typeof value === "function" ? this.styleTween(name2, styleFunction(name2, i2, tweenValue(this, "style." + name2, value))).each(styleMaybeRemove(this._id, name2)) : this.styleTween(name2, styleConstant(name2, i2, value), priority).on("end.style." + name2, null);
  }
  function styleInterpolate(name2, i2, priority) {
    return function(t) {
      this.style.setProperty(name2, i2.call(this, t), priority);
    };
  }
  function styleTween(name2, value, priority) {
    var t, i0;
    function tween() {
      var i2 = value.apply(this, arguments);
      if (i2 !== i0)
        t = (i0 = i2) && styleInterpolate(name2, i2, priority);
      return t;
    }
    tween._value = value;
    return tween;
  }
  function transition_styleTween(name2, value, priority) {
    var key = "style." + (name2 += "");
    if (arguments.length < 2)
      return (key = this.tween(key)) && key._value;
    if (value == null)
      return this.tween(key, null);
    if (typeof value !== "function")
      throw new Error();
    return this.tween(key, styleTween(name2, value, priority == null ? "" : priority));
  }
  function textConstant(value) {
    return function() {
      this.textContent = value;
    };
  }
  function textFunction(value) {
    return function() {
      var value1 = value(this);
      this.textContent = value1 == null ? "" : value1;
    };
  }
  function transition_text(value) {
    return this.tween("text", typeof value === "function" ? textFunction(tweenValue(this, "text", value)) : textConstant(value == null ? "" : value + ""));
  }
  function textInterpolate(i2) {
    return function(t) {
      this.textContent = i2.call(this, t);
    };
  }
  function textTween(value) {
    var t0, i0;
    function tween() {
      var i2 = value.apply(this, arguments);
      if (i2 !== i0)
        t0 = (i0 = i2) && textInterpolate(i2);
      return t0;
    }
    tween._value = value;
    return tween;
  }
  function transition_textTween(value) {
    var key = "text";
    if (arguments.length < 1)
      return (key = this.tween(key)) && key._value;
    if (value == null)
      return this.tween(key, null);
    if (typeof value !== "function")
      throw new Error();
    return this.tween(key, textTween(value));
  }
  function transition_transition() {
    var name2 = this._name, id0 = this._id, id1 = newId();
    for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i2 = 0; i2 < n; ++i2) {
        if (node = group[i2]) {
          var inherit2 = get$2(node, id0);
          schedule(node, name2, id1, i2, group, {
            time: inherit2.time + inherit2.delay + inherit2.duration,
            delay: 0,
            duration: inherit2.duration,
            ease: inherit2.ease
          });
        }
      }
    }
    return new Transition(groups, this._parents, name2, id1);
  }
  function transition_end() {
    var on0, on1, that = this, id2 = that._id, size = that.size();
    return new Promise(function(resolve2, reject) {
      var cancel = { value: reject }, end = { value: function() {
        if (--size === 0)
          resolve2();
      } };
      that.each(function() {
        var schedule2 = set$2(this, id2), on = schedule2.on;
        if (on !== on0) {
          on1 = (on0 = on).copy();
          on1._.cancel.push(cancel);
          on1._.interrupt.push(cancel);
          on1._.end.push(end);
        }
        schedule2.on = on1;
      });
      if (size === 0)
        resolve2();
    });
  }
  var id = 0;
  function Transition(groups, parents, name2, id2) {
    this._groups = groups;
    this._parents = parents;
    this._name = name2;
    this._id = id2;
  }
  function newId() {
    return ++id;
  }
  var selection_prototype = selection.prototype;
  Transition.prototype = {
    constructor: Transition,
    select: transition_select,
    selectAll: transition_selectAll,
    selectChild: selection_prototype.selectChild,
    selectChildren: selection_prototype.selectChildren,
    filter: transition_filter,
    merge: transition_merge,
    selection: transition_selection,
    transition: transition_transition,
    call: selection_prototype.call,
    nodes: selection_prototype.nodes,
    node: selection_prototype.node,
    size: selection_prototype.size,
    empty: selection_prototype.empty,
    each: selection_prototype.each,
    on: transition_on,
    attr: transition_attr,
    attrTween: transition_attrTween,
    style: transition_style,
    styleTween: transition_styleTween,
    text: transition_text,
    textTween: transition_textTween,
    remove: transition_remove,
    tween: transition_tween,
    delay: transition_delay,
    duration: transition_duration,
    ease: transition_ease,
    easeVarying: transition_easeVarying,
    end: transition_end,
    [Symbol.iterator]: selection_prototype[Symbol.iterator]
  };
  function cubicInOut(t) {
    return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
  }
  var defaultTiming = {
    time: null,
    delay: 0,
    duration: 250,
    ease: cubicInOut
  };
  function inherit(node, id2) {
    var timing;
    while (!(timing = node.__transition) || !(timing = timing[id2])) {
      if (!(node = node.parentNode)) {
        throw new Error(`transition ${id2} not found`);
      }
    }
    return timing;
  }
  function selection_transition(name2) {
    var id2, timing;
    if (name2 instanceof Transition) {
      id2 = name2._id, name2 = name2._name;
    } else {
      id2 = newId(), (timing = defaultTiming).time = now$2(), name2 = name2 == null ? null : name2 + "";
    }
    for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i2 = 0; i2 < n; ++i2) {
        if (node = group[i2]) {
          schedule(node, name2, id2, i2, group, timing || inherit(node, id2));
        }
      }
    }
    return new Transition(groups, this._parents, name2, id2);
  }
  selection.prototype.interrupt = selection_interrupt;
  selection.prototype.transition = selection_transition;
  function Transform(k, x, y) {
    this.k = k;
    this.x = x;
    this.y = y;
  }
  Transform.prototype = {
    constructor: Transform,
    scale: function(k) {
      return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
    },
    translate: function(x, y) {
      return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
    },
    apply: function(point) {
      return [point[0] * this.k + this.x, point[1] * this.k + this.y];
    },
    applyX: function(x) {
      return x * this.k + this.x;
    },
    applyY: function(y) {
      return y * this.k + this.y;
    },
    invert: function(location) {
      return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
    },
    invertX: function(x) {
      return (x - this.x) / this.k;
    },
    invertY: function(y) {
      return (y - this.y) / this.k;
    },
    rescaleX: function(x) {
      return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
    },
    rescaleY: function(y) {
      return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
    },
    toString: function() {
      return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
    }
  };
  new Transform(1, 0, 0);
  Transform.prototype;
  const MAX_SECTIONS = 12;
  function wrap(text, width) {
    text.each(function() {
      var text2 = select(this), words = text2.text().split(/(\s+|<br>)/).reverse(), word, line = [], lineHeight = 1.1, y = text2.attr("y"), dy = parseFloat(text2.attr("dy")), tspan = text2.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
      for (let j = 0; j < words.length; j++) {
        word = words[words.length - 1 - j];
        line.push(word);
        tspan.text(line.join(" ").trim());
        if (tspan.node().getComputedTextLength() > width || word === "<br>") {
          line.pop();
          tspan.text(line.join(" ").trim());
          if (word === "<br>") {
            line = [""];
          } else {
            line = [word];
          }
          tspan = text2.append("tspan").attr("x", 0).attr("y", y).attr("dy", lineHeight + "em").text(word);
        }
      }
    });
  }
  const defaultBkg = function(elem, node, section) {
    const rd = 5;
    elem.append("path").attr("id", "node-" + node.id).attr("class", "node-bkg node-" + type2Str(node.type)).attr(
      "d",
      `M0 ${node.height - rd} v${-node.height + 2 * rd} q0,-5 5,-5 h${node.width - 2 * rd} q5,0 5,5 v${node.height - rd} H0 Z`
    );
    elem.append("line").attr("class", "node-line-" + section).attr("x1", 0).attr("y1", node.height).attr("x2", node.width).attr("y2", node.height);
  };
  const rectBkg = function(elem, node) {
    elem.append("rect").attr("id", "node-" + node.id).attr("class", "node-bkg node-" + type2Str(node.type)).attr("height", node.height).attr("width", node.width);
  };
  const cloudBkg = function(elem, node) {
    const w = node.width;
    const h = node.height;
    const r1 = 0.15 * w;
    const r2 = 0.25 * w;
    const r3 = 0.35 * w;
    const r4 = 0.2 * w;
    elem.append("path").attr("id", "node-" + node.id).attr("class", "node-bkg node-" + type2Str(node.type)).attr(
      "d",
      `M0 0 a${r1},${r1} 0 0,1 ${w * 0.25},${-1 * w * 0.1}
      a${r3},${r3} 1 0,1 ${w * 0.4},${-1 * w * 0.1}
      a${r2},${r2} 1 0,1 ${w * 0.35},${1 * w * 0.2}

      a${r1},${r1} 1 0,1 ${w * 0.15},${1 * h * 0.35}
      a${r4},${r4} 1 0,1 ${-1 * w * 0.15},${1 * h * 0.65}

      a${r2},${r1} 1 0,1 ${-1 * w * 0.25},${w * 0.15}
      a${r3},${r3} 1 0,1 ${-1 * w * 0.5},${0}
      a${r1},${r1} 1 0,1 ${-1 * w * 0.25},${-1 * w * 0.15}

      a${r1},${r1} 1 0,1 ${-1 * w * 0.1},${-1 * h * 0.35}
      a${r4},${r4} 1 0,1 ${w * 0.1},${-1 * h * 0.65}

    H0 V0 Z`
    );
  };
  const bangBkg = function(elem, node) {
    const w = node.width;
    const h = node.height;
    const r = 0.15 * w;
    elem.append("path").attr("id", "node-" + node.id).attr("class", "node-bkg node-" + type2Str(node.type)).attr(
      "d",
      `M0 0 a${r},${r} 1 0,0 ${w * 0.25},${-1 * h * 0.1}
      a${r},${r} 1 0,0 ${w * 0.25},${0}
      a${r},${r} 1 0,0 ${w * 0.25},${0}
      a${r},${r} 1 0,0 ${w * 0.25},${1 * h * 0.1}

      a${r},${r} 1 0,0 ${w * 0.15},${1 * h * 0.33}
      a${r * 0.8},${r * 0.8} 1 0,0 ${0},${1 * h * 0.34}
      a${r},${r} 1 0,0 ${-1 * w * 0.15},${1 * h * 0.33}

      a${r},${r} 1 0,0 ${-1 * w * 0.25},${h * 0.15}
      a${r},${r} 1 0,0 ${-1 * w * 0.25},${0}
      a${r},${r} 1 0,0 ${-1 * w * 0.25},${0}
      a${r},${r} 1 0,0 ${-1 * w * 0.25},${-1 * h * 0.15}

      a${r},${r} 1 0,0 ${-1 * w * 0.1},${-1 * h * 0.33}
      a${r * 0.8},${r * 0.8} 1 0,0 ${0},${-1 * h * 0.34}
      a${r},${r} 1 0,0 ${w * 0.1},${-1 * h * 0.33}

    H0 V0 Z`
    );
  };
  const circleBkg = function(elem, node) {
    elem.append("circle").attr("id", "node-" + node.id).attr("class", "node-bkg node-" + type2Str(node.type)).attr("r", node.width / 2);
  };
  const roundedRectBkg = function(elem, node) {
    elem.append("rect").attr("id", "node-" + node.id).attr("class", "node-bkg node-" + type2Str(node.type)).attr("height", node.height).attr("rx", node.padding).attr("ry", node.padding).attr("width", node.width);
  };
  const drawNode = function(elem, node, fullSection, conf) {
    const section = fullSection % MAX_SECTIONS - 1;
    const nodeElem = elem.append("g");
    node.section = section;
    nodeElem.attr(
      "class",
      (node.class ? node.class + " " : "") + "mindmap-node " + (section < 0 ? "section-root" : "section-" + section)
    );
    const bkgElem = nodeElem.append("g");
    const textElem = nodeElem.append("g");
    const txt = textElem.append("text").text(node.descr).attr("dy", "1em").attr("alignment-baseline", "middle").attr("dominant-baseline", "middle").attr("text-anchor", "middle").call(wrap, node.width);
    const bbox = txt.node().getBBox();
    const fontSize = conf.fontSize.replace ? conf.fontSize.replace("px", "") : conf.fontSize;
    node.height = bbox.height + fontSize * 1.1 * 0.5 + node.padding;
    node.width = bbox.width + 2 * node.padding;
    if (node.icon) {
      if (node.type === nodeType.CIRCLE) {
        node.height += 50;
        node.width += 50;
        const icon = nodeElem.append("foreignObject").attr("height", "50px").attr("width", node.width).attr("style", "text-align: center;");
        icon.append("div").attr("class", "icon-container").append("i").attr("class", "node-icon-" + section + " " + node.icon);
        textElem.attr(
          "transform",
          "translate(" + node.width / 2 + ", " + (node.height / 2 - 1.5 * node.padding) + ")"
        );
      } else {
        node.width += 50;
        const orgHeight = node.height;
        node.height = Math.max(orgHeight, 60);
        const heightDiff = Math.abs(node.height - orgHeight);
        const icon = nodeElem.append("foreignObject").attr("width", "60px").attr("height", node.height).attr("style", "text-align: center;margin-top:" + heightDiff / 2 + "px;");
        icon.append("div").attr("class", "icon-container").append("i").attr("class", "node-icon-" + section + " " + node.icon);
        textElem.attr(
          "transform",
          "translate(" + (25 + node.width / 2) + ", " + (heightDiff / 2 + node.padding / 2) + ")"
        );
      }
    } else {
      textElem.attr("transform", "translate(" + node.width / 2 + ", " + node.padding / 2 + ")");
    }
    switch (node.type) {
      case nodeType.DEFAULT:
        defaultBkg(bkgElem, node, section);
        break;
      case nodeType.ROUNDED_RECT:
        roundedRectBkg(bkgElem, node);
        break;
      case nodeType.RECT:
        rectBkg(bkgElem, node);
        break;
      case nodeType.CIRCLE:
        bkgElem.attr("transform", "translate(" + node.width / 2 + ", " + +node.height / 2 + ")");
        circleBkg(bkgElem, node);
        break;
      case nodeType.CLOUD:
        cloudBkg(bkgElem, node);
        break;
      case nodeType.BANG:
        bangBkg(bkgElem, node);
        break;
    }
    setElementForId(node.id, nodeElem);
    return node.height;
  };
  const drawEdge = function drawEdge2(edgesElem, mindmap, parent, depth, fullSection) {
    const section = fullSection % MAX_SECTIONS - 1;
    const sx = parent.x + parent.width / 2;
    const sy = parent.y + parent.height / 2;
    const ex = mindmap.x + mindmap.width / 2;
    const ey = mindmap.y + mindmap.height / 2;
    const mx = ex > sx ? sx + Math.abs(sx - ex) / 2 : sx - Math.abs(sx - ex) / 2;
    const my = ey > sy ? sy + Math.abs(sy - ey) / 2 : sy - Math.abs(sy - ey) / 2;
    const qx = ex > sx ? Math.abs(sx - mx) / 2 + sx : -Math.abs(sx - mx) / 2 + sx;
    const qy = ey > sy ? Math.abs(sy - my) / 2 + sy : -Math.abs(sy - my) / 2 + sy;
    edgesElem.append("path").attr(
      "d",
      parent.direction === "TB" || parent.direction === "BT" ? `M${sx},${sy} Q${sx},${qy} ${mx},${my} T${ex},${ey}` : `M${sx},${sy} Q${qx},${sy} ${mx},${my} T${ex},${ey}`
    ).attr("class", "edge section-edge-" + section + " edge-depth-" + depth);
  };
  const positionNode = function(node) {
    const nodeElem = getElementById(node.id);
    const x = node.x || 0;
    const y = node.y || 0;
    nodeElem.attr("transform", "translate(" + x + "," + y + ")");
  };
  const svgDraw = { drawNode, positionNode, drawEdge };
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  function isObject$5(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  var isObject_1 = isObject$5;
  var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var _freeGlobal = freeGlobal$1;
  var freeGlobal = _freeGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root$4 = freeGlobal || freeSelf || Function("return this")();
  var _root = root$4;
  var root$3 = _root;
  var now$1 = function() {
    return root$3.Date.now();
  };
  var now_1 = now$1;
  var reWhitespace = /\s/;
  function trimmedEndIndex$1(string2) {
    var index = string2.length;
    while (index-- && reWhitespace.test(string2.charAt(index))) {
    }
    return index;
  }
  var _trimmedEndIndex = trimmedEndIndex$1;
  var trimmedEndIndex = _trimmedEndIndex;
  var reTrimStart = /^\s+/;
  function baseTrim$1(string2) {
    return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
  }
  var _baseTrim = baseTrim$1;
  var root$2 = _root;
  var Symbol$4 = root$2.Symbol;
  var _Symbol = Symbol$4;
  var Symbol$3 = _Symbol;
  var objectProto$5 = Object.prototype;
  var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
  var nativeObjectToString$1 = objectProto$5.toString;
  var symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : void 0;
  function getRawTag$1(value) {
    var isOwn = hasOwnProperty$4.call(value, symToStringTag$1), tag = value[symToStringTag$1];
    try {
      value[symToStringTag$1] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }
  var _getRawTag = getRawTag$1;
  var objectProto$4 = Object.prototype;
  var nativeObjectToString = objectProto$4.toString;
  function objectToString$1(value) {
    return nativeObjectToString.call(value);
  }
  var _objectToString = objectToString$1;
  var Symbol$2 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
  var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
  function baseGetTag$2(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  var _baseGetTag = baseGetTag$2;
  function isObjectLike$1(value) {
    return value != null && typeof value == "object";
  }
  var isObjectLike_1 = isObjectLike$1;
  var baseGetTag$1 = _baseGetTag, isObjectLike = isObjectLike_1;
  var symbolTag = "[object Symbol]";
  function isSymbol$5(value) {
    return typeof value == "symbol" || isObjectLike(value) && baseGetTag$1(value) == symbolTag;
  }
  var isSymbol_1 = isSymbol$5;
  var baseTrim = _baseTrim, isObject$4 = isObject_1, isSymbol$4 = isSymbol_1;
  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  function toNumber$1(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol$4(value)) {
      return NAN;
    }
    if (isObject$4(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject$4(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  var toNumber_1 = toNumber$1;
  var isObject$3 = isObject_1, now = now_1, toNumber = toNumber_1;
  var FUNC_ERROR_TEXT$1 = "Expected a function";
  var nativeMax = Math.max, nativeMin = Math.min;
  function debounce$1(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT$1);
    }
    wait = toNumber(wait) || 0;
    if (isObject$3(options)) {
      leading = !!options.leading;
      maxing = "maxWait" in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
      var args = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = void 0;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
      return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }
    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time = now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
      timerId = void 0;
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = void 0;
      return result;
    }
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush() {
      return timerId === void 0 ? result : trailingEdge(now());
    }
    function debounced() {
      var time = now(), isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  var debounce_1 = debounce$1;
  var heap$1 = { exports: {} };
  var heap = { exports: {} };
  (function(module2, exports3) {
    (function() {
      var Heap2, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min2, nlargest, nsmallest, updateItem, _siftdown, _siftup;
      floor = Math.floor, min2 = Math.min;
      defaultCmp = function(x, y) {
        if (x < y) {
          return -1;
        }
        if (x > y) {
          return 1;
        }
        return 0;
      };
      insort = function(a, x, lo, hi, cmp) {
        var mid;
        if (lo == null) {
          lo = 0;
        }
        if (cmp == null) {
          cmp = defaultCmp;
        }
        if (lo < 0) {
          throw new Error("lo must be non-negative");
        }
        if (hi == null) {
          hi = a.length;
        }
        while (lo < hi) {
          mid = floor((lo + hi) / 2);
          if (cmp(x, a[mid]) < 0) {
            hi = mid;
          } else {
            lo = mid + 1;
          }
        }
        return [].splice.apply(a, [lo, lo - lo].concat(x)), x;
      };
      heappush = function(array2, item, cmp) {
        if (cmp == null) {
          cmp = defaultCmp;
        }
        array2.push(item);
        return _siftdown(array2, 0, array2.length - 1, cmp);
      };
      heappop = function(array2, cmp) {
        var lastelt, returnitem;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        lastelt = array2.pop();
        if (array2.length) {
          returnitem = array2[0];
          array2[0] = lastelt;
          _siftup(array2, 0, cmp);
        } else {
          returnitem = lastelt;
        }
        return returnitem;
      };
      heapreplace = function(array2, item, cmp) {
        var returnitem;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        returnitem = array2[0];
        array2[0] = item;
        _siftup(array2, 0, cmp);
        return returnitem;
      };
      heappushpop = function(array2, item, cmp) {
        var _ref;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        if (array2.length && cmp(array2[0], item) < 0) {
          _ref = [array2[0], item], item = _ref[0], array2[0] = _ref[1];
          _siftup(array2, 0, cmp);
        }
        return item;
      };
      heapify = function(array2, cmp) {
        var i2, _i, _len, _ref1, _results, _results1;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        _ref1 = function() {
          _results1 = [];
          for (var _j = 0, _ref = floor(array2.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--) {
            _results1.push(_j);
          }
          return _results1;
        }.apply(this).reverse();
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          i2 = _ref1[_i];
          _results.push(_siftup(array2, i2, cmp));
        }
        return _results;
      };
      updateItem = function(array2, item, cmp) {
        var pos;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        pos = array2.indexOf(item);
        if (pos === -1) {
          return;
        }
        _siftdown(array2, 0, pos, cmp);
        return _siftup(array2, pos, cmp);
      };
      nlargest = function(array2, n, cmp) {
        var elem, result, _i, _len, _ref;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        result = array2.slice(0, n);
        if (!result.length) {
          return result;
        }
        heapify(result, cmp);
        _ref = array2.slice(n);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          elem = _ref[_i];
          heappushpop(result, elem, cmp);
        }
        return result.sort(cmp).reverse();
      };
      nsmallest = function(array2, n, cmp) {
        var elem, los, result, _i, _j, _len, _ref, _ref1, _results;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        if (n * 10 <= array2.length) {
          result = array2.slice(0, n).sort(cmp);
          if (!result.length) {
            return result;
          }
          los = result[result.length - 1];
          _ref = array2.slice(n);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            elem = _ref[_i];
            if (cmp(elem, los) < 0) {
              insort(result, elem, 0, null, cmp);
              result.pop();
              los = result[result.length - 1];
            }
          }
          return result;
        }
        heapify(array2, cmp);
        _results = [];
        for (_j = 0, _ref1 = min2(n, array2.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; 0 <= _ref1 ? ++_j : --_j) {
          _results.push(heappop(array2, cmp));
        }
        return _results;
      };
      _siftdown = function(array2, startpos, pos, cmp) {
        var newitem, parent, parentpos;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        newitem = array2[pos];
        while (pos > startpos) {
          parentpos = pos - 1 >> 1;
          parent = array2[parentpos];
          if (cmp(newitem, parent) < 0) {
            array2[pos] = parent;
            pos = parentpos;
            continue;
          }
          break;
        }
        return array2[pos] = newitem;
      };
      _siftup = function(array2, pos, cmp) {
        var childpos, endpos, newitem, rightpos, startpos;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        endpos = array2.length;
        startpos = pos;
        newitem = array2[pos];
        childpos = 2 * pos + 1;
        while (childpos < endpos) {
          rightpos = childpos + 1;
          if (rightpos < endpos && !(cmp(array2[childpos], array2[rightpos]) < 0)) {
            childpos = rightpos;
          }
          array2[pos] = array2[childpos];
          pos = childpos;
          childpos = 2 * pos + 1;
        }
        array2[pos] = newitem;
        return _siftdown(array2, startpos, pos, cmp);
      };
      Heap2 = function() {
        Heap3.push = heappush;
        Heap3.pop = heappop;
        Heap3.replace = heapreplace;
        Heap3.pushpop = heappushpop;
        Heap3.heapify = heapify;
        Heap3.updateItem = updateItem;
        Heap3.nlargest = nlargest;
        Heap3.nsmallest = nsmallest;
        function Heap3(cmp) {
          this.cmp = cmp != null ? cmp : defaultCmp;
          this.nodes = [];
        }
        Heap3.prototype.push = function(x) {
          return heappush(this.nodes, x, this.cmp);
        };
        Heap3.prototype.pop = function() {
          return heappop(this.nodes, this.cmp);
        };
        Heap3.prototype.peek = function() {
          return this.nodes[0];
        };
        Heap3.prototype.contains = function(x) {
          return this.nodes.indexOf(x) !== -1;
        };
        Heap3.prototype.replace = function(x) {
          return heapreplace(this.nodes, x, this.cmp);
        };
        Heap3.prototype.pushpop = function(x) {
          return heappushpop(this.nodes, x, this.cmp);
        };
        Heap3.prototype.heapify = function() {
          return heapify(this.nodes, this.cmp);
        };
        Heap3.prototype.updateItem = function(x) {
          return updateItem(this.nodes, x, this.cmp);
        };
        Heap3.prototype.clear = function() {
          return this.nodes = [];
        };
        Heap3.prototype.empty = function() {
          return this.nodes.length === 0;
        };
        Heap3.prototype.size = function() {
          return this.nodes.length;
        };
        Heap3.prototype.clone = function() {
          var heap2;
          heap2 = new Heap3();
          heap2.nodes = this.nodes.slice(0);
          return heap2;
        };
        Heap3.prototype.toArray = function() {
          return this.nodes.slice(0);
        };
        Heap3.prototype.insert = Heap3.prototype.push;
        Heap3.prototype.top = Heap3.prototype.peek;
        Heap3.prototype.front = Heap3.prototype.peek;
        Heap3.prototype.has = Heap3.prototype.contains;
        Heap3.prototype.copy = Heap3.prototype.clone;
        return Heap3;
      }();
      (function(root2, factory) {
        {
          return module2.exports = factory();
        }
      })(this, function() {
        return Heap2;
      });
    }).call(commonjsGlobal);
  })(heap);
  (function(module2) {
    module2.exports = heap.exports;
  })(heap$1);
  var isArray$4 = Array.isArray;
  var isArray_1 = isArray$4;
  var isArray$3 = isArray_1, isSymbol$3 = isSymbol_1;
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
  function isKey$1(value, object2) {
    if (isArray$3(value)) {
      return false;
    }
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$3(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
  }
  var _isKey = isKey$1;
  var baseGetTag = _baseGetTag, isObject$2 = isObject_1;
  var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
  function isFunction$1(value) {
    if (!isObject$2(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  var isFunction_1 = isFunction$1;
  var root$1 = _root;
  var coreJsData$1 = root$1["__core-js_shared__"];
  var _coreJsData = coreJsData$1;
  var coreJsData = _coreJsData;
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked$1(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  var _isMasked = isMasked$1;
  var funcProto$1 = Function.prototype;
  var funcToString$1 = funcProto$1.toString;
  function toSource$1(func) {
    if (func != null) {
      try {
        return funcToString$1.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  var _toSource = toSource$1;
  var isFunction = isFunction_1, isMasked = _isMasked, isObject$1 = isObject_1, toSource = _toSource;
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype, objectProto$3 = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty$3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative$1(value) {
    if (!isObject$1(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  var _baseIsNative = baseIsNative$1;
  function getValue$2(object2, key) {
    return object2 == null ? void 0 : object2[key];
  }
  var _getValue = getValue$2;
  var baseIsNative = _baseIsNative, getValue$1 = _getValue;
  function getNative$3(object2, key) {
    var value = getValue$1(object2, key);
    return baseIsNative(value) ? value : void 0;
  }
  var _getNative = getNative$3;
  var getNative$2 = _getNative;
  var nativeCreate$4 = getNative$2(Object, "create");
  var _nativeCreate = nativeCreate$4;
  var nativeCreate$3 = _nativeCreate;
  function hashClear$1() {
    this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
    this.size = 0;
  }
  var _hashClear = hashClear$1;
  function hashDelete$1(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  var _hashDelete = hashDelete$1;
  var nativeCreate$2 = _nativeCreate;
  var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
  var objectProto$2 = Object.prototype;
  var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
  function hashGet$1(key) {
    var data2 = this.__data__;
    if (nativeCreate$2) {
      var result = data2[key];
      return result === HASH_UNDEFINED$1 ? void 0 : result;
    }
    return hasOwnProperty$2.call(data2, key) ? data2[key] : void 0;
  }
  var _hashGet = hashGet$1;
  var nativeCreate$1 = _nativeCreate;
  var objectProto$1 = Object.prototype;
  var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
  function hashHas$1(key) {
    var data2 = this.__data__;
    return nativeCreate$1 ? data2[key] !== void 0 : hasOwnProperty$1.call(data2, key);
  }
  var _hashHas = hashHas$1;
  var nativeCreate = _nativeCreate;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function hashSet$1(key, value) {
    var data2 = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  var _hashSet = hashSet$1;
  var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
  function Hash$1(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  Hash$1.prototype.clear = hashClear;
  Hash$1.prototype["delete"] = hashDelete;
  Hash$1.prototype.get = hashGet;
  Hash$1.prototype.has = hashHas;
  Hash$1.prototype.set = hashSet;
  var _Hash = Hash$1;
  function listCacheClear$1() {
    this.__data__ = [];
    this.size = 0;
  }
  var _listCacheClear = listCacheClear$1;
  function eq$2(value, other) {
    return value === other || value !== value && other !== other;
  }
  var eq_1 = eq$2;
  var eq$1 = eq_1;
  function assocIndexOf$4(array2, key) {
    var length = array2.length;
    while (length--) {
      if (eq$1(array2[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  var _assocIndexOf = assocIndexOf$4;
  var assocIndexOf$3 = _assocIndexOf;
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete$1(key) {
    var data2 = this.__data__, index = assocIndexOf$3(data2, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data2.length - 1;
    if (index == lastIndex) {
      data2.pop();
    } else {
      splice.call(data2, index, 1);
    }
    --this.size;
    return true;
  }
  var _listCacheDelete = listCacheDelete$1;
  var assocIndexOf$2 = _assocIndexOf;
  function listCacheGet$1(key) {
    var data2 = this.__data__, index = assocIndexOf$2(data2, key);
    return index < 0 ? void 0 : data2[index][1];
  }
  var _listCacheGet = listCacheGet$1;
  var assocIndexOf$1 = _assocIndexOf;
  function listCacheHas$1(key) {
    return assocIndexOf$1(this.__data__, key) > -1;
  }
  var _listCacheHas = listCacheHas$1;
  var assocIndexOf = _assocIndexOf;
  function listCacheSet$1(key, value) {
    var data2 = this.__data__, index = assocIndexOf(data2, key);
    if (index < 0) {
      ++this.size;
      data2.push([key, value]);
    } else {
      data2[index][1] = value;
    }
    return this;
  }
  var _listCacheSet = listCacheSet$1;
  var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
  function ListCache$1(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache$1.prototype.clear = listCacheClear;
  ListCache$1.prototype["delete"] = listCacheDelete;
  ListCache$1.prototype.get = listCacheGet;
  ListCache$1.prototype.has = listCacheHas;
  ListCache$1.prototype.set = listCacheSet;
  var _ListCache = ListCache$1;
  var getNative$1 = _getNative, root = _root;
  var Map$3 = getNative$1(root, "Map");
  var _Map = Map$3;
  var Hash = _Hash, ListCache = _ListCache, Map$2 = _Map;
  function mapCacheClear$1() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map$2 || ListCache)(),
      "string": new Hash()
    };
  }
  var _mapCacheClear = mapCacheClear$1;
  function isKeyable$1(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  var _isKeyable = isKeyable$1;
  var isKeyable = _isKeyable;
  function getMapData$4(map, key) {
    var data2 = map.__data__;
    return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
  }
  var _getMapData = getMapData$4;
  var getMapData$3 = _getMapData;
  function mapCacheDelete$1(key) {
    var result = getMapData$3(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  var _mapCacheDelete = mapCacheDelete$1;
  var getMapData$2 = _getMapData;
  function mapCacheGet$1(key) {
    return getMapData$2(this, key).get(key);
  }
  var _mapCacheGet = mapCacheGet$1;
  var getMapData$1 = _getMapData;
  function mapCacheHas$1(key) {
    return getMapData$1(this, key).has(key);
  }
  var _mapCacheHas = mapCacheHas$1;
  var getMapData = _getMapData;
  function mapCacheSet$1(key, value) {
    var data2 = getMapData(this, key), size = data2.size;
    data2.set(key, value);
    this.size += data2.size == size ? 0 : 1;
    return this;
  }
  var _mapCacheSet = mapCacheSet$1;
  var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
  function MapCache$1(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache$1.prototype.clear = mapCacheClear;
  MapCache$1.prototype["delete"] = mapCacheDelete;
  MapCache$1.prototype.get = mapCacheGet;
  MapCache$1.prototype.has = mapCacheHas;
  MapCache$1.prototype.set = mapCacheSet;
  var _MapCache = MapCache$1;
  var MapCache = _MapCache;
  var FUNC_ERROR_TEXT = "Expected a function";
  function memoize$2(func, resolver2) {
    if (typeof func != "function" || resolver2 != null && typeof resolver2 != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments, key = resolver2 ? resolver2.apply(this, args) : args[0], cache2 = memoized.cache;
      if (cache2.has(key)) {
        return cache2.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache2.set(key, result) || cache2;
      return result;
    };
    memoized.cache = new (memoize$2.Cache || MapCache)();
    return memoized;
  }
  memoize$2.Cache = MapCache;
  var memoize_1 = memoize$2;
  var memoize$1 = memoize_1;
  var MAX_MEMOIZE_SIZE = 500;
  function memoizeCapped$1(func) {
    var result = memoize$1(func, function(key) {
      if (cache2.size === MAX_MEMOIZE_SIZE) {
        cache2.clear();
      }
      return key;
    });
    var cache2 = result.cache;
    return result;
  }
  var _memoizeCapped = memoizeCapped$1;
  var memoizeCapped = _memoizeCapped;
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath$2 = memoizeCapped(function(string2) {
    var result = [];
    if (string2.charCodeAt(0) === 46) {
      result.push("");
    }
    string2.replace(rePropName, function(match2, number2, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match2);
    });
    return result;
  });
  var _stringToPath = stringToPath$2;
  function arrayMap$2(array2, iteratee) {
    var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array2[index], index, array2);
    }
    return result;
  }
  var _arrayMap = arrayMap$2;
  var Symbol$1 = _Symbol, arrayMap$1 = _arrayMap, isArray$2 = isArray_1, isSymbol$2 = isSymbol_1;
  var INFINITY$1 = 1 / 0;
  var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseToString$1(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray$2(value)) {
      return arrayMap$1(value, baseToString$1) + "";
    }
    if (isSymbol$2(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
  }
  var _baseToString = baseToString$1;
  var baseToString = _baseToString;
  function toString$3(value) {
    return value == null ? "" : baseToString(value);
  }
  var toString_1 = toString$3;
  var isArray$1 = isArray_1, isKey = _isKey, stringToPath$1 = _stringToPath, toString$2 = toString_1;
  function castPath$2(value, object2) {
    if (isArray$1(value)) {
      return value;
    }
    return isKey(value, object2) ? [value] : stringToPath$1(toString$2(value));
  }
  var _castPath = castPath$2;
  var isSymbol$1 = isSymbol_1;
  var INFINITY = 1 / 0;
  function toKey$3(value) {
    if (typeof value == "string" || isSymbol$1(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  var _toKey = toKey$3;
  var castPath$1 = _castPath, toKey$2 = _toKey;
  function baseGet$1(object2, path) {
    path = castPath$1(path, object2);
    var index = 0, length = path.length;
    while (object2 != null && index < length) {
      object2 = object2[toKey$2(path[index++])];
    }
    return index && index == length ? object2 : void 0;
  }
  var _baseGet = baseGet$1;
  var baseGet = _baseGet;
  function get$1(object2, path, defaultValue) {
    var result = object2 == null ? void 0 : baseGet(object2, path);
    return result === void 0 ? defaultValue : result;
  }
  var get_1 = get$1;
  var getNative = _getNative;
  var defineProperty$1 = function() {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {
    }
  }();
  var _defineProperty$1 = defineProperty$1;
  var defineProperty = _defineProperty$1;
  function baseAssignValue$1(object2, key, value) {
    if (key == "__proto__" && defineProperty) {
      defineProperty(object2, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object2[key] = value;
    }
  }
  var _baseAssignValue = baseAssignValue$1;
  var baseAssignValue = _baseAssignValue, eq = eq_1;
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function assignValue$1(object2, key, value) {
    var objValue = object2[key];
    if (!(hasOwnProperty.call(object2, key) && eq(objValue, value)) || value === void 0 && !(key in object2)) {
      baseAssignValue(object2, key, value);
    }
  }
  var _assignValue = assignValue$1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex$1(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  var _isIndex = isIndex$1;
  var assignValue = _assignValue, castPath = _castPath, isIndex = _isIndex, isObject = isObject_1, toKey$1 = _toKey;
  function baseSet$1(object2, path, value, customizer) {
    if (!isObject(object2)) {
      return object2;
    }
    path = castPath(path, object2);
    var index = -1, length = path.length, lastIndex = length - 1, nested = object2;
    while (nested != null && ++index < length) {
      var key = toKey$1(path[index]), newValue = value;
      if (key === "__proto__" || key === "constructor" || key === "prototype") {
        return object2;
      }
      if (index != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : void 0;
        if (newValue === void 0) {
          newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
        }
      }
      assignValue(nested, key, newValue);
      nested = nested[key];
    }
    return object2;
  }
  var _baseSet = baseSet$1;
  var baseSet = _baseSet;
  function set$1(object2, path, value) {
    return object2 == null ? object2 : baseSet(object2, path, value);
  }
  var set_1 = set$1;
  function copyArray$2(source, array2) {
    var index = -1, length = source.length;
    array2 || (array2 = Array(length));
    while (++index < length) {
      array2[index] = source[index];
    }
    return array2;
  }
  var _copyArray = copyArray$2;
  var arrayMap = _arrayMap, copyArray$1 = _copyArray, isArray = isArray_1, isSymbol = isSymbol_1, stringToPath = _stringToPath, toKey = _toKey, toString$1 = toString_1;
  function toPath$1(value) {
    if (isArray(value)) {
      return arrayMap(value, toKey);
    }
    return isSymbol(value) ? [value] : copyArray$1(stringToPath(toString$1(value)));
  }
  var toPath_1 = toPath$1;
  var debounce = debounce_1;
  var Heap = heap$1.exports;
  var get = get_1;
  var set = set_1;
  var toPath = toPath_1;
  function _interopDefaultLegacy$1(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  var debounce__default = /* @__PURE__ */ _interopDefaultLegacy$1(debounce);
  var Heap__default = /* @__PURE__ */ _interopDefaultLegacy$1(Heap);
  var get__default = /* @__PURE__ */ _interopDefaultLegacy$1(get);
  var set__default = /* @__PURE__ */ _interopDefaultLegacy$1(set);
  var toPath__default = /* @__PURE__ */ _interopDefaultLegacy$1(toPath);
  function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof(obj);
  }
  function _classCallCheck(instance2, Constructor) {
    if (!(instance2 instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _slicedToArray(arr, i2) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function _iterableToArrayLimit(arr, i2) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null)
      return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i2 && _arr.length === i2)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
      arr2[i2] = arr[i2];
    return arr2;
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var window$1 = typeof window === "undefined" ? null : window;
  var navigator = window$1 ? window$1.navigator : null;
  window$1 ? window$1.document : null;
  var typeofstr = _typeof("");
  var typeofobj = _typeof({});
  var typeoffn = _typeof(function() {
  });
  var typeofhtmlele = typeof HTMLElement === "undefined" ? "undefined" : _typeof(HTMLElement);
  var instanceStr = function instanceStr2(obj) {
    return obj && obj.instanceString && fn$6(obj.instanceString) ? obj.instanceString() : null;
  };
  var string = function string2(obj) {
    return obj != null && _typeof(obj) == typeofstr;
  };
  var fn$6 = function fn2(obj) {
    return obj != null && _typeof(obj) === typeoffn;
  };
  var array = function array2(obj) {
    return !elementOrCollection(obj) && (Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array);
  };
  var plainObject = function plainObject2(obj) {
    return obj != null && _typeof(obj) === typeofobj && !array(obj) && obj.constructor === Object;
  };
  var object = function object2(obj) {
    return obj != null && _typeof(obj) === typeofobj;
  };
  var number$1 = function number2(obj) {
    return obj != null && _typeof(obj) === _typeof(1) && !isNaN(obj);
  };
  var integer = function integer2(obj) {
    return number$1(obj) && Math.floor(obj) === obj;
  };
  var htmlElement = function htmlElement2(obj) {
    if ("undefined" === typeofhtmlele) {
      return void 0;
    } else {
      return null != obj && obj instanceof HTMLElement;
    }
  };
  var elementOrCollection = function elementOrCollection2(obj) {
    return element(obj) || collection(obj);
  };
  var element = function element2(obj) {
    return instanceStr(obj) === "collection" && obj._private.single;
  };
  var collection = function collection2(obj) {
    return instanceStr(obj) === "collection" && !obj._private.single;
  };
  var core = function core2(obj) {
    return instanceStr(obj) === "core";
  };
  var stylesheet = function stylesheet2(obj) {
    return instanceStr(obj) === "stylesheet";
  };
  var event = function event2(obj) {
    return instanceStr(obj) === "event";
  };
  var emptyString = function emptyString2(obj) {
    if (obj === void 0 || obj === null) {
      return true;
    } else if (obj === "" || obj.match(/^\s+$/)) {
      return true;
    }
    return false;
  };
  var domElement = function domElement2(obj) {
    if (typeof HTMLElement === "undefined") {
      return false;
    } else {
      return obj instanceof HTMLElement;
    }
  };
  var boundingBox = function boundingBox2(obj) {
    return plainObject(obj) && number$1(obj.x1) && number$1(obj.x2) && number$1(obj.y1) && number$1(obj.y2);
  };
  var promise = function promise2(obj) {
    return object(obj) && fn$6(obj.then);
  };
  var ms = function ms2() {
    return navigator && navigator.userAgent.match(/msie|trident|edge/i);
  };
  var memoize = function memoize2(fn2, keyFn) {
    if (!keyFn) {
      keyFn = function keyFn2() {
        if (arguments.length === 1) {
          return arguments[0];
        } else if (arguments.length === 0) {
          return "undefined";
        }
        var args = [];
        for (var i2 = 0; i2 < arguments.length; i2++) {
          args.push(arguments[i2]);
        }
        return args.join("$");
      };
    }
    var memoizedFn = function memoizedFn2() {
      var self2 = this;
      var args = arguments;
      var ret;
      var k = keyFn.apply(self2, args);
      var cache2 = memoizedFn2.cache;
      if (!(ret = cache2[k])) {
        ret = cache2[k] = fn2.apply(self2, args);
      }
      return ret;
    };
    memoizedFn.cache = {};
    return memoizedFn;
  };
  var camel2dash = memoize(function(str) {
    return str.replace(/([A-Z])/g, function(v) {
      return "-" + v.toLowerCase();
    });
  });
  var dash2camel = memoize(function(str) {
    return str.replace(/(-\w)/g, function(v) {
      return v[1].toUpperCase();
    });
  });
  var prependCamel = memoize(function(prefix, str) {
    return prefix + str[0].toUpperCase() + str.substring(1);
  }, function(prefix, str) {
    return prefix + "$" + str;
  });
  var capitalize = function capitalize2(str) {
    if (emptyString(str)) {
      return str;
    }
    return str.charAt(0).toUpperCase() + str.substring(1);
  };
  var number = "(?:[-+]?(?:(?:\\d+|\\d*\\.\\d+)(?:[Ee][+-]?\\d+)?))";
  var rgba = "rgb[a]?\\((" + number + "[%]?)\\s*,\\s*(" + number + "[%]?)\\s*,\\s*(" + number + "[%]?)(?:\\s*,\\s*(" + number + "))?\\)";
  var rgbaNoBackRefs = "rgb[a]?\\((?:" + number + "[%]?)\\s*,\\s*(?:" + number + "[%]?)\\s*,\\s*(?:" + number + "[%]?)(?:\\s*,\\s*(?:" + number + "))?\\)";
  var hsla = "hsl[a]?\\((" + number + ")\\s*,\\s*(" + number + "[%])\\s*,\\s*(" + number + "[%])(?:\\s*,\\s*(" + number + "))?\\)";
  var hslaNoBackRefs = "hsl[a]?\\((?:" + number + ")\\s*,\\s*(?:" + number + "[%])\\s*,\\s*(?:" + number + "[%])(?:\\s*,\\s*(?:" + number + "))?\\)";
  var hex3 = "\\#[0-9a-fA-F]{3}";
  var hex6 = "\\#[0-9a-fA-F]{6}";
  var ascending = function ascending2(a, b) {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else {
      return 0;
    }
  };
  var descending = function descending2(a, b) {
    return -1 * ascending(a, b);
  };
  var extend = Object.assign != null ? Object.assign.bind(Object) : function(tgt) {
    var args = arguments;
    for (var i2 = 1; i2 < args.length; i2++) {
      var obj = args[i2];
      if (obj == null) {
        continue;
      }
      var keys = Object.keys(obj);
      for (var j = 0; j < keys.length; j++) {
        var k = keys[j];
        tgt[k] = obj[k];
      }
    }
    return tgt;
  };
  var hex2tuple = function hex2tuple2(hex2) {
    if (!(hex2.length === 4 || hex2.length === 7) || hex2[0] !== "#") {
      return;
    }
    var shortHex = hex2.length === 4;
    var r, g, b;
    var base = 16;
    if (shortHex) {
      r = parseInt(hex2[1] + hex2[1], base);
      g = parseInt(hex2[2] + hex2[2], base);
      b = parseInt(hex2[3] + hex2[3], base);
    } else {
      r = parseInt(hex2[1] + hex2[2], base);
      g = parseInt(hex2[3] + hex2[4], base);
      b = parseInt(hex2[5] + hex2[6], base);
    }
    return [r, g, b];
  };
  var hsl2tuple = function hsl2tuple2(hsl2) {
    var ret;
    var h, s, l, a, r, g, b;
    function hue2rgb(p3, q2, t) {
      if (t < 0)
        t += 1;
      if (t > 1)
        t -= 1;
      if (t < 1 / 6)
        return p3 + (q2 - p3) * 6 * t;
      if (t < 1 / 2)
        return q2;
      if (t < 2 / 3)
        return p3 + (q2 - p3) * (2 / 3 - t) * 6;
      return p3;
    }
    var m = new RegExp("^" + hsla + "$").exec(hsl2);
    if (m) {
      h = parseInt(m[1]);
      if (h < 0) {
        h = (360 - -1 * h % 360) % 360;
      } else if (h > 360) {
        h = h % 360;
      }
      h /= 360;
      s = parseFloat(m[2]);
      if (s < 0 || s > 100) {
        return;
      }
      s = s / 100;
      l = parseFloat(m[3]);
      if (l < 0 || l > 100) {
        return;
      }
      l = l / 100;
      a = m[4];
      if (a !== void 0) {
        a = parseFloat(a);
        if (a < 0 || a > 1) {
          return;
        }
      }
      if (s === 0) {
        r = g = b = Math.round(l * 255);
      } else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p2 = 2 * l - q;
        r = Math.round(255 * hue2rgb(p2, q, h + 1 / 3));
        g = Math.round(255 * hue2rgb(p2, q, h));
        b = Math.round(255 * hue2rgb(p2, q, h - 1 / 3));
      }
      ret = [r, g, b, a];
    }
    return ret;
  };
  var rgb2tuple = function rgb2tuple2(rgb2) {
    var ret;
    var m = new RegExp("^" + rgba + "$").exec(rgb2);
    if (m) {
      ret = [];
      var isPct = [];
      for (var i2 = 1; i2 <= 3; i2++) {
        var channel2 = m[i2];
        if (channel2[channel2.length - 1] === "%") {
          isPct[i2] = true;
        }
        channel2 = parseFloat(channel2);
        if (isPct[i2]) {
          channel2 = channel2 / 100 * 255;
        }
        if (channel2 < 0 || channel2 > 255) {
          return;
        }
        ret.push(Math.floor(channel2));
      }
      var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];
      var allArePct = isPct[1] && isPct[2] && isPct[3];
      if (atLeastOneIsPct && !allArePct) {
        return;
      }
      var alpha = m[4];
      if (alpha !== void 0) {
        alpha = parseFloat(alpha);
        if (alpha < 0 || alpha > 1) {
          return;
        }
        ret.push(alpha);
      }
    }
    return ret;
  };
  var colorname2tuple = function colorname2tuple2(color2) {
    return colors[color2.toLowerCase()];
  };
  var color2tuple = function color2tuple2(color2) {
    return (array(color2) ? color2 : null) || colorname2tuple(color2) || hex2tuple(color2) || rgb2tuple(color2) || hsl2tuple(color2);
  };
  var colors = {
    transparent: [0, 0, 0, 0],
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    grey: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
  var setMap = function setMap2(options) {
    var obj = options.map;
    var keys = options.keys;
    var l = keys.length;
    for (var i2 = 0; i2 < l; i2++) {
      var key = keys[i2];
      if (plainObject(key)) {
        throw Error("Tried to set map with object key");
      }
      if (i2 < keys.length - 1) {
        if (obj[key] == null) {
          obj[key] = {};
        }
        obj = obj[key];
      } else {
        obj[key] = options.value;
      }
    }
  };
  var getMap = function getMap2(options) {
    var obj = options.map;
    var keys = options.keys;
    var l = keys.length;
    for (var i2 = 0; i2 < l; i2++) {
      var key = keys[i2];
      if (plainObject(key)) {
        throw Error("Tried to get map with object key");
      }
      obj = obj[key];
      if (obj == null) {
        return obj;
      }
    }
    return obj;
  };
  var performance$1 = window$1 ? window$1.performance : null;
  var pnow = performance$1 && performance$1.now ? function() {
    return performance$1.now();
  } : function() {
    return Date.now();
  };
  var raf = function() {
    if (window$1) {
      if (window$1.requestAnimationFrame) {
        return function(fn2) {
          window$1.requestAnimationFrame(fn2);
        };
      } else if (window$1.mozRequestAnimationFrame) {
        return function(fn2) {
          window$1.mozRequestAnimationFrame(fn2);
        };
      } else if (window$1.webkitRequestAnimationFrame) {
        return function(fn2) {
          window$1.webkitRequestAnimationFrame(fn2);
        };
      } else if (window$1.msRequestAnimationFrame) {
        return function(fn2) {
          window$1.msRequestAnimationFrame(fn2);
        };
      }
    }
    return function(fn2) {
      if (fn2) {
        setTimeout(function() {
          fn2(pnow());
        }, 1e3 / 60);
      }
    };
  }();
  var requestAnimationFrame$1 = function requestAnimationFrame2(fn2) {
    return raf(fn2);
  };
  var performanceNow = pnow;
  var DEFAULT_HASH_SEED = 9261;
  var K = 65599;
  var DEFAULT_HASH_SEED_ALT = 5381;
  var hashIterableInts = function hashIterableInts2(iterator) {
    var seed = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_HASH_SEED;
    var hash = seed;
    var entry;
    for (; ; ) {
      entry = iterator.next();
      if (entry.done) {
        break;
      }
      hash = hash * K + entry.value | 0;
    }
    return hash;
  };
  var hashInt = function hashInt2(num) {
    var seed = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_HASH_SEED;
    return seed * K + num | 0;
  };
  var hashIntAlt = function hashIntAlt2(num) {
    var seed = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_HASH_SEED_ALT;
    return (seed << 5) + seed + num | 0;
  };
  var combineHashes = function combineHashes2(hash1, hash2) {
    return hash1 * 2097152 + hash2;
  };
  var combineHashesArray = function combineHashesArray2(hashes) {
    return hashes[0] * 2097152 + hashes[1];
  };
  var hashArrays = function hashArrays2(hashes1, hashes2) {
    return [hashInt(hashes1[0], hashes2[0]), hashIntAlt(hashes1[1], hashes2[1])];
  };
  var hashIntsArray = function hashIntsArray2(ints, seed) {
    var entry = {
      value: 0,
      done: false
    };
    var i2 = 0;
    var length = ints.length;
    var iterator = {
      next: function next2() {
        if (i2 < length) {
          entry.value = ints[i2++];
        } else {
          entry.done = true;
        }
        return entry;
      }
    };
    return hashIterableInts(iterator, seed);
  };
  var hashString = function hashString2(str, seed) {
    var entry = {
      value: 0,
      done: false
    };
    var i2 = 0;
    var length = str.length;
    var iterator = {
      next: function next2() {
        if (i2 < length) {
          entry.value = str.charCodeAt(i2++);
        } else {
          entry.done = true;
        }
        return entry;
      }
    };
    return hashIterableInts(iterator, seed);
  };
  var hashStrings = function hashStrings2() {
    return hashStringsArray(arguments);
  };
  var hashStringsArray = function hashStringsArray2(strs) {
    var hash;
    for (var i2 = 0; i2 < strs.length; i2++) {
      var str = strs[i2];
      if (i2 === 0) {
        hash = hashString(str);
      } else {
        hash = hashString(str, hash);
      }
    }
    return hash;
  };
  var warningsEnabled = true;
  var warnSupported = console.warn != null;
  var traceSupported = console.trace != null;
  var MAX_INT$1 = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var trueify = function trueify2() {
    return true;
  };
  var falsify = function falsify2() {
    return false;
  };
  var zeroify = function zeroify2() {
    return 0;
  };
  var noop$1 = function noop2() {
  };
  var error = function error2(msg) {
    throw new Error(msg);
  };
  var warnings = function warnings2(enabled) {
    if (enabled !== void 0) {
      warningsEnabled = !!enabled;
    } else {
      return warningsEnabled;
    }
  };
  var warn = function warn2(msg) {
    if (!warnings()) {
      return;
    }
    if (warnSupported) {
      console.warn(msg);
    } else {
      console.log(msg);
      if (traceSupported) {
        console.trace();
      }
    }
  };
  var clone = function clone2(obj) {
    return extend({}, obj);
  };
  var copy = function copy2(obj) {
    if (obj == null) {
      return obj;
    }
    if (array(obj)) {
      return obj.slice();
    } else if (plainObject(obj)) {
      return clone(obj);
    } else {
      return obj;
    }
  };
  var copyArray = function copyArray2(arr) {
    return arr.slice();
  };
  var uuid = function uuid2(a, b) {
    for (b = a = ""; a++ < 36; b += a * 51 & 52 ? (a ^ 15 ? 8 ^ Math.random() * (a ^ 20 ? 16 : 4) : 4).toString(16) : "-") {
    }
    return b;
  };
  var _staticEmptyObject = {};
  var staticEmptyObject = function staticEmptyObject2() {
    return _staticEmptyObject;
  };
  var defaults$g = function defaults2(_defaults) {
    var keys = Object.keys(_defaults);
    return function(opts) {
      var filledOpts = {};
      for (var i2 = 0; i2 < keys.length; i2++) {
        var key = keys[i2];
        var optVal = opts == null ? void 0 : opts[key];
        filledOpts[key] = optVal === void 0 ? _defaults[key] : optVal;
      }
      return filledOpts;
    };
  };
  var removeFromArray = function removeFromArray2(arr, ele, oneCopy) {
    for (var i2 = arr.length - 1; i2 >= 0; i2--) {
      if (arr[i2] === ele) {
        arr.splice(i2, 1);
        if (oneCopy) {
          break;
        }
      }
    }
  };
  var clearArray = function clearArray2(arr) {
    arr.splice(0, arr.length);
  };
  var push = function push2(arr, otherArr) {
    for (var i2 = 0; i2 < otherArr.length; i2++) {
      var el = otherArr[i2];
      arr.push(el);
    }
  };
  var getPrefixedProperty = function getPrefixedProperty2(obj, propName, prefix) {
    if (prefix) {
      propName = prependCamel(prefix, propName);
    }
    return obj[propName];
  };
  var setPrefixedProperty = function setPrefixedProperty2(obj, propName, prefix, value) {
    if (prefix) {
      propName = prependCamel(prefix, propName);
    }
    obj[propName] = value;
  };
  var ObjectMap = /* @__PURE__ */ function() {
    function ObjectMap2() {
      _classCallCheck(this, ObjectMap2);
      this._obj = {};
    }
    _createClass(ObjectMap2, [{
      key: "set",
      value: function set2(key, val) {
        this._obj[key] = val;
        return this;
      }
    }, {
      key: "delete",
      value: function _delete(key) {
        this._obj[key] = void 0;
        return this;
      }
    }, {
      key: "clear",
      value: function clear2() {
        this._obj = {};
      }
    }, {
      key: "has",
      value: function has(key) {
        return this._obj[key] !== void 0;
      }
    }, {
      key: "get",
      value: function get2(key) {
        return this._obj[key];
      }
    }]);
    return ObjectMap2;
  }();
  var Map$1 = typeof Map !== "undefined" ? Map : ObjectMap;
  var undef = "undefined";
  var ObjectSet = /* @__PURE__ */ function() {
    function ObjectSet2(arrayOrObjectSet) {
      _classCallCheck(this, ObjectSet2);
      this._obj = /* @__PURE__ */ Object.create(null);
      this.size = 0;
      if (arrayOrObjectSet != null) {
        var arr;
        if (arrayOrObjectSet.instanceString != null && arrayOrObjectSet.instanceString() === this.instanceString()) {
          arr = arrayOrObjectSet.toArray();
        } else {
          arr = arrayOrObjectSet;
        }
        for (var i2 = 0; i2 < arr.length; i2++) {
          this.add(arr[i2]);
        }
      }
    }
    _createClass(ObjectSet2, [{
      key: "instanceString",
      value: function instanceString() {
        return "set";
      }
    }, {
      key: "add",
      value: function add(val) {
        var o = this._obj;
        if (o[val] !== 1) {
          o[val] = 1;
          this.size++;
        }
      }
    }, {
      key: "delete",
      value: function _delete(val) {
        var o = this._obj;
        if (o[val] === 1) {
          o[val] = 0;
          this.size--;
        }
      }
    }, {
      key: "clear",
      value: function clear2() {
        this._obj = /* @__PURE__ */ Object.create(null);
      }
    }, {
      key: "has",
      value: function has(val) {
        return this._obj[val] === 1;
      }
    }, {
      key: "toArray",
      value: function toArray() {
        var _this = this;
        return Object.keys(this._obj).filter(function(key) {
          return _this.has(key);
        });
      }
    }, {
      key: "forEach",
      value: function forEach(callback, thisArg) {
        return this.toArray().forEach(callback, thisArg);
      }
    }]);
    return ObjectSet2;
  }();
  var Set$1 = (typeof Set === "undefined" ? "undefined" : _typeof(Set)) !== undef ? Set : ObjectSet;
  var Element = function Element2(cy, params) {
    var restore = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    if (cy === void 0 || params === void 0 || !core(cy)) {
      error("An element must have a core reference and parameters set");
      return;
    }
    var group = params.group;
    if (group == null) {
      if (params.data && params.data.source != null && params.data.target != null) {
        group = "edges";
      } else {
        group = "nodes";
      }
    }
    if (group !== "nodes" && group !== "edges") {
      error("An element must be of type `nodes` or `edges`; you specified `" + group + "`");
      return;
    }
    this.length = 1;
    this[0] = this;
    var _p = this._private = {
      cy,
      single: true,
      data: params.data || {},
      position: params.position || {
        x: 0,
        y: 0
      },
      autoWidth: void 0,
      autoHeight: void 0,
      autoPadding: void 0,
      compoundBoundsClean: false,
      listeners: [],
      group,
      style: {},
      rstyle: {},
      styleCxts: [],
      styleKeys: {},
      removed: true,
      selected: params.selected ? true : false,
      selectable: params.selectable === void 0 ? true : params.selectable ? true : false,
      locked: params.locked ? true : false,
      grabbed: false,
      grabbable: params.grabbable === void 0 ? true : params.grabbable ? true : false,
      pannable: params.pannable === void 0 ? group === "edges" ? true : false : params.pannable ? true : false,
      active: false,
      classes: new Set$1(),
      animation: {
        current: [],
        queue: []
      },
      rscratch: {},
      scratch: params.scratch || {},
      edges: [],
      children: [],
      parent: params.parent && params.parent.isNode() ? params.parent : null,
      traversalCache: {},
      backgrounding: false,
      bbCache: null,
      bbCacheShift: {
        x: 0,
        y: 0
      },
      bodyBounds: null,
      overlayBounds: null,
      labelBounds: {
        all: null,
        source: null,
        target: null,
        main: null
      },
      arrowBounds: {
        source: null,
        target: null,
        "mid-source": null,
        "mid-target": null
      }
    };
    if (_p.position.x == null) {
      _p.position.x = 0;
    }
    if (_p.position.y == null) {
      _p.position.y = 0;
    }
    if (params.renderedPosition) {
      var rpos = params.renderedPosition;
      var pan = cy.pan();
      var zoom = cy.zoom();
      _p.position = {
        x: (rpos.x - pan.x) / zoom,
        y: (rpos.y - pan.y) / zoom
      };
    }
    var classes = [];
    if (array(params.classes)) {
      classes = params.classes;
    } else if (string(params.classes)) {
      classes = params.classes.split(/\s+/);
    }
    for (var i2 = 0, l = classes.length; i2 < l; i2++) {
      var cls = classes[i2];
      if (!cls || cls === "") {
        continue;
      }
      _p.classes.add(cls);
    }
    this.createEmitter();
    var bypass = params.style || params.css;
    if (bypass) {
      warn("Setting a `style` bypass at element creation should be done only when absolutely necessary.  Try to use the stylesheet instead.");
      this.style(bypass);
    }
    if (restore === void 0 || restore) {
      this.restore();
    }
  };
  var defineSearch = function defineSearch2(params) {
    params = {
      bfs: params.bfs || !params.dfs,
      dfs: params.dfs || !params.bfs
    };
    return function searchFn(roots, fn2, directed) {
      var options;
      if (plainObject(roots) && !elementOrCollection(roots)) {
        options = roots;
        roots = options.roots || options.root;
        fn2 = options.visit;
        directed = options.directed;
      }
      directed = arguments.length === 2 && !fn$6(fn2) ? fn2 : directed;
      fn2 = fn$6(fn2) ? fn2 : function() {
      };
      var cy = this._private.cy;
      var v = roots = string(roots) ? this.filter(roots) : roots;
      var Q = [];
      var connectedNodes = [];
      var connectedBy = {};
      var id2depth = {};
      var V = {};
      var j = 0;
      var found;
      var _this$byGroup = this.byGroup(), nodes2 = _this$byGroup.nodes, edges = _this$byGroup.edges;
      for (var i2 = 0; i2 < v.length; i2++) {
        var vi = v[i2];
        var viId = vi.id();
        if (vi.isNode()) {
          Q.unshift(vi);
          if (params.bfs) {
            V[viId] = true;
            connectedNodes.push(vi);
          }
          id2depth[viId] = 0;
        }
      }
      var _loop = function _loop2() {
        var v2 = params.bfs ? Q.shift() : Q.pop();
        var vId = v2.id();
        if (params.dfs) {
          if (V[vId]) {
            return "continue";
          }
          V[vId] = true;
          connectedNodes.push(v2);
        }
        var depth = id2depth[vId];
        var prevEdge = connectedBy[vId];
        var src = prevEdge != null ? prevEdge.source() : null;
        var tgt = prevEdge != null ? prevEdge.target() : null;
        var prevNode = prevEdge == null ? void 0 : v2.same(src) ? tgt[0] : src[0];
        var ret = void 0;
        ret = fn2(v2, prevEdge, prevNode, j++, depth);
        if (ret === true) {
          found = v2;
          return "break";
        }
        if (ret === false) {
          return "break";
        }
        var vwEdges = v2.connectedEdges().filter(function(e2) {
          return (!directed || e2.source().same(v2)) && edges.has(e2);
        });
        for (var _i2 = 0; _i2 < vwEdges.length; _i2++) {
          var e = vwEdges[_i2];
          var w = e.connectedNodes().filter(function(n) {
            return !n.same(v2) && nodes2.has(n);
          });
          var wId = w.id();
          if (w.length !== 0 && !V[wId]) {
            w = w[0];
            Q.push(w);
            if (params.bfs) {
              V[wId] = true;
              connectedNodes.push(w);
            }
            connectedBy[wId] = e;
            id2depth[wId] = id2depth[vId] + 1;
          }
        }
      };
      while (Q.length !== 0) {
        var _ret = _loop();
        if (_ret === "continue")
          continue;
        if (_ret === "break")
          break;
      }
      var connectedEles = cy.collection();
      for (var _i = 0; _i < connectedNodes.length; _i++) {
        var node = connectedNodes[_i];
        var edge = connectedBy[node.id()];
        if (edge != null) {
          connectedEles.push(edge);
        }
        connectedEles.push(node);
      }
      return {
        path: cy.collection(connectedEles),
        found: cy.collection(found)
      };
    };
  };
  var elesfn$v = {
    breadthFirstSearch: defineSearch({
      bfs: true
    }),
    depthFirstSearch: defineSearch({
      dfs: true
    })
  };
  elesfn$v.bfs = elesfn$v.breadthFirstSearch;
  elesfn$v.dfs = elesfn$v.depthFirstSearch;
  var dijkstraDefaults = defaults$g({
    root: null,
    weight: function weight(edge) {
      return 1;
    },
    directed: false
  });
  var elesfn$u = {
    dijkstra: function dijkstra(options) {
      if (!plainObject(options)) {
        var args = arguments;
        options = {
          root: args[0],
          weight: args[1],
          directed: args[2]
        };
      }
      var _dijkstraDefaults = dijkstraDefaults(options), root2 = _dijkstraDefaults.root, weight = _dijkstraDefaults.weight, directed = _dijkstraDefaults.directed;
      var eles = this;
      var weightFn = weight;
      var source = string(root2) ? this.filter(root2)[0] : root2[0];
      var dist2 = {};
      var prev = {};
      var knownDist = {};
      var _this$byGroup = this.byGroup(), nodes2 = _this$byGroup.nodes, edges = _this$byGroup.edges;
      edges.unmergeBy(function(ele) {
        return ele.isLoop();
      });
      var getDist2 = function getDist3(node2) {
        return dist2[node2.id()];
      };
      var setDist = function setDist2(node2, d) {
        dist2[node2.id()] = d;
        Q.updateItem(node2);
      };
      var Q = new Heap__default["default"](function(a, b) {
        return getDist2(a) - getDist2(b);
      });
      for (var i2 = 0; i2 < nodes2.length; i2++) {
        var node = nodes2[i2];
        dist2[node.id()] = node.same(source) ? 0 : Infinity;
        Q.push(node);
      }
      var distBetween = function distBetween2(u2, v2) {
        var uvs = (directed ? u2.edgesTo(v2) : u2.edgesWith(v2)).intersect(edges);
        var smallestDistance = Infinity;
        var smallestEdge;
        for (var _i = 0; _i < uvs.length; _i++) {
          var edge = uvs[_i];
          var _weight = weightFn(edge);
          if (_weight < smallestDistance || !smallestEdge) {
            smallestDistance = _weight;
            smallestEdge = edge;
          }
        }
        return {
          edge: smallestEdge,
          dist: smallestDistance
        };
      };
      while (Q.size() > 0) {
        var u = Q.pop();
        var smalletsDist = getDist2(u);
        var uid = u.id();
        knownDist[uid] = smalletsDist;
        if (smalletsDist === Infinity) {
          continue;
        }
        var neighbors = u.neighborhood().intersect(nodes2);
        for (var _i2 = 0; _i2 < neighbors.length; _i2++) {
          var v = neighbors[_i2];
          var vid = v.id();
          var vDist = distBetween(u, v);
          var alt = smalletsDist + vDist.dist;
          if (alt < getDist2(v)) {
            setDist(v, alt);
            prev[vid] = {
              node: u,
              edge: vDist.edge
            };
          }
        }
      }
      return {
        distanceTo: function distanceTo(node2) {
          var target = string(node2) ? nodes2.filter(node2)[0] : node2[0];
          return knownDist[target.id()];
        },
        pathTo: function pathTo(node2) {
          var target = string(node2) ? nodes2.filter(node2)[0] : node2[0];
          var S = [];
          var u2 = target;
          var uid2 = u2.id();
          if (target.length > 0) {
            S.unshift(target);
            while (prev[uid2]) {
              var p2 = prev[uid2];
              S.unshift(p2.edge);
              S.unshift(p2.node);
              u2 = p2.node;
              uid2 = u2.id();
            }
          }
          return eles.spawn(S);
        }
      };
    }
  };
  var elesfn$t = {
    kruskal: function kruskal(weightFn) {
      weightFn = weightFn || function(edge2) {
        return 1;
      };
      var _this$byGroup = this.byGroup(), nodes2 = _this$byGroup.nodes, edges = _this$byGroup.edges;
      var numNodes = nodes2.length;
      var forest = new Array(numNodes);
      var A = nodes2;
      var findSetIndex = function findSetIndex2(ele) {
        for (var i3 = 0; i3 < forest.length; i3++) {
          var eles = forest[i3];
          if (eles.has(ele)) {
            return i3;
          }
        }
      };
      for (var i2 = 0; i2 < numNodes; i2++) {
        forest[i2] = this.spawn(nodes2[i2]);
      }
      var S = edges.sort(function(a, b) {
        return weightFn(a) - weightFn(b);
      });
      for (var _i = 0; _i < S.length; _i++) {
        var edge = S[_i];
        var u = edge.source()[0];
        var v = edge.target()[0];
        var setUIndex = findSetIndex(u);
        var setVIndex = findSetIndex(v);
        var setU = forest[setUIndex];
        var setV = forest[setVIndex];
        if (setUIndex !== setVIndex) {
          A.merge(edge);
          setU.merge(setV);
          forest.splice(setVIndex, 1);
        }
      }
      return A;
    }
  };
  var aStarDefaults = defaults$g({
    root: null,
    goal: null,
    weight: function weight(edge) {
      return 1;
    },
    heuristic: function heuristic(edge) {
      return 0;
    },
    directed: false
  });
  var elesfn$s = {
    aStar: function aStar(options) {
      var cy = this.cy();
      var _aStarDefaults = aStarDefaults(options), root2 = _aStarDefaults.root, goal = _aStarDefaults.goal, heuristic = _aStarDefaults.heuristic, directed = _aStarDefaults.directed, weight = _aStarDefaults.weight;
      root2 = cy.collection(root2)[0];
      goal = cy.collection(goal)[0];
      var sid = root2.id();
      var tid = goal.id();
      var gScore = {};
      var fScore = {};
      var closedSetIds = {};
      var openSet = new Heap__default["default"](function(a, b) {
        return fScore[a.id()] - fScore[b.id()];
      });
      var openSetIds = new Set$1();
      var cameFrom = {};
      var cameFromEdge = {};
      var addToOpenSet = function addToOpenSet2(ele, id2) {
        openSet.push(ele);
        openSetIds.add(id2);
      };
      var cMin, cMinId;
      var popFromOpenSet = function popFromOpenSet2() {
        cMin = openSet.pop();
        cMinId = cMin.id();
        openSetIds["delete"](cMinId);
      };
      var isInOpenSet = function isInOpenSet2(id2) {
        return openSetIds.has(id2);
      };
      addToOpenSet(root2, sid);
      gScore[sid] = 0;
      fScore[sid] = heuristic(root2);
      var steps = 0;
      while (openSet.size() > 0) {
        popFromOpenSet();
        steps++;
        if (cMinId === tid) {
          var path = [];
          var pathNode = goal;
          var pathNodeId = tid;
          var pathEdge = cameFromEdge[pathNodeId];
          for (; ; ) {
            path.unshift(pathNode);
            if (pathEdge != null) {
              path.unshift(pathEdge);
            }
            pathNode = cameFrom[pathNodeId];
            if (pathNode == null) {
              break;
            }
            pathNodeId = pathNode.id();
            pathEdge = cameFromEdge[pathNodeId];
          }
          return {
            found: true,
            distance: gScore[cMinId],
            path: this.spawn(path),
            steps
          };
        }
        closedSetIds[cMinId] = true;
        var vwEdges = cMin._private.edges;
        for (var i2 = 0; i2 < vwEdges.length; i2++) {
          var e = vwEdges[i2];
          if (!this.hasElementWithId(e.id())) {
            continue;
          }
          if (directed && e.data("source") !== cMinId) {
            continue;
          }
          var wSrc = e.source();
          var wTgt = e.target();
          var w = wSrc.id() !== cMinId ? wSrc : wTgt;
          var wid = w.id();
          if (!this.hasElementWithId(wid)) {
            continue;
          }
          if (closedSetIds[wid]) {
            continue;
          }
          var tempScore = gScore[cMinId] + weight(e);
          if (!isInOpenSet(wid)) {
            gScore[wid] = tempScore;
            fScore[wid] = tempScore + heuristic(w);
            addToOpenSet(w, wid);
            cameFrom[wid] = cMin;
            cameFromEdge[wid] = e;
            continue;
          }
          if (tempScore < gScore[wid]) {
            gScore[wid] = tempScore;
            fScore[wid] = tempScore + heuristic(w);
            cameFrom[wid] = cMin;
            cameFromEdge[wid] = e;
          }
        }
      }
      return {
        found: false,
        distance: void 0,
        path: void 0,
        steps
      };
    }
  };
  var floydWarshallDefaults = defaults$g({
    weight: function weight(edge) {
      return 1;
    },
    directed: false
  });
  var elesfn$r = {
    floydWarshall: function floydWarshall(options) {
      var cy = this.cy();
      var _floydWarshallDefault = floydWarshallDefaults(options), weight = _floydWarshallDefault.weight, directed = _floydWarshallDefault.directed;
      var weightFn = weight;
      var _this$byGroup = this.byGroup(), nodes2 = _this$byGroup.nodes, edges = _this$byGroup.edges;
      var N = nodes2.length;
      var Nsq = N * N;
      var indexOf = function indexOf2(node) {
        return nodes2.indexOf(node);
      };
      var atIndex = function atIndex2(i3) {
        return nodes2[i3];
      };
      var dist2 = new Array(Nsq);
      for (var n = 0; n < Nsq; n++) {
        var j = n % N;
        var i2 = (n - j) / N;
        if (i2 === j) {
          dist2[n] = 0;
        } else {
          dist2[n] = Infinity;
        }
      }
      var next2 = new Array(Nsq);
      var edgeNext = new Array(Nsq);
      for (var _i = 0; _i < edges.length; _i++) {
        var edge = edges[_i];
        var src = edge.source()[0];
        var tgt = edge.target()[0];
        if (src === tgt) {
          continue;
        }
        var s = indexOf(src);
        var t = indexOf(tgt);
        var st = s * N + t;
        var _weight = weightFn(edge);
        if (dist2[st] > _weight) {
          dist2[st] = _weight;
          next2[st] = t;
          edgeNext[st] = edge;
        }
        if (!directed) {
          var ts = t * N + s;
          if (!directed && dist2[ts] > _weight) {
            dist2[ts] = _weight;
            next2[ts] = s;
            edgeNext[ts] = edge;
          }
        }
      }
      for (var k = 0; k < N; k++) {
        for (var _i2 = 0; _i2 < N; _i2++) {
          var ik = _i2 * N + k;
          for (var _j = 0; _j < N; _j++) {
            var ij = _i2 * N + _j;
            var kj = k * N + _j;
            if (dist2[ik] + dist2[kj] < dist2[ij]) {
              dist2[ij] = dist2[ik] + dist2[kj];
              next2[ij] = next2[ik];
            }
          }
        }
      }
      var getArgEle = function getArgEle2(ele) {
        return (string(ele) ? cy.filter(ele) : ele)[0];
      };
      var indexOfArgEle = function indexOfArgEle2(ele) {
        return indexOf(getArgEle(ele));
      };
      var res = {
        distance: function distance(from, to) {
          var i3 = indexOfArgEle(from);
          var j2 = indexOfArgEle(to);
          return dist2[i3 * N + j2];
        },
        path: function path(from, to) {
          var i3 = indexOfArgEle(from);
          var j2 = indexOfArgEle(to);
          var fromNode = atIndex(i3);
          if (i3 === j2) {
            return fromNode.collection();
          }
          if (next2[i3 * N + j2] == null) {
            return cy.collection();
          }
          var path2 = cy.collection();
          var prev = i3;
          var edge2;
          path2.merge(fromNode);
          while (i3 !== j2) {
            prev = i3;
            i3 = next2[i3 * N + j2];
            edge2 = edgeNext[prev * N + i3];
            path2.merge(edge2);
            path2.merge(atIndex(i3));
          }
          return path2;
        }
      };
      return res;
    }
  };
  var bellmanFordDefaults = defaults$g({
    weight: function weight(edge) {
      return 1;
    },
    directed: false,
    root: null
  });
  var elesfn$q = {
    bellmanFord: function bellmanFord(options) {
      var _this = this;
      var _bellmanFordDefaults = bellmanFordDefaults(options), weight = _bellmanFordDefaults.weight, directed = _bellmanFordDefaults.directed, root2 = _bellmanFordDefaults.root;
      var weightFn = weight;
      var eles = this;
      var cy = this.cy();
      var _this$byGroup = this.byGroup(), edges = _this$byGroup.edges, nodes2 = _this$byGroup.nodes;
      var numNodes = nodes2.length;
      var infoMap = new Map$1();
      var hasNegativeWeightCycle = false;
      var negativeWeightCycles = [];
      root2 = cy.collection(root2)[0];
      edges.unmergeBy(function(edge2) {
        return edge2.isLoop();
      });
      var numEdges = edges.length;
      var getInfo2 = function getInfo3(node2) {
        var obj = infoMap.get(node2.id());
        if (!obj) {
          obj = {};
          infoMap.set(node2.id(), obj);
        }
        return obj;
      };
      var getNodeFromTo = function getNodeFromTo2(to) {
        return (string(to) ? cy.$(to) : to)[0];
      };
      var distanceTo = function distanceTo2(to) {
        return getInfo2(getNodeFromTo(to)).dist;
      };
      var pathTo = function pathTo2(to) {
        var thisStart = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : root2;
        var end = getNodeFromTo(to);
        var path = [];
        var node2 = end;
        for (; ; ) {
          if (node2 == null) {
            return _this.spawn();
          }
          var _getInfo = getInfo2(node2), edge2 = _getInfo.edge, pred = _getInfo.pred;
          path.unshift(node2[0]);
          if (node2.same(thisStart) && path.length > 0) {
            break;
          }
          if (edge2 != null) {
            path.unshift(edge2);
          }
          node2 = pred;
        }
        return eles.spawn(path);
      };
      for (var i2 = 0; i2 < numNodes; i2++) {
        var node = nodes2[i2];
        var info = getInfo2(node);
        if (node.same(root2)) {
          info.dist = 0;
        } else {
          info.dist = Infinity;
        }
        info.pred = null;
        info.edge = null;
      }
      var replacedEdge = false;
      var checkForEdgeReplacement = function checkForEdgeReplacement2(node1, node2, edge2, info1, info2, weight2) {
        var dist2 = info1.dist + weight2;
        if (dist2 < info2.dist && !edge2.same(info1.edge)) {
          info2.dist = dist2;
          info2.pred = node1;
          info2.edge = edge2;
          replacedEdge = true;
        }
      };
      for (var _i = 1; _i < numNodes; _i++) {
        replacedEdge = false;
        for (var e = 0; e < numEdges; e++) {
          var edge = edges[e];
          var src = edge.source();
          var tgt = edge.target();
          var _weight = weightFn(edge);
          var srcInfo = getInfo2(src);
          var tgtInfo = getInfo2(tgt);
          checkForEdgeReplacement(src, tgt, edge, srcInfo, tgtInfo, _weight);
          if (!directed) {
            checkForEdgeReplacement(tgt, src, edge, tgtInfo, srcInfo, _weight);
          }
        }
        if (!replacedEdge) {
          break;
        }
      }
      if (replacedEdge) {
        var negativeWeightCycleIds = [];
        for (var _e = 0; _e < numEdges; _e++) {
          var _edge = edges[_e];
          var _src = _edge.source();
          var _tgt = _edge.target();
          var _weight2 = weightFn(_edge);
          var srcDist = getInfo2(_src).dist;
          var tgtDist = getInfo2(_tgt).dist;
          if (srcDist + _weight2 < tgtDist || !directed && tgtDist + _weight2 < srcDist) {
            if (!hasNegativeWeightCycle) {
              warn("Graph contains a negative weight cycle for Bellman-Ford");
              hasNegativeWeightCycle = true;
            }
            if (options.findNegativeWeightCycles !== false) {
              var negativeNodes = [];
              if (srcDist + _weight2 < tgtDist) {
                negativeNodes.push(_src);
              }
              if (!directed && tgtDist + _weight2 < srcDist) {
                negativeNodes.push(_tgt);
              }
              var numNegativeNodes = negativeNodes.length;
              for (var n = 0; n < numNegativeNodes; n++) {
                var start2 = negativeNodes[n];
                var cycle = [start2];
                cycle.push(getInfo2(start2).edge);
                var _node = getInfo2(start2).pred;
                while (cycle.indexOf(_node) === -1) {
                  cycle.push(_node);
                  cycle.push(getInfo2(_node).edge);
                  _node = getInfo2(_node).pred;
                }
                cycle = cycle.slice(cycle.indexOf(_node));
                var smallestId = cycle[0].id();
                var smallestIndex = 0;
                for (var c = 2; c < cycle.length; c += 2) {
                  if (cycle[c].id() < smallestId) {
                    smallestId = cycle[c].id();
                    smallestIndex = c;
                  }
                }
                cycle = cycle.slice(smallestIndex).concat(cycle.slice(0, smallestIndex));
                cycle.push(cycle[0]);
                var cycleId = cycle.map(function(el) {
                  return el.id();
                }).join(",");
                if (negativeWeightCycleIds.indexOf(cycleId) === -1) {
                  negativeWeightCycles.push(eles.spawn(cycle));
                  negativeWeightCycleIds.push(cycleId);
                }
              }
            } else {
              break;
            }
          }
        }
      }
      return {
        distanceTo,
        pathTo,
        hasNegativeWeightCycle,
        negativeWeightCycles
      };
    }
  };
  var sqrt2 = Math.sqrt(2);
  var collapse = function collapse2(edgeIndex, nodeMap, remainingEdges) {
    if (remainingEdges.length === 0) {
      error("Karger-Stein must be run on a connected (sub)graph");
    }
    var edgeInfo = remainingEdges[edgeIndex];
    var sourceIn = edgeInfo[1];
    var targetIn = edgeInfo[2];
    var partition1 = nodeMap[sourceIn];
    var partition2 = nodeMap[targetIn];
    var newEdges = remainingEdges;
    for (var i2 = newEdges.length - 1; i2 >= 0; i2--) {
      var edge = newEdges[i2];
      var src = edge[1];
      var tgt = edge[2];
      if (nodeMap[src] === partition1 && nodeMap[tgt] === partition2 || nodeMap[src] === partition2 && nodeMap[tgt] === partition1) {
        newEdges.splice(i2, 1);
      }
    }
    for (var _i = 0; _i < newEdges.length; _i++) {
      var _edge = newEdges[_i];
      if (_edge[1] === partition2) {
        newEdges[_i] = _edge.slice();
        newEdges[_i][1] = partition1;
      } else if (_edge[2] === partition2) {
        newEdges[_i] = _edge.slice();
        newEdges[_i][2] = partition1;
      }
    }
    for (var _i2 = 0; _i2 < nodeMap.length; _i2++) {
      if (nodeMap[_i2] === partition2) {
        nodeMap[_i2] = partition1;
      }
    }
    return newEdges;
  };
  var contractUntil = function contractUntil2(metaNodeMap, remainingEdges, size, sizeLimit) {
    while (size > sizeLimit) {
      var edgeIndex = Math.floor(Math.random() * remainingEdges.length);
      remainingEdges = collapse(edgeIndex, metaNodeMap, remainingEdges);
      size--;
    }
    return remainingEdges;
  };
  var elesfn$p = {
    kargerStein: function kargerStein() {
      var _this = this;
      var _this$byGroup = this.byGroup(), nodes2 = _this$byGroup.nodes, edges = _this$byGroup.edges;
      edges.unmergeBy(function(edge) {
        return edge.isLoop();
      });
      var numNodes = nodes2.length;
      var numEdges = edges.length;
      var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));
      var stopSize = Math.floor(numNodes / sqrt2);
      if (numNodes < 2) {
        error("At least 2 nodes are required for Karger-Stein algorithm");
        return void 0;
      }
      var edgeIndexes = [];
      for (var i2 = 0; i2 < numEdges; i2++) {
        var e = edges[i2];
        edgeIndexes.push([i2, nodes2.indexOf(e.source()), nodes2.indexOf(e.target())]);
      }
      var minCutSize = Infinity;
      var minCutEdgeIndexes = [];
      var minCutNodeMap = new Array(numNodes);
      var metaNodeMap = new Array(numNodes);
      var metaNodeMap2 = new Array(numNodes);
      var copyNodesMap = function copyNodesMap2(from, to) {
        for (var _i3 = 0; _i3 < numNodes; _i3++) {
          to[_i3] = from[_i3];
        }
      };
      for (var iter = 0; iter <= numIter; iter++) {
        for (var _i4 = 0; _i4 < numNodes; _i4++) {
          metaNodeMap[_i4] = _i4;
        }
        var edgesState = contractUntil(metaNodeMap, edgeIndexes.slice(), numNodes, stopSize);
        var edgesState2 = edgesState.slice();
        copyNodesMap(metaNodeMap, metaNodeMap2);
        var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);
        var res2 = contractUntil(metaNodeMap2, edgesState2, stopSize, 2);
        if (res1.length <= res2.length && res1.length < minCutSize) {
          minCutSize = res1.length;
          minCutEdgeIndexes = res1;
          copyNodesMap(metaNodeMap, minCutNodeMap);
        } else if (res2.length <= res1.length && res2.length < minCutSize) {
          minCutSize = res2.length;
          minCutEdgeIndexes = res2;
          copyNodesMap(metaNodeMap2, minCutNodeMap);
        }
      }
      var cut = this.spawn(minCutEdgeIndexes.map(function(e2) {
        return edges[e2[0]];
      }));
      var partition1 = this.spawn();
      var partition2 = this.spawn();
      var witnessNodePartition = minCutNodeMap[0];
      for (var _i5 = 0; _i5 < minCutNodeMap.length; _i5++) {
        var partitionId = minCutNodeMap[_i5];
        var node = nodes2[_i5];
        if (partitionId === witnessNodePartition) {
          partition1.merge(node);
        } else {
          partition2.merge(node);
        }
      }
      var constructComponent = function constructComponent2(subset) {
        var component = _this.spawn();
        subset.forEach(function(node2) {
          component.merge(node2);
          node2.connectedEdges().forEach(function(edge) {
            if (_this.contains(edge) && !cut.contains(edge)) {
              component.merge(edge);
            }
          });
        });
        return component;
      };
      var components = [constructComponent(partition1), constructComponent(partition2)];
      var ret = {
        cut,
        components,
        partition1,
        partition2
      };
      return ret;
    }
  };
  var copyPosition = function copyPosition2(p2) {
    return {
      x: p2.x,
      y: p2.y
    };
  };
  var modelToRenderedPosition = function modelToRenderedPosition2(p2, zoom, pan) {
    return {
      x: p2.x * zoom + pan.x,
      y: p2.y * zoom + pan.y
    };
  };
  var renderedToModelPosition = function renderedToModelPosition2(p2, zoom, pan) {
    return {
      x: (p2.x - pan.x) / zoom,
      y: (p2.y - pan.y) / zoom
    };
  };
  var array2point = function array2point2(arr) {
    return {
      x: arr[0],
      y: arr[1]
    };
  };
  var min = function min2(arr) {
    var begin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var end = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : arr.length;
    var min3 = Infinity;
    for (var i2 = begin; i2 < end; i2++) {
      var val = arr[i2];
      if (isFinite(val)) {
        min3 = Math.min(val, min3);
      }
    }
    return min3;
  };
  var max = function max2(arr) {
    var begin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var end = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : arr.length;
    var max3 = -Infinity;
    for (var i2 = begin; i2 < end; i2++) {
      var val = arr[i2];
      if (isFinite(val)) {
        max3 = Math.max(val, max3);
      }
    }
    return max3;
  };
  var mean = function mean2(arr) {
    var begin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var end = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : arr.length;
    var total = 0;
    var n = 0;
    for (var i2 = begin; i2 < end; i2++) {
      var val = arr[i2];
      if (isFinite(val)) {
        total += val;
        n++;
      }
    }
    return total / n;
  };
  var median = function median2(arr) {
    var begin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var end = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : arr.length;
    var copy2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
    var sort = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
    var includeHoles = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
    if (copy2) {
      arr = arr.slice(begin, end);
    } else {
      if (end < arr.length) {
        arr.splice(end, arr.length - end);
      }
      if (begin > 0) {
        arr.splice(0, begin);
      }
    }
    var off = 0;
    for (var i2 = arr.length - 1; i2 >= 0; i2--) {
      var v = arr[i2];
      if (includeHoles) {
        if (!isFinite(v)) {
          arr[i2] = -Infinity;
          off++;
        }
      } else {
        arr.splice(i2, 1);
      }
    }
    if (sort) {
      arr.sort(function(a, b) {
        return a - b;
      });
    }
    var len = arr.length;
    var mid = Math.floor(len / 2);
    if (len % 2 !== 0) {
      return arr[mid + 1 + off];
    } else {
      return (arr[mid - 1 + off] + arr[mid + off]) / 2;
    }
  };
  var deg2rad = function deg2rad2(deg) {
    return Math.PI * deg / 180;
  };
  var getAngleFromDisp = function getAngleFromDisp2(dispX, dispY) {
    return Math.atan2(dispY, dispX) - Math.PI / 2;
  };
  var log2 = Math.log2 || function(n) {
    return Math.log(n) / Math.log(2);
  };
  var signum = function signum2(x) {
    if (x > 0) {
      return 1;
    } else if (x < 0) {
      return -1;
    } else {
      return 0;
    }
  };
  var dist = function dist2(p1, p2) {
    return Math.sqrt(sqdist(p1, p2));
  };
  var sqdist = function sqdist2(p1, p2) {
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;
    return dx * dx + dy * dy;
  };
  var inPlaceSumNormalize = function inPlaceSumNormalize2(v) {
    var length = v.length;
    var total = 0;
    for (var i2 = 0; i2 < length; i2++) {
      total += v[i2];
    }
    for (var _i = 0; _i < length; _i++) {
      v[_i] = v[_i] / total;
    }
    return v;
  };
  var qbezierAt = function qbezierAt2(p0, p1, p2, t) {
    return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;
  };
  var qbezierPtAt = function qbezierPtAt2(p0, p1, p2, t) {
    return {
      x: qbezierAt(p0.x, p1.x, p2.x, t),
      y: qbezierAt(p0.y, p1.y, p2.y, t)
    };
  };
  var lineAt = function lineAt2(p0, p1, t, d) {
    var vec = {
      x: p1.x - p0.x,
      y: p1.y - p0.y
    };
    var vecDist = dist(p0, p1);
    var normVec = {
      x: vec.x / vecDist,
      y: vec.y / vecDist
    };
    t = t == null ? 0 : t;
    d = d != null ? d : t * vecDist;
    return {
      x: p0.x + normVec.x * d,
      y: p0.y + normVec.y * d
    };
  };
  var bound = function bound2(min2, val, max2) {
    return Math.max(min2, Math.min(max2, val));
  };
  var makeBoundingBox = function makeBoundingBox2(bb) {
    if (bb == null) {
      return {
        x1: Infinity,
        y1: Infinity,
        x2: -Infinity,
        y2: -Infinity,
        w: 0,
        h: 0
      };
    } else if (bb.x1 != null && bb.y1 != null) {
      if (bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1) {
        return {
          x1: bb.x1,
          y1: bb.y1,
          x2: bb.x2,
          y2: bb.y2,
          w: bb.x2 - bb.x1,
          h: bb.y2 - bb.y1
        };
      } else if (bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0) {
        return {
          x1: bb.x1,
          y1: bb.y1,
          x2: bb.x1 + bb.w,
          y2: bb.y1 + bb.h,
          w: bb.w,
          h: bb.h
        };
      }
    }
  };
  var copyBoundingBox = function copyBoundingBox2(bb) {
    return {
      x1: bb.x1,
      x2: bb.x2,
      w: bb.w,
      y1: bb.y1,
      y2: bb.y2,
      h: bb.h
    };
  };
  var clearBoundingBox = function clearBoundingBox2(bb) {
    bb.x1 = Infinity;
    bb.y1 = Infinity;
    bb.x2 = -Infinity;
    bb.y2 = -Infinity;
    bb.w = 0;
    bb.h = 0;
  };
  var updateBoundingBox = function updateBoundingBox2(bb1, bb2) {
    bb1.x1 = Math.min(bb1.x1, bb2.x1);
    bb1.x2 = Math.max(bb1.x2, bb2.x2);
    bb1.w = bb1.x2 - bb1.x1;
    bb1.y1 = Math.min(bb1.y1, bb2.y1);
    bb1.y2 = Math.max(bb1.y2, bb2.y2);
    bb1.h = bb1.y2 - bb1.y1;
  };
  var expandBoundingBoxByPoint = function expandBoundingBoxByPoint2(bb, x, y) {
    bb.x1 = Math.min(bb.x1, x);
    bb.x2 = Math.max(bb.x2, x);
    bb.w = bb.x2 - bb.x1;
    bb.y1 = Math.min(bb.y1, y);
    bb.y2 = Math.max(bb.y2, y);
    bb.h = bb.y2 - bb.y1;
  };
  var expandBoundingBox = function expandBoundingBox2(bb) {
    var padding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    bb.x1 -= padding;
    bb.x2 += padding;
    bb.y1 -= padding;
    bb.y2 += padding;
    bb.w = bb.x2 - bb.x1;
    bb.h = bb.y2 - bb.y1;
    return bb;
  };
  var expandBoundingBoxSides = function expandBoundingBoxSides2(bb) {
    var padding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0];
    var top, right, bottom, left;
    if (padding.length === 1) {
      top = right = bottom = left = padding[0];
    } else if (padding.length === 2) {
      top = bottom = padding[0];
      left = right = padding[1];
    } else if (padding.length === 4) {
      var _padding = _slicedToArray(padding, 4);
      top = _padding[0];
      right = _padding[1];
      bottom = _padding[2];
      left = _padding[3];
    }
    bb.x1 -= left;
    bb.x2 += right;
    bb.y1 -= top;
    bb.y2 += bottom;
    bb.w = bb.x2 - bb.x1;
    bb.h = bb.y2 - bb.y1;
    return bb;
  };
  var assignBoundingBox = function assignBoundingBox2(bb1, bb2) {
    bb1.x1 = bb2.x1;
    bb1.y1 = bb2.y1;
    bb1.x2 = bb2.x2;
    bb1.y2 = bb2.y2;
    bb1.w = bb1.x2 - bb1.x1;
    bb1.h = bb1.y2 - bb1.y1;
  };
  var boundingBoxesIntersect = function boundingBoxesIntersect2(bb1, bb2) {
    if (bb1.x1 > bb2.x2) {
      return false;
    }
    if (bb2.x1 > bb1.x2) {
      return false;
    }
    if (bb1.x2 < bb2.x1) {
      return false;
    }
    if (bb2.x2 < bb1.x1) {
      return false;
    }
    if (bb1.y2 < bb2.y1) {
      return false;
    }
    if (bb2.y2 < bb1.y1) {
      return false;
    }
    if (bb1.y1 > bb2.y2) {
      return false;
    }
    if (bb2.y1 > bb1.y2) {
      return false;
    }
    return true;
  };
  var inBoundingBox = function inBoundingBox2(bb, x, y) {
    return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;
  };
  var pointInBoundingBox = function pointInBoundingBox2(bb, pt) {
    return inBoundingBox(bb, pt.x, pt.y);
  };
  var boundingBoxInBoundingBox = function boundingBoxInBoundingBox2(bb1, bb2) {
    return inBoundingBox(bb1, bb2.x1, bb2.y1) && inBoundingBox(bb1, bb2.x2, bb2.y2);
  };
  var roundRectangleIntersectLine = function roundRectangleIntersectLine2(x, y, nodeX, nodeY, width, height, padding) {
    var cornerRadius = getRoundRectangleRadius(width, height);
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var straightLineIntersections;
    {
      var topStartX = nodeX - halfWidth + cornerRadius - padding;
      var topStartY = nodeY - halfHeight - padding;
      var topEndX = nodeX + halfWidth - cornerRadius + padding;
      var topEndY = topStartY;
      straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);
      if (straightLineIntersections.length > 0) {
        return straightLineIntersections;
      }
    }
    {
      var rightStartX = nodeX + halfWidth + padding;
      var rightStartY = nodeY - halfHeight + cornerRadius - padding;
      var rightEndX = rightStartX;
      var rightEndY = nodeY + halfHeight - cornerRadius + padding;
      straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);
      if (straightLineIntersections.length > 0) {
        return straightLineIntersections;
      }
    }
    {
      var bottomStartX = nodeX - halfWidth + cornerRadius - padding;
      var bottomStartY = nodeY + halfHeight + padding;
      var bottomEndX = nodeX + halfWidth - cornerRadius + padding;
      var bottomEndY = bottomStartY;
      straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);
      if (straightLineIntersections.length > 0) {
        return straightLineIntersections;
      }
    }
    {
      var leftStartX = nodeX - halfWidth - padding;
      var leftStartY = nodeY - halfHeight + cornerRadius - padding;
      var leftEndX = leftStartX;
      var leftEndY = nodeY + halfHeight - cornerRadius + padding;
      straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);
      if (straightLineIntersections.length > 0) {
        return straightLineIntersections;
      }
    }
    var arcIntersections;
    {
      var topLeftCenterX = nodeX - halfWidth + cornerRadius;
      var topLeftCenterY = nodeY - halfHeight + cornerRadius;
      arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topLeftCenterX, topLeftCenterY, cornerRadius + padding);
      if (arcIntersections.length > 0 && arcIntersections[0] <= topLeftCenterX && arcIntersections[1] <= topLeftCenterY) {
        return [arcIntersections[0], arcIntersections[1]];
      }
    }
    {
      var topRightCenterX = nodeX + halfWidth - cornerRadius;
      var topRightCenterY = nodeY - halfHeight + cornerRadius;
      arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topRightCenterX, topRightCenterY, cornerRadius + padding);
      if (arcIntersections.length > 0 && arcIntersections[0] >= topRightCenterX && arcIntersections[1] <= topRightCenterY) {
        return [arcIntersections[0], arcIntersections[1]];
      }
    }
    {
      var bottomRightCenterX = nodeX + halfWidth - cornerRadius;
      var bottomRightCenterY = nodeY + halfHeight - cornerRadius;
      arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomRightCenterX, bottomRightCenterY, cornerRadius + padding);
      if (arcIntersections.length > 0 && arcIntersections[0] >= bottomRightCenterX && arcIntersections[1] >= bottomRightCenterY) {
        return [arcIntersections[0], arcIntersections[1]];
      }
    }
    {
      var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;
      var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;
      arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding);
      if (arcIntersections.length > 0 && arcIntersections[0] <= bottomLeftCenterX && arcIntersections[1] >= bottomLeftCenterY) {
        return [arcIntersections[0], arcIntersections[1]];
      }
    }
    return [];
  };
  var inLineVicinity = function inLineVicinity2(x, y, lx1, ly1, lx2, ly2, tolerance) {
    var t = tolerance;
    var x1 = Math.min(lx1, lx2);
    var x2 = Math.max(lx1, lx2);
    var y1 = Math.min(ly1, ly2);
    var y2 = Math.max(ly1, ly2);
    return x1 - t <= x && x <= x2 + t && y1 - t <= y && y <= y2 + t;
  };
  var inBezierVicinity = function inBezierVicinity2(x, y, x1, y1, x2, y2, x3, y3, tolerance) {
    var bb = {
      x1: Math.min(x1, x3, x2) - tolerance,
      x2: Math.max(x1, x3, x2) + tolerance,
      y1: Math.min(y1, y3, y2) - tolerance,
      y2: Math.max(y1, y3, y2) + tolerance
    };
    if (x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2) {
      return false;
    } else {
      return true;
    }
  };
  var solveQuadratic = function solveQuadratic2(a, b, c, val) {
    c -= val;
    var r = b * b - 4 * a * c;
    if (r < 0) {
      return [];
    }
    var sqrtR = Math.sqrt(r);
    var denom = 2 * a;
    var root1 = (-b + sqrtR) / denom;
    var root2 = (-b - sqrtR) / denom;
    return [root1, root2];
  };
  var solveCubic = function solveCubic2(a, b, c, d, result) {
    var epsilon = 1e-5;
    if (a === 0) {
      a = epsilon;
    }
    b /= a;
    c /= a;
    d /= a;
    var discriminant, q, r, dum1, s, t, term1, r13;
    q = (3 * c - b * b) / 9;
    r = -(27 * d) + b * (9 * c - 2 * (b * b));
    r /= 54;
    discriminant = q * q * q + r * r;
    result[1] = 0;
    term1 = b / 3;
    if (discriminant > 0) {
      s = r + Math.sqrt(discriminant);
      s = s < 0 ? -Math.pow(-s, 1 / 3) : Math.pow(s, 1 / 3);
      t = r - Math.sqrt(discriminant);
      t = t < 0 ? -Math.pow(-t, 1 / 3) : Math.pow(t, 1 / 3);
      result[0] = -term1 + s + t;
      term1 += (s + t) / 2;
      result[4] = result[2] = -term1;
      term1 = Math.sqrt(3) * (-t + s) / 2;
      result[3] = term1;
      result[5] = -term1;
      return;
    }
    result[5] = result[3] = 0;
    if (discriminant === 0) {
      r13 = r < 0 ? -Math.pow(-r, 1 / 3) : Math.pow(r, 1 / 3);
      result[0] = -term1 + 2 * r13;
      result[4] = result[2] = -(r13 + term1);
      return;
    }
    q = -q;
    dum1 = q * q * q;
    dum1 = Math.acos(r / Math.sqrt(dum1));
    r13 = 2 * Math.sqrt(q);
    result[0] = -term1 + r13 * Math.cos(dum1 / 3);
    result[2] = -term1 + r13 * Math.cos((dum1 + 2 * Math.PI) / 3);
    result[4] = -term1 + r13 * Math.cos((dum1 + 4 * Math.PI) / 3);
    return;
  };
  var sqdistToQuadraticBezier = function sqdistToQuadraticBezier2(x, y, x1, y1, x2, y2, x3, y3) {
    var a = 1 * x1 * x1 - 4 * x1 * x2 + 2 * x1 * x3 + 4 * x2 * x2 - 4 * x2 * x3 + x3 * x3 + y1 * y1 - 4 * y1 * y2 + 2 * y1 * y3 + 4 * y2 * y2 - 4 * y2 * y3 + y3 * y3;
    var b = 1 * 9 * x1 * x2 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x2 * x2 + 3 * x2 * x3 + 9 * y1 * y2 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y2 * y2 + 3 * y2 * y3;
    var c = 1 * 3 * x1 * x1 - 6 * x1 * x2 + x1 * x3 - x1 * x + 2 * x2 * x2 + 2 * x2 * x - x3 * x + 3 * y1 * y1 - 6 * y1 * y2 + y1 * y3 - y1 * y + 2 * y2 * y2 + 2 * y2 * y - y3 * y;
    var d = 1 * x1 * x2 - x1 * x1 + x1 * x - x2 * x + y1 * y2 - y1 * y1 + y1 * y - y2 * y;
    var roots = [];
    solveCubic(a, b, c, d, roots);
    var zeroThreshold = 1e-7;
    var params = [];
    for (var index = 0; index < 6; index += 2) {
      if (Math.abs(roots[index + 1]) < zeroThreshold && roots[index] >= 0 && roots[index] <= 1) {
        params.push(roots[index]);
      }
    }
    params.push(1);
    params.push(0);
    var minDistanceSquared = -1;
    var curX, curY, distSquared;
    for (var i2 = 0; i2 < params.length; i2++) {
      curX = Math.pow(1 - params[i2], 2) * x1 + 2 * (1 - params[i2]) * params[i2] * x2 + params[i2] * params[i2] * x3;
      curY = Math.pow(1 - params[i2], 2) * y1 + 2 * (1 - params[i2]) * params[i2] * y2 + params[i2] * params[i2] * y3;
      distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2);
      if (minDistanceSquared >= 0) {
        if (distSquared < minDistanceSquared) {
          minDistanceSquared = distSquared;
        }
      } else {
        minDistanceSquared = distSquared;
      }
    }
    return minDistanceSquared;
  };
  var sqdistToFiniteLine = function sqdistToFiniteLine2(x, y, x1, y1, x2, y2) {
    var offset = [x - x1, y - y1];
    var line = [x2 - x1, y2 - y1];
    var lineSq = line[0] * line[0] + line[1] * line[1];
    var hypSq = offset[0] * offset[0] + offset[1] * offset[1];
    var dotProduct = offset[0] * line[0] + offset[1] * line[1];
    var adjSq = dotProduct * dotProduct / lineSq;
    if (dotProduct < 0) {
      return hypSq;
    }
    if (adjSq > lineSq) {
      return (x - x2) * (x - x2) + (y - y2) * (y - y2);
    }
    return hypSq - adjSq;
  };
  var pointInsidePolygonPoints = function pointInsidePolygonPoints2(x, y, points) {
    var x1, y1, x2, y2;
    var y3;
    var up = 0;
    for (var i2 = 0; i2 < points.length / 2; i2++) {
      x1 = points[i2 * 2];
      y1 = points[i2 * 2 + 1];
      if (i2 + 1 < points.length / 2) {
        x2 = points[(i2 + 1) * 2];
        y2 = points[(i2 + 1) * 2 + 1];
      } else {
        x2 = points[(i2 + 1 - points.length / 2) * 2];
        y2 = points[(i2 + 1 - points.length / 2) * 2 + 1];
      }
      if (x1 == x && x2 == x)
        ;
      else if (x1 >= x && x >= x2 || x1 <= x && x <= x2) {
        y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;
        if (y3 > y) {
          up++;
        }
      } else {
        continue;
      }
    }
    if (up % 2 === 0) {
      return false;
    } else {
      return true;
    }
  };
  var pointInsidePolygon = function pointInsidePolygon2(x, y, basePoints, centerX, centerY, width, height, direction, padding) {
    var transformedPoints = new Array(basePoints.length);
    var angle;
    if (direction[0] != null) {
      angle = Math.atan(direction[1] / direction[0]);
      if (direction[0] < 0) {
        angle = angle + Math.PI / 2;
      } else {
        angle = -angle - Math.PI / 2;
      }
    } else {
      angle = direction;
    }
    var cos2 = Math.cos(-angle);
    var sin2 = Math.sin(-angle);
    for (var i2 = 0; i2 < transformedPoints.length / 2; i2++) {
      transformedPoints[i2 * 2] = width / 2 * (basePoints[i2 * 2] * cos2 - basePoints[i2 * 2 + 1] * sin2);
      transformedPoints[i2 * 2 + 1] = height / 2 * (basePoints[i2 * 2 + 1] * cos2 + basePoints[i2 * 2] * sin2);
      transformedPoints[i2 * 2] += centerX;
      transformedPoints[i2 * 2 + 1] += centerY;
    }
    var points;
    if (padding > 0) {
      var expandedLineSet = expandPolygon(transformedPoints, -padding);
      points = joinLines(expandedLineSet);
    } else {
      points = transformedPoints;
    }
    return pointInsidePolygonPoints(x, y, points);
  };
  var pointInsideRoundPolygon = function pointInsideRoundPolygon2(x, y, basePoints, centerX, centerY, width, height) {
    var cutPolygonPoints = new Array(basePoints.length);
    var halfW = width / 2;
    var halfH = height / 2;
    var cornerRadius = getRoundPolygonRadius(width, height);
    var squaredCornerRadius = cornerRadius * cornerRadius;
    for (var i2 = 0; i2 < basePoints.length / 4; i2++) {
      var sourceUv = void 0, destUv = void 0;
      if (i2 === 0) {
        sourceUv = basePoints.length - 2;
      } else {
        sourceUv = i2 * 4 - 2;
      }
      destUv = i2 * 4 + 2;
      var px = centerX + halfW * basePoints[i2 * 4];
      var py = centerY + halfH * basePoints[i2 * 4 + 1];
      var cosTheta = -basePoints[sourceUv] * basePoints[destUv] - basePoints[sourceUv + 1] * basePoints[destUv + 1];
      var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);
      var cp0x = px - offset * basePoints[sourceUv];
      var cp0y = py - offset * basePoints[sourceUv + 1];
      var cp1x = px + offset * basePoints[destUv];
      var cp1y = py + offset * basePoints[destUv + 1];
      cutPolygonPoints[i2 * 4] = cp0x;
      cutPolygonPoints[i2 * 4 + 1] = cp0y;
      cutPolygonPoints[i2 * 4 + 2] = cp1x;
      cutPolygonPoints[i2 * 4 + 3] = cp1y;
      var orthx = basePoints[sourceUv + 1];
      var orthy = -basePoints[sourceUv];
      var cosAlpha = orthx * basePoints[destUv] + orthy * basePoints[destUv + 1];
      if (cosAlpha < 0) {
        orthx *= -1;
        orthy *= -1;
      }
      var cx = cp0x + orthx * cornerRadius;
      var cy = cp0y + orthy * cornerRadius;
      var squaredDistance = Math.pow(cx - x, 2) + Math.pow(cy - y, 2);
      if (squaredDistance <= squaredCornerRadius) {
        return true;
      }
    }
    return pointInsidePolygonPoints(x, y, cutPolygonPoints);
  };
  var joinLines = function joinLines2(lineSet) {
    var vertices = new Array(lineSet.length / 2);
    var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;
    var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;
    for (var i2 = 0; i2 < lineSet.length / 4; i2++) {
      currentLineStartX = lineSet[i2 * 4];
      currentLineStartY = lineSet[i2 * 4 + 1];
      currentLineEndX = lineSet[i2 * 4 + 2];
      currentLineEndY = lineSet[i2 * 4 + 3];
      if (i2 < lineSet.length / 4 - 1) {
        nextLineStartX = lineSet[(i2 + 1) * 4];
        nextLineStartY = lineSet[(i2 + 1) * 4 + 1];
        nextLineEndX = lineSet[(i2 + 1) * 4 + 2];
        nextLineEndY = lineSet[(i2 + 1) * 4 + 3];
      } else {
        nextLineStartX = lineSet[0];
        nextLineStartY = lineSet[1];
        nextLineEndX = lineSet[2];
        nextLineEndY = lineSet[3];
      }
      var intersection = finiteLinesIntersect(currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY, nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY, true);
      vertices[i2 * 2] = intersection[0];
      vertices[i2 * 2 + 1] = intersection[1];
    }
    return vertices;
  };
  var expandPolygon = function expandPolygon2(points, pad) {
    var expandedLineSet = new Array(points.length * 2);
    var currentPointX, currentPointY, nextPointX, nextPointY;
    for (var i2 = 0; i2 < points.length / 2; i2++) {
      currentPointX = points[i2 * 2];
      currentPointY = points[i2 * 2 + 1];
      if (i2 < points.length / 2 - 1) {
        nextPointX = points[(i2 + 1) * 2];
        nextPointY = points[(i2 + 1) * 2 + 1];
      } else {
        nextPointX = points[0];
        nextPointY = points[1];
      }
      var offsetX = nextPointY - currentPointY;
      var offsetY = -(nextPointX - currentPointX);
      var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
      var normalizedOffsetX = offsetX / offsetLength;
      var normalizedOffsetY = offsetY / offsetLength;
      expandedLineSet[i2 * 4] = currentPointX + normalizedOffsetX * pad;
      expandedLineSet[i2 * 4 + 1] = currentPointY + normalizedOffsetY * pad;
      expandedLineSet[i2 * 4 + 2] = nextPointX + normalizedOffsetX * pad;
      expandedLineSet[i2 * 4 + 3] = nextPointY + normalizedOffsetY * pad;
    }
    return expandedLineSet;
  };
  var intersectLineEllipse = function intersectLineEllipse2(x, y, centerX, centerY, ellipseWradius, ellipseHradius) {
    var dispX = centerX - x;
    var dispY = centerY - y;
    dispX /= ellipseWradius;
    dispY /= ellipseHradius;
    var len = Math.sqrt(dispX * dispX + dispY * dispY);
    var newLength = len - 1;
    if (newLength < 0) {
      return [];
    }
    var lenProportion = newLength / len;
    return [(centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y];
  };
  var checkInEllipse = function checkInEllipse2(x, y, width, height, centerX, centerY, padding) {
    x -= centerX;
    y -= centerY;
    x /= width / 2 + padding;
    y /= height / 2 + padding;
    return x * x + y * y <= 1;
  };
  var intersectLineCircle = function intersectLineCircle2(x1, y1, x2, y2, centerX, centerY, radius) {
    var d = [x2 - x1, y2 - y1];
    var f = [x1 - centerX, y1 - centerY];
    var a = d[0] * d[0] + d[1] * d[1];
    var b = 2 * (f[0] * d[0] + f[1] * d[1]);
    var c = f[0] * f[0] + f[1] * f[1] - radius * radius;
    var discriminant = b * b - 4 * a * c;
    if (discriminant < 0) {
      return [];
    }
    var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);
    var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);
    var tMin = Math.min(t1, t2);
    var tMax = Math.max(t1, t2);
    var inRangeParams = [];
    if (tMin >= 0 && tMin <= 1) {
      inRangeParams.push(tMin);
    }
    if (tMax >= 0 && tMax <= 1) {
      inRangeParams.push(tMax);
    }
    if (inRangeParams.length === 0) {
      return [];
    }
    var nearIntersectionX = inRangeParams[0] * d[0] + x1;
    var nearIntersectionY = inRangeParams[0] * d[1] + y1;
    if (inRangeParams.length > 1) {
      if (inRangeParams[0] == inRangeParams[1]) {
        return [nearIntersectionX, nearIntersectionY];
      } else {
        var farIntersectionX = inRangeParams[1] * d[0] + x1;
        var farIntersectionY = inRangeParams[1] * d[1] + y1;
        return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];
      }
    } else {
      return [nearIntersectionX, nearIntersectionY];
    }
  };
  var midOfThree = function midOfThree2(a, b, c) {
    if (b <= a && a <= c || c <= a && a <= b) {
      return a;
    } else if (a <= b && b <= c || c <= b && b <= a) {
      return b;
    } else {
      return c;
    }
  };
  var finiteLinesIntersect = function finiteLinesIntersect2(x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {
    var dx13 = x1 - x3;
    var dx21 = x2 - x1;
    var dx43 = x4 - x3;
    var dy13 = y1 - y3;
    var dy21 = y2 - y1;
    var dy43 = y4 - y3;
    var ua_t = dx43 * dy13 - dy43 * dx13;
    var ub_t = dx21 * dy13 - dy21 * dx13;
    var u_b = dy43 * dx21 - dx43 * dy21;
    if (u_b !== 0) {
      var ua = ua_t / u_b;
      var ub = ub_t / u_b;
      var flptThreshold = 1e-3;
      var _min = 0 - flptThreshold;
      var _max = 1 + flptThreshold;
      if (_min <= ua && ua <= _max && _min <= ub && ub <= _max) {
        return [x1 + ua * dx21, y1 + ua * dy21];
      } else {
        if (!infiniteLines) {
          return [];
        } else {
          return [x1 + ua * dx21, y1 + ua * dy21];
        }
      }
    } else {
      if (ua_t === 0 || ub_t === 0) {
        if (midOfThree(x1, x2, x4) === x4) {
          return [x4, y4];
        }
        if (midOfThree(x1, x2, x3) === x3) {
          return [x3, y3];
        }
        if (midOfThree(x3, x4, x2) === x2) {
          return [x2, y2];
        }
        return [];
      } else {
        return [];
      }
    }
  };
  var polygonIntersectLine = function polygonIntersectLine2(x, y, basePoints, centerX, centerY, width, height, padding) {
    var intersections = [];
    var intersection;
    var transformedPoints = new Array(basePoints.length);
    var doTransform = true;
    if (width == null) {
      doTransform = false;
    }
    var points;
    if (doTransform) {
      for (var i2 = 0; i2 < transformedPoints.length / 2; i2++) {
        transformedPoints[i2 * 2] = basePoints[i2 * 2] * width + centerX;
        transformedPoints[i2 * 2 + 1] = basePoints[i2 * 2 + 1] * height + centerY;
      }
      if (padding > 0) {
        var expandedLineSet = expandPolygon(transformedPoints, -padding);
        points = joinLines(expandedLineSet);
      } else {
        points = transformedPoints;
      }
    } else {
      points = basePoints;
    }
    var currentX, currentY, nextX, nextY;
    for (var _i2 = 0; _i2 < points.length / 2; _i2++) {
      currentX = points[_i2 * 2];
      currentY = points[_i2 * 2 + 1];
      if (_i2 < points.length / 2 - 1) {
        nextX = points[(_i2 + 1) * 2];
        nextY = points[(_i2 + 1) * 2 + 1];
      } else {
        nextX = points[0];
        nextY = points[1];
      }
      intersection = finiteLinesIntersect(x, y, centerX, centerY, currentX, currentY, nextX, nextY);
      if (intersection.length !== 0) {
        intersections.push(intersection[0], intersection[1]);
      }
    }
    return intersections;
  };
  var roundPolygonIntersectLine = function roundPolygonIntersectLine2(x, y, basePoints, centerX, centerY, width, height, padding) {
    var intersections = [];
    var intersection;
    var lines = new Array(basePoints.length);
    var halfW = width / 2;
    var halfH = height / 2;
    var cornerRadius = getRoundPolygonRadius(width, height);
    for (var i2 = 0; i2 < basePoints.length / 4; i2++) {
      var sourceUv = void 0, destUv = void 0;
      if (i2 === 0) {
        sourceUv = basePoints.length - 2;
      } else {
        sourceUv = i2 * 4 - 2;
      }
      destUv = i2 * 4 + 2;
      var px = centerX + halfW * basePoints[i2 * 4];
      var py = centerY + halfH * basePoints[i2 * 4 + 1];
      var cosTheta = -basePoints[sourceUv] * basePoints[destUv] - basePoints[sourceUv + 1] * basePoints[destUv + 1];
      var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);
      var cp0x = px - offset * basePoints[sourceUv];
      var cp0y = py - offset * basePoints[sourceUv + 1];
      var cp1x = px + offset * basePoints[destUv];
      var cp1y = py + offset * basePoints[destUv + 1];
      if (i2 === 0) {
        lines[basePoints.length - 2] = cp0x;
        lines[basePoints.length - 1] = cp0y;
      } else {
        lines[i2 * 4 - 2] = cp0x;
        lines[i2 * 4 - 1] = cp0y;
      }
      lines[i2 * 4] = cp1x;
      lines[i2 * 4 + 1] = cp1y;
      var orthx = basePoints[sourceUv + 1];
      var orthy = -basePoints[sourceUv];
      var cosAlpha = orthx * basePoints[destUv] + orthy * basePoints[destUv + 1];
      if (cosAlpha < 0) {
        orthx *= -1;
        orthy *= -1;
      }
      var cx = cp0x + orthx * cornerRadius;
      var cy = cp0y + orthy * cornerRadius;
      intersection = intersectLineCircle(x, y, centerX, centerY, cx, cy, cornerRadius);
      if (intersection.length !== 0) {
        intersections.push(intersection[0], intersection[1]);
      }
    }
    for (var _i3 = 0; _i3 < lines.length / 4; _i3++) {
      intersection = finiteLinesIntersect(x, y, centerX, centerY, lines[_i3 * 4], lines[_i3 * 4 + 1], lines[_i3 * 4 + 2], lines[_i3 * 4 + 3], false);
      if (intersection.length !== 0) {
        intersections.push(intersection[0], intersection[1]);
      }
    }
    if (intersections.length > 2) {
      var lowestIntersection = [intersections[0], intersections[1]];
      var lowestSquaredDistance = Math.pow(lowestIntersection[0] - x, 2) + Math.pow(lowestIntersection[1] - y, 2);
      for (var _i4 = 1; _i4 < intersections.length / 2; _i4++) {
        var squaredDistance = Math.pow(intersections[_i4 * 2] - x, 2) + Math.pow(intersections[_i4 * 2 + 1] - y, 2);
        if (squaredDistance <= lowestSquaredDistance) {
          lowestIntersection[0] = intersections[_i4 * 2];
          lowestIntersection[1] = intersections[_i4 * 2 + 1];
          lowestSquaredDistance = squaredDistance;
        }
      }
      return lowestIntersection;
    }
    return intersections;
  };
  var shortenIntersection = function shortenIntersection2(intersection, offset, amount) {
    var disp = [intersection[0] - offset[0], intersection[1] - offset[1]];
    var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);
    var lenRatio = (length - amount) / length;
    if (lenRatio < 0) {
      lenRatio = 1e-5;
    }
    return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];
  };
  var generateUnitNgonPointsFitToSquare = function generateUnitNgonPointsFitToSquare2(sides, rotationRadians) {
    var points = generateUnitNgonPoints(sides, rotationRadians);
    points = fitPolygonToSquare(points);
    return points;
  };
  var fitPolygonToSquare = function fitPolygonToSquare2(points) {
    var x, y;
    var sides = points.length / 2;
    var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    for (var i2 = 0; i2 < sides; i2++) {
      x = points[2 * i2];
      y = points[2 * i2 + 1];
      minX = Math.min(minX, x);
      maxX = Math.max(maxX, x);
      minY = Math.min(minY, y);
      maxY = Math.max(maxY, y);
    }
    var sx = 2 / (maxX - minX);
    var sy = 2 / (maxY - minY);
    for (var _i5 = 0; _i5 < sides; _i5++) {
      x = points[2 * _i5] = points[2 * _i5] * sx;
      y = points[2 * _i5 + 1] = points[2 * _i5 + 1] * sy;
      minX = Math.min(minX, x);
      maxX = Math.max(maxX, x);
      minY = Math.min(minY, y);
      maxY = Math.max(maxY, y);
    }
    if (minY < -1) {
      for (var _i6 = 0; _i6 < sides; _i6++) {
        y = points[2 * _i6 + 1] = points[2 * _i6 + 1] + (-1 - minY);
      }
    }
    return points;
  };
  var generateUnitNgonPoints = function generateUnitNgonPoints2(sides, rotationRadians) {
    var increment = 1 / sides * 2 * Math.PI;
    var startAngle = sides % 2 === 0 ? Math.PI / 2 + increment / 2 : Math.PI / 2;
    startAngle += rotationRadians;
    var points = new Array(sides * 2);
    var currentAngle;
    for (var i2 = 0; i2 < sides; i2++) {
      currentAngle = i2 * increment + startAngle;
      points[2 * i2] = Math.cos(currentAngle);
      points[2 * i2 + 1] = Math.sin(-currentAngle);
    }
    return points;
  };
  var getRoundRectangleRadius = function getRoundRectangleRadius2(width, height) {
    return Math.min(width / 4, height / 4, 8);
  };
  var getRoundPolygonRadius = function getRoundPolygonRadius2(width, height) {
    return Math.min(width / 10, height / 10, 8);
  };
  var getCutRectangleCornerLength = function getCutRectangleCornerLength2() {
    return 8;
  };
  var bezierPtsToQuadCoeff = function bezierPtsToQuadCoeff2(p0, p1, p2) {
    return [p0 - 2 * p1 + p2, 2 * (p1 - p0), p0];
  };
  var getBarrelCurveConstants = function getBarrelCurveConstants2(width, height) {
    return {
      heightOffset: Math.min(15, 0.05 * height),
      widthOffset: Math.min(100, 0.25 * width),
      ctrlPtOffsetPct: 0.05
    };
  };
  var pageRankDefaults = defaults$g({
    dampingFactor: 0.8,
    precision: 1e-6,
    iterations: 200,
    weight: function weight(edge) {
      return 1;
    }
  });
  var elesfn$o = {
    pageRank: function pageRank(options) {
      var _pageRankDefaults = pageRankDefaults(options), dampingFactor = _pageRankDefaults.dampingFactor, precision = _pageRankDefaults.precision, iterations = _pageRankDefaults.iterations, weight = _pageRankDefaults.weight;
      var cy = this._private.cy;
      var _this$byGroup = this.byGroup(), nodes2 = _this$byGroup.nodes, edges = _this$byGroup.edges;
      var numNodes = nodes2.length;
      var numNodesSqd = numNodes * numNodes;
      var numEdges = edges.length;
      var matrix = new Array(numNodesSqd);
      var columnSum = new Array(numNodes);
      var additionalProb = (1 - dampingFactor) / numNodes;
      for (var i2 = 0; i2 < numNodes; i2++) {
        for (var j = 0; j < numNodes; j++) {
          var n = i2 * numNodes + j;
          matrix[n] = 0;
        }
        columnSum[i2] = 0;
      }
      for (var _i = 0; _i < numEdges; _i++) {
        var edge = edges[_i];
        var srcId = edge.data("source");
        var tgtId = edge.data("target");
        if (srcId === tgtId) {
          continue;
        }
        var s = nodes2.indexOfId(srcId);
        var t = nodes2.indexOfId(tgtId);
        var w = weight(edge);
        var _n = t * numNodes + s;
        matrix[_n] += w;
        columnSum[s] += w;
      }
      var p2 = 1 / numNodes + additionalProb;
      for (var _j = 0; _j < numNodes; _j++) {
        if (columnSum[_j] === 0) {
          for (var _i2 = 0; _i2 < numNodes; _i2++) {
            var _n2 = _i2 * numNodes + _j;
            matrix[_n2] = p2;
          }
        } else {
          for (var _i3 = 0; _i3 < numNodes; _i3++) {
            var _n3 = _i3 * numNodes + _j;
            matrix[_n3] = matrix[_n3] / columnSum[_j] + additionalProb;
          }
        }
      }
      var eigenvector = new Array(numNodes);
      var temp = new Array(numNodes);
      var previous;
      for (var _i4 = 0; _i4 < numNodes; _i4++) {
        eigenvector[_i4] = 1;
      }
      for (var iter = 0; iter < iterations; iter++) {
        for (var _i5 = 0; _i5 < numNodes; _i5++) {
          temp[_i5] = 0;
        }
        for (var _i6 = 0; _i6 < numNodes; _i6++) {
          for (var _j2 = 0; _j2 < numNodes; _j2++) {
            var _n4 = _i6 * numNodes + _j2;
            temp[_i6] += matrix[_n4] * eigenvector[_j2];
          }
        }
        inPlaceSumNormalize(temp);
        previous = eigenvector;
        eigenvector = temp;
        temp = previous;
        var diff = 0;
        for (var _i7 = 0; _i7 < numNodes; _i7++) {
          var delta = previous[_i7] - eigenvector[_i7];
          diff += delta * delta;
        }
        if (diff < precision) {
          break;
        }
      }
      var res = {
        rank: function rank(node) {
          node = cy.collection(node)[0];
          return eigenvector[nodes2.indexOf(node)];
        }
      };
      return res;
    }
  };
  var defaults$f = defaults$g({
    root: null,
    weight: function weight(edge) {
      return 1;
    },
    directed: false,
    alpha: 0
  });
  var elesfn$n = {
    degreeCentralityNormalized: function degreeCentralityNormalized(options) {
      options = defaults$f(options);
      var cy = this.cy();
      var nodes2 = this.nodes();
      var numNodes = nodes2.length;
      if (!options.directed) {
        var degrees2 = {};
        var maxDegree = 0;
        for (var i2 = 0; i2 < numNodes; i2++) {
          var node = nodes2[i2];
          options.root = node;
          var currDegree = this.degreeCentrality(options);
          if (maxDegree < currDegree.degree) {
            maxDegree = currDegree.degree;
          }
          degrees2[node.id()] = currDegree.degree;
        }
        return {
          degree: function degree(node2) {
            if (maxDegree === 0) {
              return 0;
            }
            if (string(node2)) {
              node2 = cy.filter(node2);
            }
            return degrees2[node2.id()] / maxDegree;
          }
        };
      } else {
        var indegrees = {};
        var outdegrees = {};
        var maxIndegree = 0;
        var maxOutdegree = 0;
        for (var _i = 0; _i < numNodes; _i++) {
          var _node = nodes2[_i];
          var id2 = _node.id();
          options.root = _node;
          var _currDegree = this.degreeCentrality(options);
          if (maxIndegree < _currDegree.indegree)
            maxIndegree = _currDegree.indegree;
          if (maxOutdegree < _currDegree.outdegree)
            maxOutdegree = _currDegree.outdegree;
          indegrees[id2] = _currDegree.indegree;
          outdegrees[id2] = _currDegree.outdegree;
        }
        return {
          indegree: function indegree(node2) {
            if (maxIndegree == 0) {
              return 0;
            }
            if (string(node2)) {
              node2 = cy.filter(node2);
            }
            return indegrees[node2.id()] / maxIndegree;
          },
          outdegree: function outdegree(node2) {
            if (maxOutdegree === 0) {
              return 0;
            }
            if (string(node2)) {
              node2 = cy.filter(node2);
            }
            return outdegrees[node2.id()] / maxOutdegree;
          }
        };
      }
    },
    degreeCentrality: function degreeCentrality(options) {
      options = defaults$f(options);
      var cy = this.cy();
      var callingEles = this;
      var _options = options, root2 = _options.root, weight = _options.weight, directed = _options.directed, alpha = _options.alpha;
      root2 = cy.collection(root2)[0];
      if (!directed) {
        var connEdges = root2.connectedEdges().intersection(callingEles);
        var k = connEdges.length;
        var s = 0;
        for (var i2 = 0; i2 < connEdges.length; i2++) {
          s += weight(connEdges[i2]);
        }
        return {
          degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)
        };
      } else {
        var edges = root2.connectedEdges();
        var incoming = edges.filter(function(edge) {
          return edge.target().same(root2) && callingEles.has(edge);
        });
        var outgoing = edges.filter(function(edge) {
          return edge.source().same(root2) && callingEles.has(edge);
        });
        var k_in = incoming.length;
        var k_out = outgoing.length;
        var s_in = 0;
        var s_out = 0;
        for (var _i2 = 0; _i2 < incoming.length; _i2++) {
          s_in += weight(incoming[_i2]);
        }
        for (var _i3 = 0; _i3 < outgoing.length; _i3++) {
          s_out += weight(outgoing[_i3]);
        }
        return {
          indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),
          outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)
        };
      }
    }
  };
  elesfn$n.dc = elesfn$n.degreeCentrality;
  elesfn$n.dcn = elesfn$n.degreeCentralityNormalised = elesfn$n.degreeCentralityNormalized;
  var defaults$e = defaults$g({
    harmonic: true,
    weight: function weight() {
      return 1;
    },
    directed: false,
    root: null
  });
  var elesfn$m = {
    closenessCentralityNormalized: function closenessCentralityNormalized(options) {
      var _defaults = defaults$e(options), harmonic = _defaults.harmonic, weight = _defaults.weight, directed = _defaults.directed;
      var cy = this.cy();
      var closenesses = {};
      var maxCloseness = 0;
      var nodes2 = this.nodes();
      var fw = this.floydWarshall({
        weight,
        directed
      });
      for (var i2 = 0; i2 < nodes2.length; i2++) {
        var currCloseness = 0;
        var node_i = nodes2[i2];
        for (var j = 0; j < nodes2.length; j++) {
          if (i2 !== j) {
            var d = fw.distance(node_i, nodes2[j]);
            if (harmonic) {
              currCloseness += 1 / d;
            } else {
              currCloseness += d;
            }
          }
        }
        if (!harmonic) {
          currCloseness = 1 / currCloseness;
        }
        if (maxCloseness < currCloseness) {
          maxCloseness = currCloseness;
        }
        closenesses[node_i.id()] = currCloseness;
      }
      return {
        closeness: function closeness(node) {
          if (maxCloseness == 0) {
            return 0;
          }
          if (string(node)) {
            node = cy.filter(node)[0].id();
          } else {
            node = node.id();
          }
          return closenesses[node] / maxCloseness;
        }
      };
    },
    closenessCentrality: function closenessCentrality(options) {
      var _defaults2 = defaults$e(options), root2 = _defaults2.root, weight = _defaults2.weight, directed = _defaults2.directed, harmonic = _defaults2.harmonic;
      root2 = this.filter(root2)[0];
      var dijkstra = this.dijkstra({
        root: root2,
        weight,
        directed
      });
      var totalDistance = 0;
      var nodes2 = this.nodes();
      for (var i2 = 0; i2 < nodes2.length; i2++) {
        var n = nodes2[i2];
        if (!n.same(root2)) {
          var d = dijkstra.distanceTo(n);
          if (harmonic) {
            totalDistance += 1 / d;
          } else {
            totalDistance += d;
          }
        }
      }
      return harmonic ? totalDistance : 1 / totalDistance;
    }
  };
  elesfn$m.cc = elesfn$m.closenessCentrality;
  elesfn$m.ccn = elesfn$m.closenessCentralityNormalised = elesfn$m.closenessCentralityNormalized;
  var defaults$d = defaults$g({
    weight: null,
    directed: false
  });
  var elesfn$l = {
    betweennessCentrality: function betweennessCentrality(options) {
      var _defaults = defaults$d(options), directed = _defaults.directed, weight = _defaults.weight;
      var weighted = weight != null;
      var cy = this.cy();
      var V = this.nodes();
      var A = {};
      var _C = {};
      var max2 = 0;
      var C = {
        set: function set2(key, val) {
          _C[key] = val;
          if (val > max2) {
            max2 = val;
          }
        },
        get: function get2(key) {
          return _C[key];
        }
      };
      for (var i2 = 0; i2 < V.length; i2++) {
        var v = V[i2];
        var vid = v.id();
        if (directed) {
          A[vid] = v.outgoers().nodes();
        } else {
          A[vid] = v.openNeighborhood().nodes();
        }
        C.set(vid, 0);
      }
      var _loop = function _loop2(s2) {
        var sid = V[s2].id();
        var S = [];
        var P = {};
        var g = {};
        var d = {};
        var Q = new Heap__default["default"](function(a, b) {
          return d[a] - d[b];
        });
        for (var _i = 0; _i < V.length; _i++) {
          var _vid = V[_i].id();
          P[_vid] = [];
          g[_vid] = 0;
          d[_vid] = Infinity;
        }
        g[sid] = 1;
        d[sid] = 0;
        Q.push(sid);
        while (!Q.empty()) {
          var _v = Q.pop();
          S.push(_v);
          if (weighted) {
            for (var j = 0; j < A[_v].length; j++) {
              var w = A[_v][j];
              var vEle = cy.getElementById(_v);
              var edge = void 0;
              if (vEle.edgesTo(w).length > 0) {
                edge = vEle.edgesTo(w)[0];
              } else {
                edge = w.edgesTo(vEle)[0];
              }
              var edgeWeight = weight(edge);
              w = w.id();
              if (d[w] > d[_v] + edgeWeight) {
                d[w] = d[_v] + edgeWeight;
                if (Q.nodes.indexOf(w) < 0) {
                  Q.push(w);
                } else {
                  Q.updateItem(w);
                }
                g[w] = 0;
                P[w] = [];
              }
              if (d[w] == d[_v] + edgeWeight) {
                g[w] = g[w] + g[_v];
                P[w].push(_v);
              }
            }
          } else {
            for (var _j = 0; _j < A[_v].length; _j++) {
              var _w = A[_v][_j].id();
              if (d[_w] == Infinity) {
                Q.push(_w);
                d[_w] = d[_v] + 1;
              }
              if (d[_w] == d[_v] + 1) {
                g[_w] = g[_w] + g[_v];
                P[_w].push(_v);
              }
            }
          }
        }
        var e = {};
        for (var _i2 = 0; _i2 < V.length; _i2++) {
          e[V[_i2].id()] = 0;
        }
        while (S.length > 0) {
          var _w2 = S.pop();
          for (var _j2 = 0; _j2 < P[_w2].length; _j2++) {
            var _v2 = P[_w2][_j2];
            e[_v2] = e[_v2] + g[_v2] / g[_w2] * (1 + e[_w2]);
          }
          if (_w2 != V[s2].id()) {
            C.set(_w2, C.get(_w2) + e[_w2]);
          }
        }
      };
      for (var s = 0; s < V.length; s++) {
        _loop(s);
      }
      var ret = {
        betweenness: function betweenness(node) {
          var id2 = cy.collection(node).id();
          return C.get(id2);
        },
        betweennessNormalized: function betweennessNormalized(node) {
          if (max2 == 0) {
            return 0;
          }
          var id2 = cy.collection(node).id();
          return C.get(id2) / max2;
        }
      };
      ret.betweennessNormalised = ret.betweennessNormalized;
      return ret;
    }
  };
  elesfn$l.bc = elesfn$l.betweennessCentrality;
  var defaults$c = defaults$g({
    expandFactor: 2,
    inflateFactor: 2,
    multFactor: 1,
    maxIterations: 20,
    attributes: [
      function(edge) {
        return 1;
      }
    ]
  });
  var setOptions$3 = function setOptions2(options) {
    return defaults$c(options);
  };
  var getSimilarity$1 = function getSimilarity2(edge, attributes) {
    var total = 0;
    for (var i2 = 0; i2 < attributes.length; i2++) {
      total += attributes[i2](edge);
    }
    return total;
  };
  var addLoops = function addLoops2(M, n, val) {
    for (var i2 = 0; i2 < n; i2++) {
      M[i2 * n + i2] = val;
    }
  };
  var normalize = function normalize2(M, n) {
    var sum;
    for (var col = 0; col < n; col++) {
      sum = 0;
      for (var row = 0; row < n; row++) {
        sum += M[row * n + col];
      }
      for (var _row = 0; _row < n; _row++) {
        M[_row * n + col] = M[_row * n + col] / sum;
      }
    }
  };
  var mmult = function mmult2(A, B, n) {
    var C = new Array(n * n);
    for (var i2 = 0; i2 < n; i2++) {
      for (var j = 0; j < n; j++) {
        C[i2 * n + j] = 0;
      }
      for (var k = 0; k < n; k++) {
        for (var _j = 0; _j < n; _j++) {
          C[i2 * n + _j] += A[i2 * n + k] * B[k * n + _j];
        }
      }
    }
    return C;
  };
  var expand = function expand2(M, n, expandFactor) {
    var _M = M.slice(0);
    for (var p2 = 1; p2 < expandFactor; p2++) {
      M = mmult(M, _M, n);
    }
    return M;
  };
  var inflate = function inflate2(M, n, inflateFactor) {
    var _M = new Array(n * n);
    for (var i2 = 0; i2 < n * n; i2++) {
      _M[i2] = Math.pow(M[i2], inflateFactor);
    }
    normalize(_M, n);
    return _M;
  };
  var hasConverged = function hasConverged2(M, _M, n2, roundFactor) {
    for (var i2 = 0; i2 < n2; i2++) {
      var v1 = Math.round(M[i2] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor);
      var v2 = Math.round(_M[i2] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor);
      if (v1 !== v2) {
        return false;
      }
    }
    return true;
  };
  var assign$2 = function assign2(M, n, nodes2, cy) {
    var clusters = [];
    for (var i2 = 0; i2 < n; i2++) {
      var cluster = [];
      for (var j = 0; j < n; j++) {
        if (Math.round(M[i2 * n + j] * 1e3) / 1e3 > 0) {
          cluster.push(nodes2[j]);
        }
      }
      if (cluster.length !== 0) {
        clusters.push(cy.collection(cluster));
      }
    }
    return clusters;
  };
  var isDuplicate = function isDuplicate2(c1, c2) {
    for (var i2 = 0; i2 < c1.length; i2++) {
      if (!c2[i2] || c1[i2].id() !== c2[i2].id()) {
        return false;
      }
    }
    return true;
  };
  var removeDuplicates = function removeDuplicates2(clusters) {
    for (var i2 = 0; i2 < clusters.length; i2++) {
      for (var j = 0; j < clusters.length; j++) {
        if (i2 != j && isDuplicate(clusters[i2], clusters[j])) {
          clusters.splice(j, 1);
        }
      }
    }
    return clusters;
  };
  var markovClustering = function markovClustering2(options) {
    var nodes2 = this.nodes();
    var edges = this.edges();
    var cy = this.cy();
    var opts = setOptions$3(options);
    var id2position = {};
    for (var i2 = 0; i2 < nodes2.length; i2++) {
      id2position[nodes2[i2].id()] = i2;
    }
    var n = nodes2.length, n2 = n * n;
    var M = new Array(n2), _M;
    for (var _i = 0; _i < n2; _i++) {
      M[_i] = 0;
    }
    for (var e = 0; e < edges.length; e++) {
      var edge = edges[e];
      var _i2 = id2position[edge.source().id()];
      var j = id2position[edge.target().id()];
      var sim = getSimilarity$1(edge, opts.attributes);
      M[_i2 * n + j] += sim;
      M[j * n + _i2] += sim;
    }
    addLoops(M, n, opts.multFactor);
    normalize(M, n);
    var isStillMoving = true;
    var iterations = 0;
    while (isStillMoving && iterations < opts.maxIterations) {
      isStillMoving = false;
      _M = expand(M, n, opts.expandFactor);
      M = inflate(_M, n, opts.inflateFactor);
      if (!hasConverged(M, _M, n2, 4)) {
        isStillMoving = true;
      }
      iterations++;
    }
    var clusters = assign$2(M, n, nodes2, cy);
    clusters = removeDuplicates(clusters);
    return clusters;
  };
  var markovClustering$1 = {
    markovClustering,
    mcl: markovClustering
  };
  var identity = function identity2(x) {
    return x;
  };
  var absDiff = function absDiff2(p2, q) {
    return Math.abs(q - p2);
  };
  var addAbsDiff = function addAbsDiff2(total, p2, q) {
    return total + absDiff(p2, q);
  };
  var addSquaredDiff = function addSquaredDiff2(total, p2, q) {
    return total + Math.pow(q - p2, 2);
  };
  var sqrt = function sqrt3(x) {
    return Math.sqrt(x);
  };
  var maxAbsDiff = function maxAbsDiff2(currentMax, p2, q) {
    return Math.max(currentMax, absDiff(p2, q));
  };
  var getDistance = function getDistance2(length, getP, getQ, init2, visit) {
    var post = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : identity;
    var ret = init2;
    var p2, q;
    for (var dim = 0; dim < length; dim++) {
      p2 = getP(dim);
      q = getQ(dim);
      ret = visit(ret, p2, q);
    }
    return post(ret);
  };
  var distances = {
    euclidean: function euclidean(length, getP, getQ) {
      if (length >= 2) {
        return getDistance(length, getP, getQ, 0, addSquaredDiff, sqrt);
      } else {
        return getDistance(length, getP, getQ, 0, addAbsDiff);
      }
    },
    squaredEuclidean: function squaredEuclidean(length, getP, getQ) {
      return getDistance(length, getP, getQ, 0, addSquaredDiff);
    },
    manhattan: function manhattan(length, getP, getQ) {
      return getDistance(length, getP, getQ, 0, addAbsDiff);
    },
    max: function max2(length, getP, getQ) {
      return getDistance(length, getP, getQ, -Infinity, maxAbsDiff);
    }
  };
  distances["squared-euclidean"] = distances["squaredEuclidean"];
  distances["squaredeuclidean"] = distances["squaredEuclidean"];
  function clusteringDistance(method, length, getP, getQ, nodeP, nodeQ) {
    var impl2;
    if (fn$6(method)) {
      impl2 = method;
    } else {
      impl2 = distances[method] || distances.euclidean;
    }
    if (length === 0 && fn$6(method)) {
      return impl2(nodeP, nodeQ);
    } else {
      return impl2(length, getP, getQ, nodeP, nodeQ);
    }
  }
  var defaults$b = defaults$g({
    k: 2,
    m: 2,
    sensitivityThreshold: 1e-4,
    distance: "euclidean",
    maxIterations: 10,
    attributes: [],
    testMode: false,
    testCentroids: null
  });
  var setOptions$2 = function setOptions2(options) {
    return defaults$b(options);
  };
  var getDist = function getDist2(type, node, centroid, attributes, mode) {
    var noNodeP = mode !== "kMedoids";
    var getP = noNodeP ? function(i2) {
      return centroid[i2];
    } : function(i2) {
      return attributes[i2](centroid);
    };
    var getQ = function getQ2(i2) {
      return attributes[i2](node);
    };
    var nodeP = centroid;
    var nodeQ = node;
    return clusteringDistance(type, attributes.length, getP, getQ, nodeP, nodeQ);
  };
  var randomCentroids = function randomCentroids2(nodes2, k, attributes) {
    var ndim = attributes.length;
    var min2 = new Array(ndim);
    var max2 = new Array(ndim);
    var centroids = new Array(k);
    var centroid = null;
    for (var i2 = 0; i2 < ndim; i2++) {
      min2[i2] = nodes2.min(attributes[i2]).value;
      max2[i2] = nodes2.max(attributes[i2]).value;
    }
    for (var c = 0; c < k; c++) {
      centroid = [];
      for (var _i = 0; _i < ndim; _i++) {
        centroid[_i] = Math.random() * (max2[_i] - min2[_i]) + min2[_i];
      }
      centroids[c] = centroid;
    }
    return centroids;
  };
  var classify = function classify2(node, centroids, distance, attributes, type) {
    var min2 = Infinity;
    var index = 0;
    for (var i2 = 0; i2 < centroids.length; i2++) {
      var dist2 = getDist(distance, node, centroids[i2], attributes, type);
      if (dist2 < min2) {
        min2 = dist2;
        index = i2;
      }
    }
    return index;
  };
  var buildCluster = function buildCluster2(centroid, nodes2, assignment) {
    var cluster = [];
    var node = null;
    for (var n = 0; n < nodes2.length; n++) {
      node = nodes2[n];
      if (assignment[node.id()] === centroid) {
        cluster.push(node);
      }
    }
    return cluster;
  };
  var haveValuesConverged = function haveValuesConverged2(v1, v2, sensitivityThreshold) {
    return Math.abs(v2 - v1) <= sensitivityThreshold;
  };
  var haveMatricesConverged = function haveMatricesConverged2(v1, v2, sensitivityThreshold) {
    for (var i2 = 0; i2 < v1.length; i2++) {
      for (var j = 0; j < v1[i2].length; j++) {
        var diff = Math.abs(v1[i2][j] - v2[i2][j]);
        if (diff > sensitivityThreshold) {
          return false;
        }
      }
    }
    return true;
  };
  var seenBefore = function seenBefore2(node, medoids, n) {
    for (var i2 = 0; i2 < n; i2++) {
      if (node === medoids[i2])
        return true;
    }
    return false;
  };
  var randomMedoids = function randomMedoids2(nodes2, k) {
    var medoids = new Array(k);
    if (nodes2.length < 50) {
      for (var i2 = 0; i2 < k; i2++) {
        var node = nodes2[Math.floor(Math.random() * nodes2.length)];
        while (seenBefore(node, medoids, i2)) {
          node = nodes2[Math.floor(Math.random() * nodes2.length)];
        }
        medoids[i2] = node;
      }
    } else {
      for (var _i2 = 0; _i2 < k; _i2++) {
        medoids[_i2] = nodes2[Math.floor(Math.random() * nodes2.length)];
      }
    }
    return medoids;
  };
  var findCost = function findCost2(potentialNewMedoid, cluster, attributes) {
    var cost = 0;
    for (var n = 0; n < cluster.length; n++) {
      cost += getDist("manhattan", cluster[n], potentialNewMedoid, attributes, "kMedoids");
    }
    return cost;
  };
  var kMeans = function kMeans2(options) {
    var cy = this.cy();
    var nodes2 = this.nodes();
    var node = null;
    var opts = setOptions$2(options);
    var clusters = new Array(opts.k);
    var assignment = {};
    var centroids;
    if (opts.testMode) {
      if (typeof opts.testCentroids === "number") {
        opts.testCentroids;
        centroids = randomCentroids(nodes2, opts.k, opts.attributes);
      } else if (_typeof(opts.testCentroids) === "object") {
        centroids = opts.testCentroids;
      } else {
        centroids = randomCentroids(nodes2, opts.k, opts.attributes);
      }
    } else {
      centroids = randomCentroids(nodes2, opts.k, opts.attributes);
    }
    var isStillMoving = true;
    var iterations = 0;
    while (isStillMoving && iterations < opts.maxIterations) {
      for (var n = 0; n < nodes2.length; n++) {
        node = nodes2[n];
        assignment[node.id()] = classify(node, centroids, opts.distance, opts.attributes, "kMeans");
      }
      isStillMoving = false;
      for (var c = 0; c < opts.k; c++) {
        var cluster = buildCluster(c, nodes2, assignment);
        if (cluster.length === 0) {
          continue;
        }
        var ndim = opts.attributes.length;
        var centroid = centroids[c];
        var newCentroid = new Array(ndim);
        var sum = new Array(ndim);
        for (var d = 0; d < ndim; d++) {
          sum[d] = 0;
          for (var i2 = 0; i2 < cluster.length; i2++) {
            node = cluster[i2];
            sum[d] += opts.attributes[d](node);
          }
          newCentroid[d] = sum[d] / cluster.length;
          if (!haveValuesConverged(newCentroid[d], centroid[d], opts.sensitivityThreshold)) {
            isStillMoving = true;
          }
        }
        centroids[c] = newCentroid;
        clusters[c] = cy.collection(cluster);
      }
      iterations++;
    }
    return clusters;
  };
  var kMedoids = function kMedoids2(options) {
    var cy = this.cy();
    var nodes2 = this.nodes();
    var node = null;
    var opts = setOptions$2(options);
    var clusters = new Array(opts.k);
    var medoids;
    var assignment = {};
    var curCost;
    var minCosts = new Array(opts.k);
    if (opts.testMode) {
      if (typeof opts.testCentroids === "number")
        ;
      else if (_typeof(opts.testCentroids) === "object") {
        medoids = opts.testCentroids;
      } else {
        medoids = randomMedoids(nodes2, opts.k);
      }
    } else {
      medoids = randomMedoids(nodes2, opts.k);
    }
    var isStillMoving = true;
    var iterations = 0;
    while (isStillMoving && iterations < opts.maxIterations) {
      for (var n = 0; n < nodes2.length; n++) {
        node = nodes2[n];
        assignment[node.id()] = classify(node, medoids, opts.distance, opts.attributes, "kMedoids");
      }
      isStillMoving = false;
      for (var m = 0; m < medoids.length; m++) {
        var cluster = buildCluster(m, nodes2, assignment);
        if (cluster.length === 0) {
          continue;
        }
        minCosts[m] = findCost(medoids[m], cluster, opts.attributes);
        for (var _n = 0; _n < cluster.length; _n++) {
          curCost = findCost(cluster[_n], cluster, opts.attributes);
          if (curCost < minCosts[m]) {
            minCosts[m] = curCost;
            medoids[m] = cluster[_n];
            isStillMoving = true;
          }
        }
        clusters[m] = cy.collection(cluster);
      }
      iterations++;
    }
    return clusters;
  };
  var updateCentroids = function updateCentroids2(centroids, nodes2, U, weight, opts) {
    var numerator, denominator;
    for (var n = 0; n < nodes2.length; n++) {
      for (var c = 0; c < centroids.length; c++) {
        weight[n][c] = Math.pow(U[n][c], opts.m);
      }
    }
    for (var _c = 0; _c < centroids.length; _c++) {
      for (var dim = 0; dim < opts.attributes.length; dim++) {
        numerator = 0;
        denominator = 0;
        for (var _n2 = 0; _n2 < nodes2.length; _n2++) {
          numerator += weight[_n2][_c] * opts.attributes[dim](nodes2[_n2]);
          denominator += weight[_n2][_c];
        }
        centroids[_c][dim] = numerator / denominator;
      }
    }
  };
  var updateMembership = function updateMembership2(U, _U, centroids, nodes2, opts) {
    for (var i2 = 0; i2 < U.length; i2++) {
      _U[i2] = U[i2].slice();
    }
    var sum, numerator, denominator;
    var pow = 2 / (opts.m - 1);
    for (var c = 0; c < centroids.length; c++) {
      for (var n = 0; n < nodes2.length; n++) {
        sum = 0;
        for (var k = 0; k < centroids.length; k++) {
          numerator = getDist(opts.distance, nodes2[n], centroids[c], opts.attributes, "cmeans");
          denominator = getDist(opts.distance, nodes2[n], centroids[k], opts.attributes, "cmeans");
          sum += Math.pow(numerator / denominator, pow);
        }
        U[n][c] = 1 / sum;
      }
    }
  };
  var assign$1 = function assign2(nodes2, U, opts, cy) {
    var clusters = new Array(opts.k);
    for (var c = 0; c < clusters.length; c++) {
      clusters[c] = [];
    }
    var max2;
    var index;
    for (var n = 0; n < U.length; n++) {
      max2 = -Infinity;
      index = -1;
      for (var _c2 = 0; _c2 < U[0].length; _c2++) {
        if (U[n][_c2] > max2) {
          max2 = U[n][_c2];
          index = _c2;
        }
      }
      clusters[index].push(nodes2[n]);
    }
    for (var _c3 = 0; _c3 < clusters.length; _c3++) {
      clusters[_c3] = cy.collection(clusters[_c3]);
    }
    return clusters;
  };
  var fuzzyCMeans = function fuzzyCMeans2(options) {
    var cy = this.cy();
    var nodes2 = this.nodes();
    var opts = setOptions$2(options);
    var clusters;
    var centroids;
    var U;
    var _U;
    var weight;
    _U = new Array(nodes2.length);
    for (var i2 = 0; i2 < nodes2.length; i2++) {
      _U[i2] = new Array(opts.k);
    }
    U = new Array(nodes2.length);
    for (var _i3 = 0; _i3 < nodes2.length; _i3++) {
      U[_i3] = new Array(opts.k);
    }
    for (var _i4 = 0; _i4 < nodes2.length; _i4++) {
      var total = 0;
      for (var j = 0; j < opts.k; j++) {
        U[_i4][j] = Math.random();
        total += U[_i4][j];
      }
      for (var _j = 0; _j < opts.k; _j++) {
        U[_i4][_j] = U[_i4][_j] / total;
      }
    }
    centroids = new Array(opts.k);
    for (var _i5 = 0; _i5 < opts.k; _i5++) {
      centroids[_i5] = new Array(opts.attributes.length);
    }
    weight = new Array(nodes2.length);
    for (var _i6 = 0; _i6 < nodes2.length; _i6++) {
      weight[_i6] = new Array(opts.k);
    }
    var isStillMoving = true;
    var iterations = 0;
    while (isStillMoving && iterations < opts.maxIterations) {
      isStillMoving = false;
      updateCentroids(centroids, nodes2, U, weight, opts);
      updateMembership(U, _U, centroids, nodes2, opts);
      if (!haveMatricesConverged(U, _U, opts.sensitivityThreshold)) {
        isStillMoving = true;
      }
      iterations++;
    }
    clusters = assign$1(nodes2, U, opts, cy);
    return {
      clusters,
      degreeOfMembership: U
    };
  };
  var kClustering = {
    kMeans,
    kMedoids,
    fuzzyCMeans,
    fcm: fuzzyCMeans
  };
  var defaults$a = defaults$g({
    distance: "euclidean",
    linkage: "min",
    mode: "threshold",
    threshold: Infinity,
    addDendrogram: false,
    dendrogramDepth: 0,
    attributes: []
  });
  var linkageAliases = {
    "single": "min",
    "complete": "max"
  };
  var setOptions$1 = function setOptions2(options) {
    var opts = defaults$a(options);
    var preferredAlias = linkageAliases[opts.linkage];
    if (preferredAlias != null) {
      opts.linkage = preferredAlias;
    }
    return opts;
  };
  var mergeClosest = function mergeClosest2(clusters, index, dists, mins, opts) {
    var minKey = 0;
    var min2 = Infinity;
    var dist2;
    var attrs = opts.attributes;
    var getDist2 = function getDist3(n1, n2) {
      return clusteringDistance(opts.distance, attrs.length, function(i3) {
        return attrs[i3](n1);
      }, function(i3) {
        return attrs[i3](n2);
      }, n1, n2);
    };
    for (var i2 = 0; i2 < clusters.length; i2++) {
      var key = clusters[i2].key;
      var _dist = dists[key][mins[key]];
      if (_dist < min2) {
        minKey = key;
        min2 = _dist;
      }
    }
    if (opts.mode === "threshold" && min2 >= opts.threshold || opts.mode === "dendrogram" && clusters.length === 1) {
      return false;
    }
    var c1 = index[minKey];
    var c2 = index[mins[minKey]];
    var merged;
    if (opts.mode === "dendrogram") {
      merged = {
        left: c1,
        right: c2,
        key: c1.key
      };
    } else {
      merged = {
        value: c1.value.concat(c2.value),
        key: c1.key
      };
    }
    clusters[c1.index] = merged;
    clusters.splice(c2.index, 1);
    index[c1.key] = merged;
    for (var _i = 0; _i < clusters.length; _i++) {
      var cur = clusters[_i];
      if (c1.key === cur.key) {
        dist2 = Infinity;
      } else if (opts.linkage === "min") {
        dist2 = dists[c1.key][cur.key];
        if (dists[c1.key][cur.key] > dists[c2.key][cur.key]) {
          dist2 = dists[c2.key][cur.key];
        }
      } else if (opts.linkage === "max") {
        dist2 = dists[c1.key][cur.key];
        if (dists[c1.key][cur.key] < dists[c2.key][cur.key]) {
          dist2 = dists[c2.key][cur.key];
        }
      } else if (opts.linkage === "mean") {
        dist2 = (dists[c1.key][cur.key] * c1.size + dists[c2.key][cur.key] * c2.size) / (c1.size + c2.size);
      } else {
        if (opts.mode === "dendrogram")
          dist2 = getDist2(cur.value, c1.value);
        else
          dist2 = getDist2(cur.value[0], c1.value[0]);
      }
      dists[c1.key][cur.key] = dists[cur.key][c1.key] = dist2;
    }
    for (var _i2 = 0; _i2 < clusters.length; _i2++) {
      var key1 = clusters[_i2].key;
      if (mins[key1] === c1.key || mins[key1] === c2.key) {
        var _min = key1;
        for (var j = 0; j < clusters.length; j++) {
          var key2 = clusters[j].key;
          if (dists[key1][key2] < dists[key1][_min]) {
            _min = key2;
          }
        }
        mins[key1] = _min;
      }
      clusters[_i2].index = _i2;
    }
    c1.key = c2.key = c1.index = c2.index = null;
    return true;
  };
  var getAllChildren = function getAllChildren2(root2, arr, cy) {
    if (!root2)
      return;
    if (root2.value) {
      arr.push(root2.value);
    } else {
      if (root2.left)
        getAllChildren2(root2.left, arr);
      if (root2.right)
        getAllChildren2(root2.right, arr);
    }
  };
  var buildDendrogram = function buildDendrogram2(root2, cy) {
    if (!root2)
      return "";
    if (root2.left && root2.right) {
      var leftStr = buildDendrogram2(root2.left, cy);
      var rightStr = buildDendrogram2(root2.right, cy);
      var node = cy.add({
        group: "nodes",
        data: {
          id: leftStr + "," + rightStr
        }
      });
      cy.add({
        group: "edges",
        data: {
          source: leftStr,
          target: node.id()
        }
      });
      cy.add({
        group: "edges",
        data: {
          source: rightStr,
          target: node.id()
        }
      });
      return node.id();
    } else if (root2.value) {
      return root2.value.id();
    }
  };
  var buildClustersFromTree = function buildClustersFromTree2(root2, k, cy) {
    if (!root2)
      return [];
    var left = [], right = [], leaves = [];
    if (k === 0) {
      if (root2.left)
        getAllChildren(root2.left, left);
      if (root2.right)
        getAllChildren(root2.right, right);
      leaves = left.concat(right);
      return [cy.collection(leaves)];
    } else if (k === 1) {
      if (root2.value) {
        return [cy.collection(root2.value)];
      } else {
        if (root2.left)
          getAllChildren(root2.left, left);
        if (root2.right)
          getAllChildren(root2.right, right);
        return [cy.collection(left), cy.collection(right)];
      }
    } else {
      if (root2.value) {
        return [cy.collection(root2.value)];
      } else {
        if (root2.left)
          left = buildClustersFromTree2(root2.left, k - 1, cy);
        if (root2.right)
          right = buildClustersFromTree2(root2.right, k - 1, cy);
        return left.concat(right);
      }
    }
  };
  var hierarchicalClustering = function hierarchicalClustering2(options) {
    var cy = this.cy();
    var nodes2 = this.nodes();
    var opts = setOptions$1(options);
    var attrs = opts.attributes;
    var getDist2 = function getDist3(n1, n2) {
      return clusteringDistance(opts.distance, attrs.length, function(i3) {
        return attrs[i3](n1);
      }, function(i3) {
        return attrs[i3](n2);
      }, n1, n2);
    };
    var clusters = [];
    var dists = [];
    var mins = [];
    var index = [];
    for (var n = 0; n < nodes2.length; n++) {
      var cluster = {
        value: opts.mode === "dendrogram" ? nodes2[n] : [nodes2[n]],
        key: n,
        index: n
      };
      clusters[n] = cluster;
      index[n] = cluster;
      dists[n] = [];
      mins[n] = 0;
    }
    for (var i2 = 0; i2 < clusters.length; i2++) {
      for (var j = 0; j <= i2; j++) {
        var dist2 = void 0;
        if (opts.mode === "dendrogram") {
          dist2 = i2 === j ? Infinity : getDist2(clusters[i2].value, clusters[j].value);
        } else {
          dist2 = i2 === j ? Infinity : getDist2(clusters[i2].value[0], clusters[j].value[0]);
        }
        dists[i2][j] = dist2;
        dists[j][i2] = dist2;
        if (dist2 < dists[i2][mins[i2]]) {
          mins[i2] = j;
        }
      }
    }
    var merged = mergeClosest(clusters, index, dists, mins, opts);
    while (merged) {
      merged = mergeClosest(clusters, index, dists, mins, opts);
    }
    var retClusters;
    if (opts.mode === "dendrogram") {
      retClusters = buildClustersFromTree(clusters[0], opts.dendrogramDepth, cy);
      if (opts.addDendrogram)
        buildDendrogram(clusters[0], cy);
    } else {
      retClusters = new Array(clusters.length);
      clusters.forEach(function(cluster2, i3) {
        cluster2.key = cluster2.index = null;
        retClusters[i3] = cy.collection(cluster2.value);
      });
    }
    return retClusters;
  };
  var hierarchicalClustering$1 = {
    hierarchicalClustering,
    hca: hierarchicalClustering
  };
  var defaults$9 = defaults$g({
    distance: "euclidean",
    preference: "median",
    damping: 0.8,
    maxIterations: 1e3,
    minIterations: 100,
    attributes: []
  });
  var setOptions = function setOptions2(options) {
    var dmp = options.damping;
    var pref = options.preference;
    if (!(0.5 <= dmp && dmp < 1)) {
      error("Damping must range on [0.5, 1).  Got: ".concat(dmp));
    }
    var validPrefs = ["median", "mean", "min", "max"];
    if (!(validPrefs.some(function(v) {
      return v === pref;
    }) || number$1(pref))) {
      error("Preference must be one of [".concat(validPrefs.map(function(p2) {
        return "'".concat(p2, "'");
      }).join(", "), "] or a number.  Got: ").concat(pref));
    }
    return defaults$9(options);
  };
  var getSimilarity = function getSimilarity2(type, n1, n2, attributes) {
    var attr = function attr2(n, i2) {
      return attributes[i2](n);
    };
    return -clusteringDistance(type, attributes.length, function(i2) {
      return attr(n1, i2);
    }, function(i2) {
      return attr(n2, i2);
    }, n1, n2);
  };
  var getPreference = function getPreference2(S, preference) {
    var p2 = null;
    if (preference === "median") {
      p2 = median(S);
    } else if (preference === "mean") {
      p2 = mean(S);
    } else if (preference === "min") {
      p2 = min(S);
    } else if (preference === "max") {
      p2 = max(S);
    } else {
      p2 = preference;
    }
    return p2;
  };
  var findExemplars = function findExemplars2(n, R, A) {
    var indices = [];
    for (var i2 = 0; i2 < n; i2++) {
      if (R[i2 * n + i2] + A[i2 * n + i2] > 0) {
        indices.push(i2);
      }
    }
    return indices;
  };
  var assignClusters = function assignClusters2(n, S, exemplars) {
    var clusters = [];
    for (var i2 = 0; i2 < n; i2++) {
      var index = -1;
      var max2 = -Infinity;
      for (var ei = 0; ei < exemplars.length; ei++) {
        var e = exemplars[ei];
        if (S[i2 * n + e] > max2) {
          index = e;
          max2 = S[i2 * n + e];
        }
      }
      if (index > 0) {
        clusters.push(index);
      }
    }
    for (var _ei = 0; _ei < exemplars.length; _ei++) {
      clusters[exemplars[_ei]] = exemplars[_ei];
    }
    return clusters;
  };
  var assign = function assign2(n, S, exemplars) {
    var clusters = assignClusters(n, S, exemplars);
    for (var ei = 0; ei < exemplars.length; ei++) {
      var ii = [];
      for (var c = 0; c < clusters.length; c++) {
        if (clusters[c] === exemplars[ei]) {
          ii.push(c);
        }
      }
      var maxI = -1;
      var maxSum = -Infinity;
      for (var i2 = 0; i2 < ii.length; i2++) {
        var sum = 0;
        for (var j = 0; j < ii.length; j++) {
          sum += S[ii[j] * n + ii[i2]];
        }
        if (sum > maxSum) {
          maxI = i2;
          maxSum = sum;
        }
      }
      exemplars[ei] = ii[maxI];
    }
    clusters = assignClusters(n, S, exemplars);
    return clusters;
  };
  var affinityPropagation = function affinityPropagation2(options) {
    var cy = this.cy();
    var nodes2 = this.nodes();
    var opts = setOptions(options);
    var id2position = {};
    for (var i2 = 0; i2 < nodes2.length; i2++) {
      id2position[nodes2[i2].id()] = i2;
    }
    var n;
    var n2;
    var S;
    var p2;
    var R;
    var A;
    n = nodes2.length;
    n2 = n * n;
    S = new Array(n2);
    for (var _i = 0; _i < n2; _i++) {
      S[_i] = -Infinity;
    }
    for (var _i2 = 0; _i2 < n; _i2++) {
      for (var j = 0; j < n; j++) {
        if (_i2 !== j) {
          S[_i2 * n + j] = getSimilarity(opts.distance, nodes2[_i2], nodes2[j], opts.attributes);
        }
      }
    }
    p2 = getPreference(S, opts.preference);
    for (var _i3 = 0; _i3 < n; _i3++) {
      S[_i3 * n + _i3] = p2;
    }
    R = new Array(n2);
    for (var _i4 = 0; _i4 < n2; _i4++) {
      R[_i4] = 0;
    }
    A = new Array(n2);
    for (var _i5 = 0; _i5 < n2; _i5++) {
      A[_i5] = 0;
    }
    var old = new Array(n);
    var Rp = new Array(n);
    var se = new Array(n);
    for (var _i6 = 0; _i6 < n; _i6++) {
      old[_i6] = 0;
      Rp[_i6] = 0;
      se[_i6] = 0;
    }
    var e = new Array(n * opts.minIterations);
    for (var _i7 = 0; _i7 < e.length; _i7++) {
      e[_i7] = 0;
    }
    var iter;
    for (iter = 0; iter < opts.maxIterations; iter++) {
      for (var _i8 = 0; _i8 < n; _i8++) {
        var max2 = -Infinity, max22 = -Infinity, maxI = -1, AS = 0;
        for (var _j = 0; _j < n; _j++) {
          old[_j] = R[_i8 * n + _j];
          AS = A[_i8 * n + _j] + S[_i8 * n + _j];
          if (AS >= max2) {
            max22 = max2;
            max2 = AS;
            maxI = _j;
          } else if (AS > max22) {
            max22 = AS;
          }
        }
        for (var _j2 = 0; _j2 < n; _j2++) {
          R[_i8 * n + _j2] = (1 - opts.damping) * (S[_i8 * n + _j2] - max2) + opts.damping * old[_j2];
        }
        R[_i8 * n + maxI] = (1 - opts.damping) * (S[_i8 * n + maxI] - max22) + opts.damping * old[maxI];
      }
      for (var _i9 = 0; _i9 < n; _i9++) {
        var sum = 0;
        for (var _j3 = 0; _j3 < n; _j3++) {
          old[_j3] = A[_j3 * n + _i9];
          Rp[_j3] = Math.max(0, R[_j3 * n + _i9]);
          sum += Rp[_j3];
        }
        sum -= Rp[_i9];
        Rp[_i9] = R[_i9 * n + _i9];
        sum += Rp[_i9];
        for (var _j4 = 0; _j4 < n; _j4++) {
          A[_j4 * n + _i9] = (1 - opts.damping) * Math.min(0, sum - Rp[_j4]) + opts.damping * old[_j4];
        }
        A[_i9 * n + _i9] = (1 - opts.damping) * (sum - Rp[_i9]) + opts.damping * old[_i9];
      }
      var K2 = 0;
      for (var _i10 = 0; _i10 < n; _i10++) {
        var E = A[_i10 * n + _i10] + R[_i10 * n + _i10] > 0 ? 1 : 0;
        e[iter % opts.minIterations * n + _i10] = E;
        K2 += E;
      }
      if (K2 > 0 && (iter >= opts.minIterations - 1 || iter == opts.maxIterations - 1)) {
        var _sum = 0;
        for (var _i11 = 0; _i11 < n; _i11++) {
          se[_i11] = 0;
          for (var _j5 = 0; _j5 < opts.minIterations; _j5++) {
            se[_i11] += e[_j5 * n + _i11];
          }
          if (se[_i11] === 0 || se[_i11] === opts.minIterations) {
            _sum++;
          }
        }
        if (_sum === n) {
          break;
        }
      }
    }
    var exemplarsIndices = findExemplars(n, R, A);
    var clusterIndices = assign(n, S, exemplarsIndices);
    var clusters = {};
    for (var c = 0; c < exemplarsIndices.length; c++) {
      clusters[exemplarsIndices[c]] = [];
    }
    for (var _i12 = 0; _i12 < nodes2.length; _i12++) {
      var pos = id2position[nodes2[_i12].id()];
      var clusterIndex = clusterIndices[pos];
      if (clusterIndex != null) {
        clusters[clusterIndex].push(nodes2[_i12]);
      }
    }
    var retClusters = new Array(exemplarsIndices.length);
    for (var _c = 0; _c < exemplarsIndices.length; _c++) {
      retClusters[_c] = cy.collection(clusters[exemplarsIndices[_c]]);
    }
    return retClusters;
  };
  var affinityPropagation$1 = {
    affinityPropagation,
    ap: affinityPropagation
  };
  var hierholzerDefaults = defaults$g({
    root: void 0,
    directed: false
  });
  var elesfn$k = {
    hierholzer: function hierholzer(options) {
      if (!plainObject(options)) {
        var args = arguments;
        options = {
          root: args[0],
          directed: args[1]
        };
      }
      var _hierholzerDefaults = hierholzerDefaults(options), root2 = _hierholzerDefaults.root, directed = _hierholzerDefaults.directed;
      var eles = this;
      var dflag = false;
      var oddIn;
      var oddOut;
      var startVertex;
      if (root2)
        startVertex = string(root2) ? this.filter(root2)[0].id() : root2[0].id();
      var nodes2 = {};
      var edges = {};
      if (directed) {
        eles.forEach(function(ele) {
          var id2 = ele.id();
          if (ele.isNode()) {
            var ind = ele.indegree(true);
            var outd = ele.outdegree(true);
            var d1 = ind - outd;
            var d2 = outd - ind;
            if (d1 == 1) {
              if (oddIn)
                dflag = true;
              else
                oddIn = id2;
            } else if (d2 == 1) {
              if (oddOut)
                dflag = true;
              else
                oddOut = id2;
            } else if (d2 > 1 || d1 > 1) {
              dflag = true;
            }
            nodes2[id2] = [];
            ele.outgoers().forEach(function(e) {
              if (e.isEdge())
                nodes2[id2].push(e.id());
            });
          } else {
            edges[id2] = [void 0, ele.target().id()];
          }
        });
      } else {
        eles.forEach(function(ele) {
          var id2 = ele.id();
          if (ele.isNode()) {
            var d2 = ele.degree(true);
            if (d2 % 2) {
              if (!oddIn)
                oddIn = id2;
              else if (!oddOut)
                oddOut = id2;
              else
                dflag = true;
            }
            nodes2[id2] = [];
            ele.connectedEdges().forEach(function(e) {
              return nodes2[id2].push(e.id());
            });
          } else {
            edges[id2] = [ele.source().id(), ele.target().id()];
          }
        });
      }
      var result = {
        found: false,
        trail: void 0
      };
      if (dflag)
        return result;
      else if (oddOut && oddIn) {
        if (directed) {
          if (startVertex && oddOut != startVertex) {
            return result;
          }
          startVertex = oddOut;
        } else {
          if (startVertex && oddOut != startVertex && oddIn != startVertex) {
            return result;
          } else if (!startVertex) {
            startVertex = oddOut;
          }
        }
      } else {
        if (!startVertex)
          startVertex = eles[0].id();
      }
      var walk = function walk2(v) {
        var currentNode = v;
        var subtour2 = [v];
        var adj, adjTail, adjHead;
        while (nodes2[currentNode].length) {
          adj = nodes2[currentNode].shift();
          adjTail = edges[adj][0];
          adjHead = edges[adj][1];
          if (currentNode != adjHead) {
            nodes2[adjHead] = nodes2[adjHead].filter(function(e) {
              return e != adj;
            });
            currentNode = adjHead;
          } else if (!directed && currentNode != adjTail) {
            nodes2[adjTail] = nodes2[adjTail].filter(function(e) {
              return e != adj;
            });
            currentNode = adjTail;
          }
          subtour2.unshift(adj);
          subtour2.unshift(currentNode);
        }
        return subtour2;
      };
      var trail = [];
      var subtour = [];
      subtour = walk(startVertex);
      while (subtour.length != 1) {
        if (nodes2[subtour[0]].length == 0) {
          trail.unshift(eles.getElementById(subtour.shift()));
          trail.unshift(eles.getElementById(subtour.shift()));
        } else {
          subtour = walk(subtour.shift()).concat(subtour);
        }
      }
      trail.unshift(eles.getElementById(subtour.shift()));
      for (var d in nodes2) {
        if (nodes2[d].length) {
          return result;
        }
      }
      result.found = true;
      result.trail = this.spawn(trail, true);
      return result;
    }
  };
  var hopcroftTarjanBiconnected = function hopcroftTarjanBiconnected2() {
    var eles = this;
    var nodes2 = {};
    var id2 = 0;
    var edgeCount = 0;
    var components = [];
    var stack = [];
    var visitedEdges = {};
    var buildComponent = function buildComponent2(x, y) {
      var i2 = stack.length - 1;
      var cutset = [];
      var component = eles.spawn();
      while (stack[i2].x != x || stack[i2].y != y) {
        cutset.push(stack.pop().edge);
        i2--;
      }
      cutset.push(stack.pop().edge);
      cutset.forEach(function(edge) {
        var connectedNodes = edge.connectedNodes().intersection(eles);
        component.merge(edge);
        connectedNodes.forEach(function(node) {
          var nodeId = node.id();
          var connectedEdges = node.connectedEdges().intersection(eles);
          component.merge(node);
          if (!nodes2[nodeId].cutVertex) {
            component.merge(connectedEdges);
          } else {
            component.merge(connectedEdges.filter(function(edge2) {
              return edge2.isLoop();
            }));
          }
        });
      });
      components.push(component);
    };
    var biconnectedSearch = function biconnectedSearch2(root2, currentNode, parent) {
      if (root2 === parent)
        edgeCount += 1;
      nodes2[currentNode] = {
        id: id2,
        low: id2++,
        cutVertex: false
      };
      var edges = eles.getElementById(currentNode).connectedEdges().intersection(eles);
      if (edges.size() === 0) {
        components.push(eles.spawn(eles.getElementById(currentNode)));
      } else {
        var sourceId, targetId, otherNodeId, edgeId;
        edges.forEach(function(edge) {
          sourceId = edge.source().id();
          targetId = edge.target().id();
          otherNodeId = sourceId === currentNode ? targetId : sourceId;
          if (otherNodeId !== parent) {
            edgeId = edge.id();
            if (!visitedEdges[edgeId]) {
              visitedEdges[edgeId] = true;
              stack.push({
                x: currentNode,
                y: otherNodeId,
                edge
              });
            }
            if (!(otherNodeId in nodes2)) {
              biconnectedSearch2(root2, otherNodeId, currentNode);
              nodes2[currentNode].low = Math.min(nodes2[currentNode].low, nodes2[otherNodeId].low);
              if (nodes2[currentNode].id <= nodes2[otherNodeId].low) {
                nodes2[currentNode].cutVertex = true;
                buildComponent(currentNode, otherNodeId);
              }
            } else {
              nodes2[currentNode].low = Math.min(nodes2[currentNode].low, nodes2[otherNodeId].id);
            }
          }
        });
      }
    };
    eles.forEach(function(ele) {
      if (ele.isNode()) {
        var nodeId = ele.id();
        if (!(nodeId in nodes2)) {
          edgeCount = 0;
          biconnectedSearch(nodeId, nodeId);
          nodes2[nodeId].cutVertex = edgeCount > 1;
        }
      }
    });
    var cutVertices = Object.keys(nodes2).filter(function(id3) {
      return nodes2[id3].cutVertex;
    }).map(function(id3) {
      return eles.getElementById(id3);
    });
    return {
      cut: eles.spawn(cutVertices),
      components
    };
  };
  var hopcroftTarjanBiconnected$1 = {
    hopcroftTarjanBiconnected,
    htbc: hopcroftTarjanBiconnected,
    htb: hopcroftTarjanBiconnected,
    hopcroftTarjanBiconnectedComponents: hopcroftTarjanBiconnected
  };
  var tarjanStronglyConnected = function tarjanStronglyConnected2() {
    var eles = this;
    var nodes2 = {};
    var index = 0;
    var components = [];
    var stack = [];
    var cut = eles.spawn(eles);
    var stronglyConnectedSearch = function stronglyConnectedSearch2(sourceNodeId) {
      stack.push(sourceNodeId);
      nodes2[sourceNodeId] = {
        index,
        low: index++,
        explored: false
      };
      var connectedEdges = eles.getElementById(sourceNodeId).connectedEdges().intersection(eles);
      connectedEdges.forEach(function(edge) {
        var targetNodeId = edge.target().id();
        if (targetNodeId !== sourceNodeId) {
          if (!(targetNodeId in nodes2)) {
            stronglyConnectedSearch2(targetNodeId);
          }
          if (!nodes2[targetNodeId].explored) {
            nodes2[sourceNodeId].low = Math.min(nodes2[sourceNodeId].low, nodes2[targetNodeId].low);
          }
        }
      });
      if (nodes2[sourceNodeId].index === nodes2[sourceNodeId].low) {
        var componentNodes = eles.spawn();
        for (; ; ) {
          var nodeId = stack.pop();
          componentNodes.merge(eles.getElementById(nodeId));
          nodes2[nodeId].low = nodes2[sourceNodeId].index;
          nodes2[nodeId].explored = true;
          if (nodeId === sourceNodeId) {
            break;
          }
        }
        var componentEdges = componentNodes.edgesWith(componentNodes);
        var component = componentNodes.merge(componentEdges);
        components.push(component);
        cut = cut.difference(component);
      }
    };
    eles.forEach(function(ele) {
      if (ele.isNode()) {
        var nodeId = ele.id();
        if (!(nodeId in nodes2)) {
          stronglyConnectedSearch(nodeId);
        }
      }
    });
    return {
      cut,
      components
    };
  };
  var tarjanStronglyConnected$1 = {
    tarjanStronglyConnected,
    tsc: tarjanStronglyConnected,
    tscc: tarjanStronglyConnected,
    tarjanStronglyConnectedComponents: tarjanStronglyConnected
  };
  var elesfn$j = {};
  [elesfn$v, elesfn$u, elesfn$t, elesfn$s, elesfn$r, elesfn$q, elesfn$p, elesfn$o, elesfn$n, elesfn$m, elesfn$l, markovClustering$1, kClustering, hierarchicalClustering$1, affinityPropagation$1, elesfn$k, hopcroftTarjanBiconnected$1, tarjanStronglyConnected$1].forEach(function(props) {
    extend(elesfn$j, props);
  });
  /*!
  Embeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable
  Copyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)
  Licensed under The MIT License (http://opensource.org/licenses/MIT)
  */
  var STATE_PENDING = 0;
  var STATE_FULFILLED = 1;
  var STATE_REJECTED = 2;
  var api = function api2(executor) {
    if (!(this instanceof api2))
      return new api2(executor);
    this.id = "Thenable/1.0.7";
    this.state = STATE_PENDING;
    this.fulfillValue = void 0;
    this.rejectReason = void 0;
    this.onFulfilled = [];
    this.onRejected = [];
    this.proxy = {
      then: this.then.bind(this)
    };
    if (typeof executor === "function")
      executor.call(this, this.fulfill.bind(this), this.reject.bind(this));
  };
  api.prototype = {
    fulfill: function fulfill(value) {
      return deliver(this, STATE_FULFILLED, "fulfillValue", value);
    },
    reject: function reject(value) {
      return deliver(this, STATE_REJECTED, "rejectReason", value);
    },
    then: function then(onFulfilled, onRejected) {
      var curr = this;
      var next2 = new api();
      curr.onFulfilled.push(resolver(onFulfilled, next2, "fulfill"));
      curr.onRejected.push(resolver(onRejected, next2, "reject"));
      execute(curr);
      return next2.proxy;
    }
  };
  var deliver = function deliver2(curr, state, name2, value) {
    if (curr.state === STATE_PENDING) {
      curr.state = state;
      curr[name2] = value;
      execute(curr);
    }
    return curr;
  };
  var execute = function execute2(curr) {
    if (curr.state === STATE_FULFILLED)
      execute_handlers(curr, "onFulfilled", curr.fulfillValue);
    else if (curr.state === STATE_REJECTED)
      execute_handlers(curr, "onRejected", curr.rejectReason);
  };
  var execute_handlers = function execute_handlers2(curr, name2, value) {
    if (curr[name2].length === 0)
      return;
    var handlers = curr[name2];
    curr[name2] = [];
    var func = function func2() {
      for (var i2 = 0; i2 < handlers.length; i2++) {
        handlers[i2](value);
      }
    };
    if (typeof setImmediate === "function")
      setImmediate(func);
    else
      setTimeout(func, 0);
  };
  var resolver = function resolver2(cb, next2, method) {
    return function(value) {
      if (typeof cb !== "function")
        next2[method].call(next2, value);
      else {
        var result;
        try {
          result = cb(value);
        } catch (e) {
          next2.reject(e);
          return;
        }
        resolve(next2, result);
      }
    };
  };
  var resolve = function resolve2(promise2, x) {
    if (promise2 === x || promise2.proxy === x) {
      promise2.reject(new TypeError("cannot resolve promise with itself"));
      return;
    }
    var then;
    if (_typeof(x) === "object" && x !== null || typeof x === "function") {
      try {
        then = x.then;
      } catch (e) {
        promise2.reject(e);
        return;
      }
    }
    if (typeof then === "function") {
      var resolved = false;
      try {
        then.call(
          x,
          function(y) {
            if (resolved)
              return;
            resolved = true;
            if (y === x)
              promise2.reject(new TypeError("circular thenable chain"));
            else
              resolve2(promise2, y);
          },
          function(r) {
            if (resolved)
              return;
            resolved = true;
            promise2.reject(r);
          }
        );
      } catch (e) {
        if (!resolved)
          promise2.reject(e);
      }
      return;
    }
    promise2.fulfill(x);
  };
  api.all = function(ps) {
    return new api(function(resolveAll, rejectAll) {
      var vals = new Array(ps.length);
      var doneCount = 0;
      var fulfill = function fulfill2(i3, val) {
        vals[i3] = val;
        doneCount++;
        if (doneCount === ps.length) {
          resolveAll(vals);
        }
      };
      for (var i2 = 0; i2 < ps.length; i2++) {
        (function(i3) {
          var p2 = ps[i3];
          var isPromise = p2 != null && p2.then != null;
          if (isPromise) {
            p2.then(function(val2) {
              fulfill(i3, val2);
            }, function(err) {
              rejectAll(err);
            });
          } else {
            var val = p2;
            fulfill(i3, val);
          }
        })(i2);
      }
    });
  };
  api.resolve = function(val) {
    return new api(function(resolve2, reject) {
      resolve2(val);
    });
  };
  api.reject = function(val) {
    return new api(function(resolve2, reject) {
      reject(val);
    });
  };
  var Promise$1 = typeof Promise !== "undefined" ? Promise : api;
  var Animation = function Animation2(target, opts, opts2) {
    var isCore = core(target);
    var isEle = !isCore;
    var _p = this._private = extend({
      duration: 1e3
    }, opts, opts2);
    _p.target = target;
    _p.style = _p.style || _p.css;
    _p.started = false;
    _p.playing = false;
    _p.hooked = false;
    _p.applying = false;
    _p.progress = 0;
    _p.completes = [];
    _p.frames = [];
    if (_p.complete && fn$6(_p.complete)) {
      _p.completes.push(_p.complete);
    }
    if (isEle) {
      var pos = target.position();
      _p.startPosition = _p.startPosition || {
        x: pos.x,
        y: pos.y
      };
      _p.startStyle = _p.startStyle || target.cy().style().getAnimationStartStyle(target, _p.style);
    }
    if (isCore) {
      var pan = target.pan();
      _p.startPan = {
        x: pan.x,
        y: pan.y
      };
      _p.startZoom = target.zoom();
    }
    this.length = 1;
    this[0] = this;
  };
  var anifn = Animation.prototype;
  extend(anifn, {
    instanceString: function instanceString() {
      return "animation";
    },
    hook: function hook() {
      var _p = this._private;
      if (!_p.hooked) {
        var q;
        var tAni = _p.target._private.animation;
        if (_p.queue) {
          q = tAni.queue;
        } else {
          q = tAni.current;
        }
        q.push(this);
        if (elementOrCollection(_p.target)) {
          _p.target.cy().addToAnimationPool(_p.target);
        }
        _p.hooked = true;
      }
      return this;
    },
    play: function play() {
      var _p = this._private;
      if (_p.progress === 1) {
        _p.progress = 0;
      }
      _p.playing = true;
      _p.started = false;
      _p.stopped = false;
      this.hook();
      return this;
    },
    playing: function playing() {
      return this._private.playing;
    },
    apply: function apply() {
      var _p = this._private;
      _p.applying = true;
      _p.started = false;
      _p.stopped = false;
      this.hook();
      return this;
    },
    applying: function applying() {
      return this._private.applying;
    },
    pause: function pause() {
      var _p = this._private;
      _p.playing = false;
      _p.started = false;
      return this;
    },
    stop: function stop() {
      var _p = this._private;
      _p.playing = false;
      _p.started = false;
      _p.stopped = true;
      return this;
    },
    rewind: function rewind() {
      return this.progress(0);
    },
    fastforward: function fastforward() {
      return this.progress(1);
    },
    time: function time(t) {
      var _p = this._private;
      if (t === void 0) {
        return _p.progress * _p.duration;
      } else {
        return this.progress(t / _p.duration);
      }
    },
    progress: function progress(p2) {
      var _p = this._private;
      var wasPlaying = _p.playing;
      if (p2 === void 0) {
        return _p.progress;
      } else {
        if (wasPlaying) {
          this.pause();
        }
        _p.progress = p2;
        _p.started = false;
        if (wasPlaying) {
          this.play();
        }
      }
      return this;
    },
    completed: function completed() {
      return this._private.progress === 1;
    },
    reverse: function reverse() {
      var _p = this._private;
      var wasPlaying = _p.playing;
      if (wasPlaying) {
        this.pause();
      }
      _p.progress = 1 - _p.progress;
      _p.started = false;
      var swap = function swap2(a, b) {
        var _pa = _p[a];
        if (_pa == null) {
          return;
        }
        _p[a] = _p[b];
        _p[b] = _pa;
      };
      swap("zoom", "startZoom");
      swap("pan", "startPan");
      swap("position", "startPosition");
      if (_p.style) {
        for (var i2 = 0; i2 < _p.style.length; i2++) {
          var prop = _p.style[i2];
          var name2 = prop.name;
          var startStyleProp = _p.startStyle[name2];
          _p.startStyle[name2] = prop;
          _p.style[i2] = startStyleProp;
        }
      }
      if (wasPlaying) {
        this.play();
      }
      return this;
    },
    promise: function promise2(type) {
      var _p = this._private;
      var arr;
      switch (type) {
        case "frame":
          arr = _p.frames;
          break;
        default:
        case "complete":
        case "completed":
          arr = _p.completes;
      }
      return new Promise$1(function(resolve2, reject) {
        arr.push(function() {
          resolve2();
        });
      });
    }
  });
  anifn.complete = anifn.completed;
  anifn.run = anifn.play;
  anifn.running = anifn.playing;
  var define$3 = {
    animated: function animated() {
      return function animatedImpl() {
        var self2 = this;
        var selfIsArrayLike = self2.length !== void 0;
        var all = selfIsArrayLike ? self2 : [self2];
        var cy = this._private.cy || this;
        if (!cy.styleEnabled()) {
          return false;
        }
        var ele = all[0];
        if (ele) {
          return ele._private.animation.current.length > 0;
        }
      };
    },
    clearQueue: function clearQueue() {
      return function clearQueueImpl() {
        var self2 = this;
        var selfIsArrayLike = self2.length !== void 0;
        var all = selfIsArrayLike ? self2 : [self2];
        var cy = this._private.cy || this;
        if (!cy.styleEnabled()) {
          return this;
        }
        for (var i2 = 0; i2 < all.length; i2++) {
          var ele = all[i2];
          ele._private.animation.queue = [];
        }
        return this;
      };
    },
    delay: function delay() {
      return function delayImpl(time, complete) {
        var cy = this._private.cy || this;
        if (!cy.styleEnabled()) {
          return this;
        }
        return this.animate({
          delay: time,
          duration: time,
          complete
        });
      };
    },
    delayAnimation: function delayAnimation() {
      return function delayAnimationImpl(time, complete) {
        var cy = this._private.cy || this;
        if (!cy.styleEnabled()) {
          return this;
        }
        return this.animation({
          delay: time,
          duration: time,
          complete
        });
      };
    },
    animation: function animation() {
      return function animationImpl(properties, params) {
        var self2 = this;
        var selfIsArrayLike = self2.length !== void 0;
        var all = selfIsArrayLike ? self2 : [self2];
        var cy = this._private.cy || this;
        var isCore = !selfIsArrayLike;
        var isEles = !isCore;
        if (!cy.styleEnabled()) {
          return this;
        }
        var style = cy.style();
        properties = extend({}, properties, params);
        var propertiesEmpty = Object.keys(properties).length === 0;
        if (propertiesEmpty) {
          return new Animation(all[0], properties);
        }
        if (properties.duration === void 0) {
          properties.duration = 400;
        }
        switch (properties.duration) {
          case "slow":
            properties.duration = 600;
            break;
          case "fast":
            properties.duration = 200;
            break;
        }
        if (isEles) {
          properties.style = style.getPropsList(properties.style || properties.css);
          properties.css = void 0;
        }
        if (isEles && properties.renderedPosition != null) {
          var rpos = properties.renderedPosition;
          var pan = cy.pan();
          var zoom = cy.zoom();
          properties.position = renderedToModelPosition(rpos, zoom, pan);
        }
        if (isCore && properties.panBy != null) {
          var panBy = properties.panBy;
          var cyPan = cy.pan();
          properties.pan = {
            x: cyPan.x + panBy.x,
            y: cyPan.y + panBy.y
          };
        }
        var center = properties.center || properties.centre;
        if (isCore && center != null) {
          var centerPan = cy.getCenterPan(center.eles, properties.zoom);
          if (centerPan != null) {
            properties.pan = centerPan;
          }
        }
        if (isCore && properties.fit != null) {
          var fit = properties.fit;
          var fitVp = cy.getFitViewport(fit.eles || fit.boundingBox, fit.padding);
          if (fitVp != null) {
            properties.pan = fitVp.pan;
            properties.zoom = fitVp.zoom;
          }
        }
        if (isCore && plainObject(properties.zoom)) {
          var vp = cy.getZoomedViewport(properties.zoom);
          if (vp != null) {
            if (vp.zoomed) {
              properties.zoom = vp.zoom;
            }
            if (vp.panned) {
              properties.pan = vp.pan;
            }
          } else {
            properties.zoom = null;
          }
        }
        return new Animation(all[0], properties);
      };
    },
    animate: function animate() {
      return function animateImpl(properties, params) {
        var self2 = this;
        var selfIsArrayLike = self2.length !== void 0;
        var all = selfIsArrayLike ? self2 : [self2];
        var cy = this._private.cy || this;
        if (!cy.styleEnabled()) {
          return this;
        }
        if (params) {
          properties = extend({}, properties, params);
        }
        for (var i2 = 0; i2 < all.length; i2++) {
          var ele = all[i2];
          var queue = ele.animated() && (properties.queue === void 0 || properties.queue);
          var ani = ele.animation(properties, queue ? {
            queue: true
          } : void 0);
          ani.play();
        }
        return this;
      };
    },
    stop: function stop() {
      return function stopImpl(clearQueue, jumpToEnd) {
        var self2 = this;
        var selfIsArrayLike = self2.length !== void 0;
        var all = selfIsArrayLike ? self2 : [self2];
        var cy = this._private.cy || this;
        if (!cy.styleEnabled()) {
          return this;
        }
        for (var i2 = 0; i2 < all.length; i2++) {
          var ele = all[i2];
          var _p = ele._private;
          var anis = _p.animation.current;
          for (var j = 0; j < anis.length; j++) {
            var ani = anis[j];
            var ani_p = ani._private;
            if (jumpToEnd) {
              ani_p.duration = 0;
            }
          }
          if (clearQueue) {
            _p.animation.queue = [];
          }
          if (!jumpToEnd) {
            _p.animation.current = [];
          }
        }
        cy.notify("draw");
        return this;
      };
    }
  };
  var define$2 = {
    data: function data2(params) {
      var defaults2 = {
        field: "data",
        bindingEvent: "data",
        allowBinding: false,
        allowSetting: false,
        allowGetting: false,
        settingEvent: "data",
        settingTriggersEvent: false,
        triggerFnName: "trigger",
        immutableKeys: {},
        updateStyle: false,
        beforeGet: function beforeGet(self2) {
        },
        beforeSet: function beforeSet(self2, obj) {
        },
        onSet: function onSet(self2) {
        },
        canSet: function canSet(self2) {
          return true;
        }
      };
      params = extend({}, defaults2, params);
      return function dataImpl(name2, value) {
        var p2 = params;
        var self2 = this;
        var selfIsArrayLike = self2.length !== void 0;
        var all = selfIsArrayLike ? self2 : [self2];
        var single = selfIsArrayLike ? self2[0] : self2;
        if (string(name2)) {
          var isPathLike = name2.indexOf(".") !== -1;
          var path = isPathLike && toPath__default["default"](name2);
          if (p2.allowGetting && value === void 0) {
            var ret;
            if (single) {
              p2.beforeGet(single);
              if (path && single._private[p2.field][name2] === void 0) {
                ret = get__default["default"](single._private[p2.field], path);
              } else {
                ret = single._private[p2.field][name2];
              }
            }
            return ret;
          } else if (p2.allowSetting && value !== void 0) {
            var valid2 = !p2.immutableKeys[name2];
            if (valid2) {
              var change = _defineProperty({}, name2, value);
              p2.beforeSet(self2, change);
              for (var i2 = 0, l = all.length; i2 < l; i2++) {
                var ele = all[i2];
                if (p2.canSet(ele)) {
                  if (path && single._private[p2.field][name2] === void 0) {
                    set__default["default"](ele._private[p2.field], path, value);
                  } else {
                    ele._private[p2.field][name2] = value;
                  }
                }
              }
              if (p2.updateStyle) {
                self2.updateStyle();
              }
              p2.onSet(self2);
              if (p2.settingTriggersEvent) {
                self2[p2.triggerFnName](p2.settingEvent);
              }
            }
          }
        } else if (p2.allowSetting && plainObject(name2)) {
          var obj = name2;
          var k, v;
          var keys = Object.keys(obj);
          p2.beforeSet(self2, obj);
          for (var _i = 0; _i < keys.length; _i++) {
            k = keys[_i];
            v = obj[k];
            var _valid = !p2.immutableKeys[k];
            if (_valid) {
              for (var j = 0; j < all.length; j++) {
                var _ele = all[j];
                if (p2.canSet(_ele)) {
                  _ele._private[p2.field][k] = v;
                }
              }
            }
          }
          if (p2.updateStyle) {
            self2.updateStyle();
          }
          p2.onSet(self2);
          if (p2.settingTriggersEvent) {
            self2[p2.triggerFnName](p2.settingEvent);
          }
        } else if (p2.allowBinding && fn$6(name2)) {
          var fn2 = name2;
          self2.on(p2.bindingEvent, fn2);
        } else if (p2.allowGetting && name2 === void 0) {
          var _ret;
          if (single) {
            p2.beforeGet(single);
            _ret = single._private[p2.field];
          }
          return _ret;
        }
        return self2;
      };
    },
    removeData: function removeData(params) {
      var defaults2 = {
        field: "data",
        event: "data",
        triggerFnName: "trigger",
        triggerEvent: false,
        immutableKeys: {}
      };
      params = extend({}, defaults2, params);
      return function removeDataImpl(names) {
        var p2 = params;
        var self2 = this;
        var selfIsArrayLike = self2.length !== void 0;
        var all = selfIsArrayLike ? self2 : [self2];
        if (string(names)) {
          var keys = names.split(/\s+/);
          var l = keys.length;
          for (var i2 = 0; i2 < l; i2++) {
            var key = keys[i2];
            if (emptyString(key)) {
              continue;
            }
            var valid2 = !p2.immutableKeys[key];
            if (valid2) {
              for (var i_a = 0, l_a = all.length; i_a < l_a; i_a++) {
                all[i_a]._private[p2.field][key] = void 0;
              }
            }
          }
          if (p2.triggerEvent) {
            self2[p2.triggerFnName](p2.event);
          }
        } else if (names === void 0) {
          for (var _i_a = 0, _l_a = all.length; _i_a < _l_a; _i_a++) {
            var _privateFields = all[_i_a]._private[p2.field];
            var _keys = Object.keys(_privateFields);
            for (var _i2 = 0; _i2 < _keys.length; _i2++) {
              var _key = _keys[_i2];
              var validKeyToDelete = !p2.immutableKeys[_key];
              if (validKeyToDelete) {
                _privateFields[_key] = void 0;
              }
            }
          }
          if (p2.triggerEvent) {
            self2[p2.triggerFnName](p2.event);
          }
        }
        return self2;
      };
    }
  };
  var define$1 = {
    eventAliasesOn: function eventAliasesOn(proto) {
      var p2 = proto;
      p2.addListener = p2.listen = p2.bind = p2.on;
      p2.unlisten = p2.unbind = p2.off = p2.removeListener;
      p2.trigger = p2.emit;
      p2.pon = p2.promiseOn = function(events, selector2) {
        var self2 = this;
        var args = Array.prototype.slice.call(arguments, 0);
        return new Promise$1(function(resolve2, reject) {
          var callback = function callback2(e) {
            self2.off.apply(self2, offArgs);
            resolve2(e);
          };
          var onArgs = args.concat([callback]);
          var offArgs = onArgs.concat([]);
          self2.on.apply(self2, onArgs);
        });
      };
    }
  };
  var define2 = {};
  [define$3, define$2, define$1].forEach(function(m) {
    extend(define2, m);
  });
  var elesfn$i = {
    animate: define2.animate(),
    animation: define2.animation(),
    animated: define2.animated(),
    clearQueue: define2.clearQueue(),
    delay: define2.delay(),
    delayAnimation: define2.delayAnimation(),
    stop: define2.stop()
  };
  var elesfn$h = {
    classes: function classes(_classes) {
      var self2 = this;
      if (_classes === void 0) {
        var ret = [];
        self2[0]._private.classes.forEach(function(cls2) {
          return ret.push(cls2);
        });
        return ret;
      } else if (!array(_classes)) {
        _classes = (_classes || "").match(/\S+/g) || [];
      }
      var changed = [];
      var classesSet = new Set$1(_classes);
      for (var j = 0; j < self2.length; j++) {
        var ele = self2[j];
        var _p = ele._private;
        var eleClasses = _p.classes;
        var changedEle = false;
        for (var i2 = 0; i2 < _classes.length; i2++) {
          var cls = _classes[i2];
          var eleHasClass = eleClasses.has(cls);
          if (!eleHasClass) {
            changedEle = true;
            break;
          }
        }
        if (!changedEle) {
          changedEle = eleClasses.size !== _classes.length;
        }
        if (changedEle) {
          _p.classes = classesSet;
          changed.push(ele);
        }
      }
      if (changed.length > 0) {
        this.spawn(changed).updateStyle().emit("class");
      }
      return self2;
    },
    addClass: function addClass(classes) {
      return this.toggleClass(classes, true);
    },
    hasClass: function hasClass(className) {
      var ele = this[0];
      return ele != null && ele._private.classes.has(className);
    },
    toggleClass: function toggleClass(classes, toggle) {
      if (!array(classes)) {
        classes = classes.match(/\S+/g) || [];
      }
      var self2 = this;
      var toggleUndefd = toggle === void 0;
      var changed = [];
      for (var i2 = 0, il = self2.length; i2 < il; i2++) {
        var ele = self2[i2];
        var eleClasses = ele._private.classes;
        var changedEle = false;
        for (var j = 0; j < classes.length; j++) {
          var cls = classes[j];
          var hasClass = eleClasses.has(cls);
          var changedNow = false;
          if (toggle || toggleUndefd && !hasClass) {
            eleClasses.add(cls);
            changedNow = true;
          } else if (!toggle || toggleUndefd && hasClass) {
            eleClasses["delete"](cls);
            changedNow = true;
          }
          if (!changedEle && changedNow) {
            changed.push(ele);
            changedEle = true;
          }
        }
      }
      if (changed.length > 0) {
        this.spawn(changed).updateStyle().emit("class");
      }
      return self2;
    },
    removeClass: function removeClass(classes) {
      return this.toggleClass(classes, false);
    },
    flashClass: function flashClass(classes, duration) {
      var self2 = this;
      if (duration == null) {
        duration = 250;
      } else if (duration === 0) {
        return self2;
      }
      self2.addClass(classes);
      setTimeout(function() {
        self2.removeClass(classes);
      }, duration);
      return self2;
    }
  };
  elesfn$h.className = elesfn$h.classNames = elesfn$h.classes;
  var tokens = {
    metaChar: "[\\!\\\"\\#\\$\\%\\&\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]",
    comparatorOp: "=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=",
    boolOp: "\\?|\\!|\\^",
    string: `"(?:\\\\"|[^"])*"|'(?:\\\\'|[^'])*'`,
    number,
    meta: "degree|indegree|outdegree",
    separator: "\\s*,\\s*",
    descendant: "\\s+",
    child: "\\s+>\\s+",
    subject: "\\$",
    group: "node|edge|\\*",
    directedEdge: "\\s+->\\s+",
    undirectedEdge: "\\s+<->\\s+"
  };
  tokens.variable = "(?:[\\w-.]|(?:\\\\" + tokens.metaChar + "))+";
  tokens.className = "(?:[\\w-]|(?:\\\\" + tokens.metaChar + "))+";
  tokens.value = tokens.string + "|" + tokens.number;
  tokens.id = tokens.variable;
  (function() {
    var ops, op, i2;
    ops = tokens.comparatorOp.split("|");
    for (i2 = 0; i2 < ops.length; i2++) {
      op = ops[i2];
      tokens.comparatorOp += "|@" + op;
    }
    ops = tokens.comparatorOp.split("|");
    for (i2 = 0; i2 < ops.length; i2++) {
      op = ops[i2];
      if (op.indexOf("!") >= 0) {
        continue;
      }
      if (op === "=") {
        continue;
      }
      tokens.comparatorOp += "|\\!" + op;
    }
  })();
  var newQuery = function newQuery2() {
    return {
      checks: []
    };
  };
  var Type$2 = {
    GROUP: 0,
    COLLECTION: 1,
    FILTER: 2,
    DATA_COMPARE: 3,
    DATA_EXIST: 4,
    DATA_BOOL: 5,
    META_COMPARE: 6,
    STATE: 7,
    ID: 8,
    CLASS: 9,
    UNDIRECTED_EDGE: 10,
    DIRECTED_EDGE: 11,
    NODE_SOURCE: 12,
    NODE_TARGET: 13,
    NODE_NEIGHBOR: 14,
    CHILD: 15,
    DESCENDANT: 16,
    PARENT: 17,
    ANCESTOR: 18,
    COMPOUND_SPLIT: 19,
    TRUE: 20
  };
  var stateSelectors = [{
    selector: ":selected",
    matches: function matches2(ele) {
      return ele.selected();
    }
  }, {
    selector: ":unselected",
    matches: function matches2(ele) {
      return !ele.selected();
    }
  }, {
    selector: ":selectable",
    matches: function matches2(ele) {
      return ele.selectable();
    }
  }, {
    selector: ":unselectable",
    matches: function matches2(ele) {
      return !ele.selectable();
    }
  }, {
    selector: ":locked",
    matches: function matches2(ele) {
      return ele.locked();
    }
  }, {
    selector: ":unlocked",
    matches: function matches2(ele) {
      return !ele.locked();
    }
  }, {
    selector: ":visible",
    matches: function matches2(ele) {
      return ele.visible();
    }
  }, {
    selector: ":hidden",
    matches: function matches2(ele) {
      return !ele.visible();
    }
  }, {
    selector: ":transparent",
    matches: function matches2(ele) {
      return ele.transparent();
    }
  }, {
    selector: ":grabbed",
    matches: function matches2(ele) {
      return ele.grabbed();
    }
  }, {
    selector: ":free",
    matches: function matches2(ele) {
      return !ele.grabbed();
    }
  }, {
    selector: ":removed",
    matches: function matches2(ele) {
      return ele.removed();
    }
  }, {
    selector: ":inside",
    matches: function matches2(ele) {
      return !ele.removed();
    }
  }, {
    selector: ":grabbable",
    matches: function matches2(ele) {
      return ele.grabbable();
    }
  }, {
    selector: ":ungrabbable",
    matches: function matches2(ele) {
      return !ele.grabbable();
    }
  }, {
    selector: ":animated",
    matches: function matches2(ele) {
      return ele.animated();
    }
  }, {
    selector: ":unanimated",
    matches: function matches2(ele) {
      return !ele.animated();
    }
  }, {
    selector: ":parent",
    matches: function matches2(ele) {
      return ele.isParent();
    }
  }, {
    selector: ":childless",
    matches: function matches2(ele) {
      return ele.isChildless();
    }
  }, {
    selector: ":child",
    matches: function matches2(ele) {
      return ele.isChild();
    }
  }, {
    selector: ":orphan",
    matches: function matches2(ele) {
      return ele.isOrphan();
    }
  }, {
    selector: ":nonorphan",
    matches: function matches2(ele) {
      return ele.isChild();
    }
  }, {
    selector: ":compound",
    matches: function matches2(ele) {
      if (ele.isNode()) {
        return ele.isParent();
      } else {
        return ele.source().isParent() || ele.target().isParent();
      }
    }
  }, {
    selector: ":loop",
    matches: function matches2(ele) {
      return ele.isLoop();
    }
  }, {
    selector: ":simple",
    matches: function matches2(ele) {
      return ele.isSimple();
    }
  }, {
    selector: ":active",
    matches: function matches2(ele) {
      return ele.active();
    }
  }, {
    selector: ":inactive",
    matches: function matches2(ele) {
      return !ele.active();
    }
  }, {
    selector: ":backgrounding",
    matches: function matches2(ele) {
      return ele.backgrounding();
    }
  }, {
    selector: ":nonbackgrounding",
    matches: function matches2(ele) {
      return !ele.backgrounding();
    }
  }].sort(function(a, b) {
    return descending(a.selector, b.selector);
  });
  var lookup = function() {
    var selToFn = {};
    var s;
    for (var i2 = 0; i2 < stateSelectors.length; i2++) {
      s = stateSelectors[i2];
      selToFn[s.selector] = s.matches;
    }
    return selToFn;
  }();
  var stateSelectorMatches = function stateSelectorMatches2(sel, ele) {
    return lookup[sel](ele);
  };
  var stateSelectorRegex = "(" + stateSelectors.map(function(s) {
    return s.selector;
  }).join("|") + ")";
  var cleanMetaChars = function cleanMetaChars2(str) {
    return str.replace(new RegExp("\\\\(" + tokens.metaChar + ")", "g"), function(match2, $1) {
      return $1;
    });
  };
  var replaceLastQuery = function replaceLastQuery2(selector2, examiningQuery, replacementQuery) {
    selector2[selector2.length - 1] = replacementQuery;
  };
  var exprs = [{
    name: "group",
    query: true,
    regex: "(" + tokens.group + ")",
    populate: function populate(selector2, query, _ref) {
      var _ref2 = _slicedToArray(_ref, 1), group = _ref2[0];
      query.checks.push({
        type: Type$2.GROUP,
        value: group === "*" ? group : group + "s"
      });
    }
  }, {
    name: "state",
    query: true,
    regex: stateSelectorRegex,
    populate: function populate(selector2, query, _ref3) {
      var _ref4 = _slicedToArray(_ref3, 1), state = _ref4[0];
      query.checks.push({
        type: Type$2.STATE,
        value: state
      });
    }
  }, {
    name: "id",
    query: true,
    regex: "\\#(" + tokens.id + ")",
    populate: function populate(selector2, query, _ref5) {
      var _ref6 = _slicedToArray(_ref5, 1), id2 = _ref6[0];
      query.checks.push({
        type: Type$2.ID,
        value: cleanMetaChars(id2)
      });
    }
  }, {
    name: "className",
    query: true,
    regex: "\\.(" + tokens.className + ")",
    populate: function populate(selector2, query, _ref7) {
      var _ref8 = _slicedToArray(_ref7, 1), className = _ref8[0];
      query.checks.push({
        type: Type$2.CLASS,
        value: cleanMetaChars(className)
      });
    }
  }, {
    name: "dataExists",
    query: true,
    regex: "\\[\\s*(" + tokens.variable + ")\\s*\\]",
    populate: function populate(selector2, query, _ref9) {
      var _ref10 = _slicedToArray(_ref9, 1), variable = _ref10[0];
      query.checks.push({
        type: Type$2.DATA_EXIST,
        field: cleanMetaChars(variable)
      });
    }
  }, {
    name: "dataCompare",
    query: true,
    regex: "\\[\\s*(" + tokens.variable + ")\\s*(" + tokens.comparatorOp + ")\\s*(" + tokens.value + ")\\s*\\]",
    populate: function populate(selector2, query, _ref11) {
      var _ref12 = _slicedToArray(_ref11, 3), variable = _ref12[0], comparatorOp = _ref12[1], value = _ref12[2];
      var valueIsString = new RegExp("^" + tokens.string + "$").exec(value) != null;
      if (valueIsString) {
        value = value.substring(1, value.length - 1);
      } else {
        value = parseFloat(value);
      }
      query.checks.push({
        type: Type$2.DATA_COMPARE,
        field: cleanMetaChars(variable),
        operator: comparatorOp,
        value
      });
    }
  }, {
    name: "dataBool",
    query: true,
    regex: "\\[\\s*(" + tokens.boolOp + ")\\s*(" + tokens.variable + ")\\s*\\]",
    populate: function populate(selector2, query, _ref13) {
      var _ref14 = _slicedToArray(_ref13, 2), boolOp = _ref14[0], variable = _ref14[1];
      query.checks.push({
        type: Type$2.DATA_BOOL,
        field: cleanMetaChars(variable),
        operator: boolOp
      });
    }
  }, {
    name: "metaCompare",
    query: true,
    regex: "\\[\\[\\s*(" + tokens.meta + ")\\s*(" + tokens.comparatorOp + ")\\s*(" + tokens.number + ")\\s*\\]\\]",
    populate: function populate(selector2, query, _ref15) {
      var _ref16 = _slicedToArray(_ref15, 3), meta2 = _ref16[0], comparatorOp = _ref16[1], number2 = _ref16[2];
      query.checks.push({
        type: Type$2.META_COMPARE,
        field: cleanMetaChars(meta2),
        operator: comparatorOp,
        value: parseFloat(number2)
      });
    }
  }, {
    name: "nextQuery",
    separator: true,
    regex: tokens.separator,
    populate: function populate(selector2, query) {
      var currentSubject = selector2.currentSubject;
      var edgeCount = selector2.edgeCount;
      var compoundCount = selector2.compoundCount;
      var lastQ = selector2[selector2.length - 1];
      if (currentSubject != null) {
        lastQ.subject = currentSubject;
        selector2.currentSubject = null;
      }
      lastQ.edgeCount = edgeCount;
      lastQ.compoundCount = compoundCount;
      selector2.edgeCount = 0;
      selector2.compoundCount = 0;
      var nextQuery = selector2[selector2.length++] = newQuery();
      return nextQuery;
    }
  }, {
    name: "directedEdge",
    separator: true,
    regex: tokens.directedEdge,
    populate: function populate(selector2, query) {
      if (selector2.currentSubject == null) {
        var edgeQuery = newQuery();
        var source = query;
        var target = newQuery();
        edgeQuery.checks.push({
          type: Type$2.DIRECTED_EDGE,
          source,
          target
        });
        replaceLastQuery(selector2, query, edgeQuery);
        selector2.edgeCount++;
        return target;
      } else {
        var srcTgtQ = newQuery();
        var _source = query;
        var _target = newQuery();
        srcTgtQ.checks.push({
          type: Type$2.NODE_SOURCE,
          source: _source,
          target: _target
        });
        replaceLastQuery(selector2, query, srcTgtQ);
        selector2.edgeCount++;
        return _target;
      }
    }
  }, {
    name: "undirectedEdge",
    separator: true,
    regex: tokens.undirectedEdge,
    populate: function populate(selector2, query) {
      if (selector2.currentSubject == null) {
        var edgeQuery = newQuery();
        var source = query;
        var target = newQuery();
        edgeQuery.checks.push({
          type: Type$2.UNDIRECTED_EDGE,
          nodes: [source, target]
        });
        replaceLastQuery(selector2, query, edgeQuery);
        selector2.edgeCount++;
        return target;
      } else {
        var nhoodQ = newQuery();
        var node = query;
        var neighbor = newQuery();
        nhoodQ.checks.push({
          type: Type$2.NODE_NEIGHBOR,
          node,
          neighbor
        });
        replaceLastQuery(selector2, query, nhoodQ);
        return neighbor;
      }
    }
  }, {
    name: "child",
    separator: true,
    regex: tokens.child,
    populate: function populate(selector2, query) {
      if (selector2.currentSubject == null) {
        var parentChildQuery = newQuery();
        var child = newQuery();
        var parent = selector2[selector2.length - 1];
        parentChildQuery.checks.push({
          type: Type$2.CHILD,
          parent,
          child
        });
        replaceLastQuery(selector2, query, parentChildQuery);
        selector2.compoundCount++;
        return child;
      } else if (selector2.currentSubject === query) {
        var compound = newQuery();
        var left = selector2[selector2.length - 1];
        var right = newQuery();
        var subject = newQuery();
        var _child = newQuery();
        var _parent = newQuery();
        compound.checks.push({
          type: Type$2.COMPOUND_SPLIT,
          left,
          right,
          subject
        });
        subject.checks = query.checks;
        query.checks = [{
          type: Type$2.TRUE
        }];
        _parent.checks.push({
          type: Type$2.TRUE
        });
        right.checks.push({
          type: Type$2.PARENT,
          parent: _parent,
          child: _child
        });
        replaceLastQuery(selector2, left, compound);
        selector2.currentSubject = subject;
        selector2.compoundCount++;
        return _child;
      } else {
        var _parent2 = newQuery();
        var _child2 = newQuery();
        var pcQChecks = [{
          type: Type$2.PARENT,
          parent: _parent2,
          child: _child2
        }];
        _parent2.checks = query.checks;
        query.checks = pcQChecks;
        selector2.compoundCount++;
        return _child2;
      }
    }
  }, {
    name: "descendant",
    separator: true,
    regex: tokens.descendant,
    populate: function populate(selector2, query) {
      if (selector2.currentSubject == null) {
        var ancChQuery = newQuery();
        var descendant = newQuery();
        var ancestor = selector2[selector2.length - 1];
        ancChQuery.checks.push({
          type: Type$2.DESCENDANT,
          ancestor,
          descendant
        });
        replaceLastQuery(selector2, query, ancChQuery);
        selector2.compoundCount++;
        return descendant;
      } else if (selector2.currentSubject === query) {
        var compound = newQuery();
        var left = selector2[selector2.length - 1];
        var right = newQuery();
        var subject = newQuery();
        var _descendant = newQuery();
        var _ancestor = newQuery();
        compound.checks.push({
          type: Type$2.COMPOUND_SPLIT,
          left,
          right,
          subject
        });
        subject.checks = query.checks;
        query.checks = [{
          type: Type$2.TRUE
        }];
        _ancestor.checks.push({
          type: Type$2.TRUE
        });
        right.checks.push({
          type: Type$2.ANCESTOR,
          ancestor: _ancestor,
          descendant: _descendant
        });
        replaceLastQuery(selector2, left, compound);
        selector2.currentSubject = subject;
        selector2.compoundCount++;
        return _descendant;
      } else {
        var _ancestor2 = newQuery();
        var _descendant2 = newQuery();
        var adQChecks = [{
          type: Type$2.ANCESTOR,
          ancestor: _ancestor2,
          descendant: _descendant2
        }];
        _ancestor2.checks = query.checks;
        query.checks = adQChecks;
        selector2.compoundCount++;
        return _descendant2;
      }
    }
  }, {
    name: "subject",
    modifier: true,
    regex: tokens.subject,
    populate: function populate(selector2, query) {
      if (selector2.currentSubject != null && selector2.currentSubject !== query) {
        warn("Redefinition of subject in selector `" + selector2.toString() + "`");
        return false;
      }
      selector2.currentSubject = query;
      var topQ = selector2[selector2.length - 1];
      var topChk = topQ.checks[0];
      var topType = topChk == null ? null : topChk.type;
      if (topType === Type$2.DIRECTED_EDGE) {
        topChk.type = Type$2.NODE_TARGET;
      } else if (topType === Type$2.UNDIRECTED_EDGE) {
        topChk.type = Type$2.NODE_NEIGHBOR;
        topChk.node = topChk.nodes[1];
        topChk.neighbor = topChk.nodes[0];
        topChk.nodes = null;
      }
    }
  }];
  exprs.forEach(function(e) {
    return e.regexObj = new RegExp("^" + e.regex);
  });
  var consumeExpr = function consumeExpr2(remaining) {
    var expr;
    var match2;
    var name2;
    for (var j = 0; j < exprs.length; j++) {
      var e = exprs[j];
      var n = e.name;
      var m = remaining.match(e.regexObj);
      if (m != null) {
        match2 = m;
        expr = e;
        name2 = n;
        var consumed = m[0];
        remaining = remaining.substring(consumed.length);
        break;
      }
    }
    return {
      expr,
      match: match2,
      name: name2,
      remaining
    };
  };
  var consumeWhitespace = function consumeWhitespace2(remaining) {
    var match2 = remaining.match(/^\s+/);
    if (match2) {
      var consumed = match2[0];
      remaining = remaining.substring(consumed.length);
    }
    return remaining;
  };
  var parse = function parse2(selector2) {
    var self2 = this;
    var remaining = self2.inputText = selector2;
    var currentQuery = self2[0] = newQuery();
    self2.length = 1;
    remaining = consumeWhitespace(remaining);
    for (; ; ) {
      var exprInfo = consumeExpr(remaining);
      if (exprInfo.expr == null) {
        warn("The selector `" + selector2 + "`is invalid